<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TouchKio Slideshow</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            cursor: none;
            user-select: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .slideshow-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transform-origin: center center;
        }

        /* Slideshow Entrance/Exit Animation Classes */
        .slideshow-entrance-animation {
            animation-fill-mode: both;
        }

        .slideshow-exit-animation {
            animation-fill-mode: both;
        }

        /* Default Animation Theme */
        .slideshow-entrance-default {
            animation-name: fadeIn;
        }

        .slideshow-exit-default {
            animation-name: fadeOut;
        }

        /* Elegant Animation Theme */
        .slideshow-entrance-elegant {
            animation-name: elegantIn;
        }

        /* Disable conflicting transitions during elegant entrance */
        .slideshow-entrance-elegant .photo,
        .slideshow-entrance-elegant .photo-background {
            transition: none !important;
        }

        .slideshow-exit-elegant {
            animation-name: elegantOut;
        }

        /* Disable conflicting transitions during elegant exit */
        .slideshow-exit-elegant .photo,
        .slideshow-exit-elegant .photo-background {
            transition: none !important;
        }

        /* Dynamic Animation Theme */
        .slideshow-entrance-dynamic {
            animation-name: dynamicIn;
        }

        .slideshow-exit-dynamic {
            animation-name: dynamicOut;
        }

        /* Minimal Animation Theme */
        .slideshow-entrance-minimal {
            animation-name: minimalIn;
        }

        .slideshow-exit-minimal {
            animation-name: minimalOut;
        }

        /* Playful Animation Theme */
        .slideshow-entrance-playful {
            animation-name: playfulIn;
        }

        .slideshow-exit-playful {
            animation-name: playfulOut;
        }

        /* Animation Keyframes */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Elegant animations - Simple clean fade */
        @keyframes elegantIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes elegantOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        /* Element zoom animations - These happen on the actual content */
        @keyframes elegantElementIn {
            from {
                transform: scale(1.5);
            }
            to {
                transform: scale(1);
            }
        }

        @keyframes elegantElementOut {
            from {
                transform: scale(1);
            }
            to {
                transform: scale(1.5);
            }
        }

        /* Special animations for photos that already have transforms */
        @keyframes elegantPhotoIn {
            from {
                transform: translate(-50%, -50%) scale(1.5);
            }
            to {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes elegantPhotoOut {
            from {
                transform: translate(-50%, -50%) scale(1);
            }
            to {
                transform: translate(-50%, -50%) scale(1.5);
            }
        }

        @keyframes dynamicIn {
            from {
                opacity: 0;
                transform: scale(0.8) rotate(-5deg);
            }
            to {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
        }

        @keyframes dynamicOut {
            from {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
            to {
                opacity: 0;
                transform: scale(1.2) rotate(5deg);
            }
        }

        @keyframes minimalIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes minimalOut {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(10px);
            }
        }

        @keyframes playfulIn {
            from {
                opacity: 0;
                transform: scale(0.5) rotate(180deg);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.1) rotate(90deg);
            }
            to {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
        }

        @keyframes playfulOut {
            from {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
            50% {
                opacity: 0.7;
                transform: scale(0.9) rotate(-90deg);
            }
            to {
                opacity: 0;
                transform: scale(0.5) rotate(-180deg);
            }
        }

        .photo-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-style: preserve-3d;
        }

        .photo-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: blur(20px) brightness(0.3);
            transform: scale(1.1);
            opacity: 0;
            transition: opacity 2s ease-in-out;
        }

        .photo {
            position: absolute;
            opacity: 0;
            transform: scale(1);
            filter: blur(0px);
            transition: all 2s ease-in-out;
            z-index: 1;
        }

        .photo.fit-contain {
            /* Smart contain: fill viewport height for square/landscape, width for portrait */
            width: auto;
            height: 100vh;
            max-width: 100vw;
            object-fit: contain;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .photo.fit-contain-original {
            /* Original contain behavior */
            max-width: 100vw;
            max-height: 100vh;
            width: auto;
            height: auto;
            object-fit: contain;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .photo.fit-cover {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .photo.fit-fill {
            width: 100%;
            height: 100%;
            object-fit: fill;
        }

        /* Removed orientation-specific fit modes - smart contain handles all cases */

        .photo.visible {
            opacity: 1;
        }

        .photo-background.visible {
            opacity: 1;
        }

        .photo.loading {
            opacity: 0.3;
        }

        /* Fade transition */
        .transition-fade .photo {
            transition: opacity 2s ease-in-out;
        }

        /* Slide transition */
        .transition-slide .photo {
            transform: translateX(100%);
            transition: transform 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-slide .photo.visible {
            transform: translateX(0);
        }

        /* Zoom transition */
        .transition-zoom .photo {
            transform: scale(0.8);
            transition: transform 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-zoom .photo.visible {
            transform: scale(1);
        }

        /* Blur transition */
        .transition-blur .photo {
            filter: blur(10px);
            transition: filter 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-blur .photo.visible {
            filter: blur(0px);
        }

        /* Rotate transition */
        .transition-rotate .photo {
            transform: rotate(-10deg) scale(0.9);
            transition: transform 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-rotate .photo.visible {
            transform: rotate(0deg) scale(1);
        }

        .overlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0px;
            line-height: 0.9;
            z-index: 10;
        }

        .overlay.pos-center {
            align-items: center;
        }

        .overlay.pos-top-left,
        .overlay.pos-bottom-left {
            align-items: flex-start;
        }

        .overlay.background-dark {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
        }

        .overlay.background-light {
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .overlay.background-none {
            background: none;
            backdrop-filter: none !important;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* Position classes */
        .pos-top-left { top: 20px; left: 20px; right: auto; bottom: auto; }
        .pos-top-right { top: 20px; right: 20px; left: auto; bottom: auto; }
        .pos-bottom-left { bottom: 20px; left: 20px; right: auto; top: auto; }
        .pos-bottom-right { bottom: 20px; right: 20px; left: auto; top: auto; }
        .pos-center {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            right: auto;
            bottom: auto;
        }


        .date.size-tiny { font-size: 0.6rem !important; }
        .date.size-small { font-size: 0.8rem !important; }
        .date.size-medium { font-size: 1rem !important; }
        .date.size-large { font-size: 1.2rem !important; }
        .date.size-xlarge { font-size: 1.6rem !important; }
        .date.size-xxlarge { font-size: 2.2rem !important; }
        .date.size-massive { font-size: 3rem !important; }
        .date.size-giant { font-size: 4rem !important; }

        /* Size classes for indicators */
        .size-small {
            padding: 8px 12px;
            font-size: 0.7rem;
        }
        .size-medium {
            padding: 10px 15px;
            font-size: 0.8rem;
        }
        .size-large {
            padding: 12px 18px;
            font-size: 0.9rem;
        }

        .clock {
            position: absolute;
            font-weight: 300;
            letter-spacing: 2px;
            line-height: 1;
            margin: 0;
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        .date {
            position: absolute;
            opacity: 0.8;
            line-height: 1;
            margin: 0;
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        .source-indicator {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
            /* NO default position - will be set by pos- classes */
        }

        .source-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        .source-icon.google {
            background: #4285f4;
        }

        .source-icon.local {
            background: #34a853;
        }

        .photo-counter {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
            /* NO default position - will be set by pos- classes */
        }

        /* Photo counter positioning - uses general .pos- classes */

        /* Source indicator size classes */
        .source-indicator.size-small {
            font-size: 0.7rem !important;
            padding: 8px 12px !important;
        }
        .source-indicator.size-medium {
            font-size: 0.9rem !important;
            padding: 10px 15px !important;
        }
        .source-indicator.size-large {
            font-size: 1.1rem !important;
            padding: 12px 18px !important;
        }

        /* Photo counter size classes */
        .photo-counter.size-small {
            font-size: 0.7rem !important;
            padding: 8px 12px !important;
        }
        .photo-counter.size-medium {
            font-size: 0.9rem !important;
            padding: 10px 15px !important;
        }
        .photo-counter.size-large {
            font-size: 1.1rem !important;
            padding: 12px 18px !important;
        }

        /* Source indicator background colors */
        .source-indicator.background-dark { background: rgba(0, 0, 0, 0.7) !important; color: white; }
        .source-indicator.background-light { background: rgba(255, 255, 255, 0.8) !important; color: #333; }
        .source-indicator.background-blue { background: rgba(52, 152, 219, 0.7) !important; color: white; }
        .source-indicator.background-green { background: rgba(46, 204, 113, 0.7) !important; color: white; }
        .source-indicator.background-red { background: rgba(231, 76, 60, 0.7) !important; color: white; }
        .source-indicator.background-purple { background: rgba(155, 89, 182, 0.7) !important; color: white; }
        .source-indicator.background-none { background: transparent !important; backdrop-filter: none !important; }

        /* Photo counter background colors */
        .photo-counter.background-dark { background: rgba(0, 0, 0, 0.7) !important; color: white; }
        .photo-counter.background-light { background: rgba(255, 255, 255, 0.8) !important; color: #333; }
        .photo-counter.background-blue { background: rgba(52, 152, 219, 0.7) !important; color: white; }
        .photo-counter.background-green { background: rgba(46, 204, 113, 0.7) !important; color: white; }
        .photo-counter.background-red { background: rgba(231, 76, 60, 0.7) !important; color: white; }
        .photo-counter.background-purple { background: rgba(155, 89, 182, 0.7) !important; color: white; }
        .photo-counter.background-none { background: transparent !important; backdrop-filter: none !important; }

        /* Background classes for clock and date */
        .clock.background-dark, .date.background-dark { background: rgba(0, 0, 0, 0.7) !important; color: white; }
        .clock.background-light, .date.background-light { background: rgba(255, 255, 255, 0.8) !important; color: #333; }
        .clock.background-blue, .date.background-blue { background: rgba(52, 152, 219, 0.7) !important; color: white; }
        .clock.background-green, .date.background-green { background: rgba(46, 204, 113, 0.7) !important; color: white; }
        .clock.background-red, .date.background-red { background: rgba(231, 76, 60, 0.7) !important; color: white; }
        .clock.background-purple, .date.background-purple { background: rgba(155, 89, 182, 0.7) !important; color: white; }
        .clock.background-none, .date.background-none { background: transparent !important; backdrop-filter: none !important; }

        /* Font size classes for all elements - high specificity to override size classes */
        .clock.font-size-tiny, .date.font-size-tiny { font-size: 0.6rem !important; }
        .clock.font-size-small, .date.font-size-small { font-size: 0.8rem !important; }
        .clock.font-size-medium, .date.font-size-medium { font-size: 1.0rem !important; }
        .clock.font-size-large, .date.font-size-large { font-size: 1.2rem !important; }
        .clock.font-size-xlarge, .date.font-size-xlarge { font-size: 1.4rem !important; }
        .clock.font-size-xxlarge, .date.font-size-xxlarge { font-size: 1.6rem !important; }

        .source-indicator.font-size-tiny { font-size: 0.6rem !important; }
        .source-indicator.font-size-small { font-size: 0.8rem !important; }
        .source-indicator.font-size-medium { font-size: 1.0rem !important; }
        .source-indicator.font-size-large { font-size: 1.2rem !important; }
        .source-indicator.font-size-xlarge { font-size: 1.4rem !important; }
        .source-indicator.font-size-xxlarge { font-size: 1.6rem !important; }

        .photo-counter.font-size-tiny { font-size: 0.6rem !important; }
        .photo-counter.font-size-small { font-size: 0.8rem !important; }
        .photo-counter.font-size-medium { font-size: 1.0rem !important; }
        .photo-counter.font-size-large { font-size: 1.2rem !important; }
        .photo-counter.font-size-xlarge { font-size: 1.4rem !important; }
        .photo-counter.font-size-xxlarge { font-size: 1.6rem !important; }

        .metadata-overlay {
            position: absolute;
            bottom: 20px;
            right: 50%;
            transform: translateX(50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.7rem;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
            text-align: center;
            max-width: 80%;
            display: none;
            transition: opacity 1s ease-in-out;
            opacity: 0;
        }

        .metadata-overlay.background-dark {
            background: rgba(0, 0, 0, 0.7);
        }

        .metadata-overlay.background-light {
            background: rgba(255, 255, 255, 0.3);
            color: #333;
        }

        .metadata-overlay.background-blue {
            background: rgba(52, 152, 219, 0.7);
            color: white;
        }

        .metadata-overlay.background-green {
            background: rgba(52, 168, 83, 0.7);
            color: white;
        }

        .metadata-overlay.background-red {
            background: rgba(231, 76, 60, 0.7);
            color: white;
        }

        .metadata-overlay.background-purple {
            background: rgba(155, 89, 182, 0.7);
            color: white;
        }

        .metadata-overlay.background-none {
            background: none !important;
            backdrop-filter: none !important;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .metadata-line {
            margin: 2px 0;
            line-height: 1.2;
        }

        .metadata-filename {
            font-weight: bold;
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .metadata-date {
            color: #ccc;
            font-size: 0.8em;
        }

        .metadata-camera {
            color: #aaa;
            font-size: 0.75em;
        }

        .metadata-exposure {
            color: #888;
            font-size: 0.7em;
            font-family: monospace;
        }

        .metadata-location {
            color: #999;
            font-size: 0.7em;
        }

        /* Metadata overlay positioning */
        .metadata-overlay.pos-top-left { top: 20px; left: 20px; right: auto; bottom: auto; transform: none; }
        .metadata-overlay.pos-top-center { top: 20px; left: 50%; right: auto; bottom: auto; transform: translateX(-50%); }
        .metadata-overlay.pos-top-right { top: 20px; right: 20px; left: auto; bottom: auto; transform: none; }
        .metadata-overlay.pos-bottom-left { bottom: 20px; left: 20px; right: auto; top: auto; transform: none; }
        .metadata-overlay.pos-bottom-center {
            bottom: 20px;
            left: 50%;
            right: auto;
            top: auto;
            transform: translateX(-50%);
        }
        .metadata-overlay.pos-bottom-right { bottom: 20px; right: 20px; left: auto; top: auto; transform: none; }
        .metadata-overlay.pos-center {
            top: 50%;
            left: 50%;
            right: auto;
            bottom: auto;
            transform: translate(-50%, -50%);
        }

        /* Font size classes for metadata */
        .metadata-overlay.font-tiny { font-size: 0.5rem !important; }
        .metadata-overlay.font-small { font-size: 0.7rem !important; }
        .metadata-overlay.font-medium { font-size: 0.9rem !important; }
        .metadata-overlay.font-large { font-size: 1.1rem !important; }
        .metadata-overlay.font-xlarge { font-size: 1.4rem !important; }
        .metadata-overlay.font-xxlarge { font-size: 1.8rem !important; }

        /* Smooth text content transitions - overlay stays in place */
        .metadata-overlay.visible {
            opacity: 1;
        }

        .metadata-overlay.transitioning {
            opacity: 0.3;
        }

        /* Individual metadata line transitions */
        .metadata-line {
            transition: opacity 1s ease-in-out, filter 1s ease-in-out;
        }

        .metadata-line.fade-out {
            opacity: 0;
        }

        .metadata-line.blur-out {
            opacity: 0;
            filter: blur(3px);
        }

        .metadata-line.slide-up-out {
            opacity: 0;
            transform: translateY(-20px);
        }

        .metadata-line.slide-down-out {
            opacity: 0;
            transform: translateY(20px);
        }

        .metadata-line.glow-out {
            opacity: 0;
            text-shadow: 0 0 15px currentColor;
        }

        .metadata-line.typewriter-out {
            opacity: 0;
            letter-spacing: 0.2em;
        }

        /* Enhanced transitions for transform effects */
        .metadata-line {
            transition: opacity 1s ease-in-out, filter 1s ease-in-out, transform 1s ease-in-out, text-shadow 1s ease-in-out, letter-spacing 1s ease-in-out;
        }

        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.9);
            padding: 20px 30px;
            border-radius: 10px;
            font-size: 1.2rem;
            text-align: center;
            display: none;
        }

        .no-photos {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0.7;
        }

        .no-photos h2 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .no-photos p {
            font-size: 1.2rem;
        }

        .preload-container {
            position: absolute;
            top: -9999px;
            left: -9999px;
            opacity: 0;
            pointer-events: none;
        }

        /* ================================
           PHASE 4A: ANIMATION FRAMEWORK
           ================================ */

        /* Animation Duration Utilities */
        :root {
            --animation-speed-multiplier: 1.0;
            --animation-duration-fast: calc(0.3s * var(--animation-speed-multiplier));
            --animation-duration-normal: calc(0.6s * var(--animation-speed-multiplier));
            --animation-duration-slow: calc(1.2s * var(--animation-speed-multiplier));
            --animation-duration-position: calc(0.8s * var(--animation-speed-multiplier));
            --animation-duration-content: calc(0.4s * var(--animation-speed-multiplier));
        }

        /* Animation Easing Presets */
        .animate-ease-smooth { animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1); }
        .animate-ease-bounce { animation-timing-function: cubic-bezier(0.68, -0.55, 0.265, 1.55); }
        .animate-ease-elastic { animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .animate-ease-back { animation-timing-function: cubic-bezier(0.68, -0.55, 0.265, 1.55); }

        /* Base Animation Classes */
        .animate-enabled {
            transition-property: transform, opacity, left, top, right, bottom;
            transition-duration: var(--animation-duration-normal);
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        }

        .animate-position {
            transition-property: left, top, right, bottom, transform;
            transition-duration: var(--animation-duration-position);
            transition-timing-function: cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .animate-content {
            transition-property: opacity;
            transition-duration: var(--animation-duration-content);
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Entrance Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideInFromLeft {
            from {
                opacity: 0;
                transform: translateX(-100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideInFromRight {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideInFromTop {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInFromBottom {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes bounceIn {
            0% {
                opacity: 0;
                transform: scale(0.3) translateY(-30px);
            }
            50% {
                opacity: 1;
                transform: scale(1.05) translateY(0);
            }
            70% {
                transform: scale(0.95);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Exit Animations */
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        @keyframes slideOutToLeft {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(-100px);
            }
        }

        @keyframes slideOutToRight {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(100px);
            }
        }

        @keyframes scaleOut {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0.8);
            }
        }

        /* Animation State Classes */
        .animate-fade-in {
            animation: fadeIn var(--animation-duration-normal) ease-out;
        }

        .animate-slide-in-left {
            animation: slideInFromLeft var(--animation-duration-normal) cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .animate-slide-in-right {
            animation: slideInFromRight var(--animation-duration-normal) cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .animate-slide-in-top {
            animation: slideInFromTop var(--animation-duration-normal) cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .animate-slide-in-bottom {
            animation: slideInFromBottom var(--animation-duration-normal) cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .animate-scale-in {
            animation: scaleIn var(--animation-duration-normal) cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .animate-bounce-in {
            animation: bounceIn var(--animation-duration-slow) cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .animate-fade-out {
            animation: fadeOut var(--animation-duration-normal) ease-in;
        }

        .animate-slide-out-left {
            animation: slideOutToLeft var(--animation-duration-normal) cubic-bezier(0.55, 0.085, 0.68, 0.53);
        }

        .animate-slide-out-right {
            animation: slideOutToRight var(--animation-duration-normal) cubic-bezier(0.55, 0.085, 0.68, 0.53);
        }

        .animate-scale-out {
            animation: scaleOut var(--animation-duration-normal) cubic-bezier(0.55, 0.085, 0.68, 0.53);
        }

        /* Additional animation keyframes for partial fade */
        @keyframes fadeOutPartial {
            from { opacity: 1; }
            to { opacity: 0.3; }
        }

        /* Additional animation classes for JavaScript controller */
        .animate-fade-out-partial {
            animation: fadeOutPartial var(--animation-duration-fast) ease-in forwards;
        }

        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }

        /* Animation Disabled State */
        .animations-disabled * {
            animation: none !important;
            transition: none !important;
        }

        @media (max-width: 768px) {
            .clock {
                font-size: 2rem;
            }

            .overlay {
                bottom: 10px;
                right: 10px;
                padding: 10px 15px;
            }

            .source-indicator,
            .photo-counter {
                padding: 8px 12px;
                font-size: 0.8rem;
                /* Removed fixed positioning - pos- classes will handle this */
            }
        }
    </style>
</head>
<body>
    <div class="slideshow-container">
        <div class="photo-container">
            <img id="bg1" class="photo-background" alt="Background 1">
            <img id="bg2" class="photo-background" alt="Background 2">
            <img id="photo1" class="photo" alt="Slideshow Photo 1">
            <img id="photo2" class="photo" alt="Slideshow Photo 2">
            <div class="preload-container">
                <img id="preloadPhoto" alt="Preload Photo">
            </div>
        </div>

        <div class="source-indicator pos-top-left size-medium">
            <div class="source-icon" id="sourceIcon"></div>
            <span id="sourceText">Local Photos</span>
        </div>

        <div class="photo-counter pos-bottom-left size-medium">
            <span id="photoCounter">0 / 0</span>
        </div>

        <div class="metadata-overlay" id="metadataOverlay">
            <div class="metadata-line metadata-filename" id="metadataFilename"></div>
            <div class="metadata-line metadata-date" id="metadataDate"></div>
            <div class="metadata-line metadata-camera" id="metadataCamera"></div>
            <div class="metadata-line metadata-exposure" id="metadataExposure"></div>
            <div class="metadata-line metadata-location" id="metadataLocation"></div>
        </div>

        <div class="clock pos-bottom-right size-large background-dark" id="clock">00:00</div>
        <div class="date pos-bottom-left size-medium background-dark" id="date">Loading...</div>

        <div class="loading-indicator" id="loadingIndicator">
            <div class="spinner"></div>
        </div>

        <div class="error-message" id="errorMessage">
            Failed to load photo
        </div>

        <div class="no-photos" id="noPhotos" style="display: none;">
            <h2>No Photos Available</h2>
            <p>Add photos to your Pictures folder or configure Google Photos</p>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');

        let config = {};
        let photos = [];
        let currentIndex = 0;
        let clockInterval = null;
        let currentPhotoElement = 1; // Track which photo element is currently visible

        const elements = {
            bg1: document.getElementById('bg1'),
            bg2: document.getElementById('bg2'),
            photo1: document.getElementById('photo1'),
            photo2: document.getElementById('photo2'),
            preloadPhoto: document.getElementById('preloadPhoto'),
            sourceIcon: document.getElementById('sourceIcon'),
            sourceText: document.getElementById('sourceText'),
            photoCounter: document.getElementById('photoCounter'),
            metadataOverlay: document.getElementById('metadataOverlay'),
            metadataFilename: document.getElementById('metadataFilename'),
            metadataDate: document.getElementById('metadataDate'),
            metadataCamera: document.getElementById('metadataCamera'),
            metadataExposure: document.getElementById('metadataExposure'),
            metadataLocation: document.getElementById('metadataLocation'),
            clock: document.getElementById('clock'),
            date: document.getElementById('date'),
            loadingIndicator: document.getElementById('loadingIndicator'),
            errorMessage: document.getElementById('errorMessage'),
            noPhotos: document.getElementById('noPhotos')
        };

        // TouchKio Animation Controller - Phase 4A: Animation Foundation
        class TouchKioAnimator {
            constructor() {
                this.animationQueue = [];
                this.currentAnimations = new Map();
                this.globalSpeed = 1.0;
                this.reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            }

            // Set global animation speed multiplier
            setGlobalSpeed(speed) {
                this.globalSpeed = Math.max(0.1, Math.min(5.0, speed));
                document.documentElement.style.setProperty('--animation-speed-multiplier', this.globalSpeed);
            }

            // Animate element with specified animation type
            animate(element, animationType, options = {}) {
                if (!element || this.reducedMotion) return Promise.resolve();

                const {
                    duration = 'normal',
                    delay = 0,
                    easing = 'ease-out',
                    direction = 'normal',
                    fillMode = 'both',
                    onComplete = null
                } = options;

                // Cancel any existing animation on this element
                this.cancelAnimation(element);

                return new Promise((resolve) => {
                    const animationClass = `animate-${animationType}`;

                    // Apply animation class
                    element.classList.add(animationClass);

                    // Set custom animation properties if needed
                    if (duration !== 'normal') {
                        element.style.animationDuration = this.getDurationValue(duration);
                    }
                    if (delay > 0) {
                        element.style.animationDelay = `${delay}ms`;
                    }
                    if (easing !== 'ease-out') {
                        element.style.animationTimingFunction = easing;
                    }
                    if (direction !== 'normal') {
                        element.style.animationDirection = direction;
                    }
                    if (fillMode !== 'both') {
                        element.style.animationFillMode = fillMode;
                    }

                    // Track this animation
                    const animationData = {
                        element,
                        class: animationClass,
                        resolve,
                        onComplete
                    };
                    this.currentAnimations.set(element, animationData);

                    // Listen for animation end
                    const handleAnimationEnd = (event) => {
                        if (event.target === element) {
                            element.removeEventListener('animationend', handleAnimationEnd);
                            this.cleanupAnimation(element);
                            if (onComplete) onComplete();
                            resolve();
                        }
                    };

                    element.addEventListener('animationend', handleAnimationEnd);

                    // Fallback timeout in case animationend doesn't fire
                    setTimeout(() => {
                        if (this.currentAnimations.has(element)) {
                            element.removeEventListener('animationend', handleAnimationEnd);
                            this.cleanupAnimation(element);
                            if (onComplete) onComplete();
                            resolve();
                        }
                    }, this.getDurationMs(duration) + delay + 100);
                });
            }

            // Cancel animation on element
            cancelAnimation(element) {
                if (this.currentAnimations.has(element)) {
                    const animationData = this.currentAnimations.get(element);
                    element.classList.remove(animationData.class);
                    this.cleanupAnimation(element);
                }
            }

            // Clean up animation styles and tracking
            cleanupAnimation(element) {
                if (this.currentAnimations.has(element)) {
                    const animationData = this.currentAnimations.get(element);
                    element.classList.remove(animationData.class);

                    // Reset custom animation properties
                    element.style.animationDuration = '';
                    element.style.animationDelay = '';
                    element.style.animationTimingFunction = '';
                    element.style.animationDirection = '';
                    element.style.animationFillMode = '';

                    this.currentAnimations.delete(element);
                }
            }

            // Get duration value for CSS
            getDurationValue(duration) {
                const speeds = {
                    'fast': 'var(--animation-duration-fast)',
                    'normal': 'var(--animation-duration-normal)',
                    'slow': 'var(--animation-duration-slow)',
                    'position': 'var(--animation-duration-position)',
                    'content': 'var(--animation-duration-content)'
                };
                return speeds[duration] || `${duration}ms`;
            }

            // Get duration in milliseconds for timeouts
            getDurationMs(duration) {
                const baseSpeeds = {
                    'fast': 300,
                    'normal': 600,
                    'slow': 1200,
                    'position': 800,
                    'content': 400
                };
                const baseMs = baseSpeeds[duration] || parseInt(duration) || 600;
                return Math.round(baseMs / this.globalSpeed);
            }

            // Batch animate multiple elements
            async animateSequence(animations, options = {}) {
                const { parallel = false, stagger = 0 } = options;

                if (parallel) {
                    // Run all animations in parallel
                    const promises = animations.map((anim, index) => {
                        const delay = (anim.delay || 0) + (stagger * index);
                        return this.animate(anim.element, anim.type, { ...anim.options, delay });
                    });
                    return Promise.all(promises);
                } else {
                    // Run animations sequentially
                    for (let i = 0; i < animations.length; i++) {
                        const anim = animations[i];
                        if (stagger > 0 && i > 0) {
                            await new Promise(resolve => setTimeout(resolve, stagger));
                        }
                        await this.animate(anim.element, anim.type, anim.options);
                    }
                }
            }

            // Cancel all animations
            cancelAllAnimations() {
                for (const element of this.currentAnimations.keys()) {
                    this.cancelAnimation(element);
                }
            }

            // Entrance animations for slideshow elements
            async animateElementEntrance(element, type = 'fadeIn', delay = 0) {
                return this.animate(element, type, { delay, duration: 'content' });
            }

            // Exit animations for slideshow elements
            async animateElementExit(element, type = 'fadeOut', delay = 0) {
                return this.animate(element, type, { delay, duration: 'content' });
            }

            // Position change animations
            async animatePositionChange(element, newClasses = [], delay = 0) {
                // First fade out slightly
                await this.animate(element, 'fade-out-partial', {
                    duration: 'fast',
                    delay
                });

                // Apply new position classes
                if (newClasses.length > 0) {
                    newClasses.forEach(cls => element.classList.add(cls));
                }

                // Fade back in
                return this.animate(element, 'fadeIn', {
                    duration: 'position'
                });
            }
        }

        // Initialize animation controller
        const animator = new TouchKioAnimator();

        function initializeClock() {
            if (clockInterval) {
                clearInterval(clockInterval);
            }

            function updateClock() {
                const now = new Date();
                const timeString = now.toLocaleTimeString([], {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
                const dateString = now.toLocaleDateString([], {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });

                elements.clock.textContent = timeString;
                elements.date.textContent = dateString;
            }

            updateClock();
            clockInterval = setInterval(updateClock, 1000);
        }

        function updateSourceIndicator(photo) {
            if (photo.type === 'google') {
                elements.sourceIcon.className = 'source-icon google';
                elements.sourceText.textContent = 'Google Photos';
            } else {
                elements.sourceIcon.className = 'source-icon local';
                elements.sourceText.textContent = 'Local Photos';
            }
        }

        function updatePhotoCounter(current, total) {
            elements.photoCounter.textContent = `${current + 1} / ${total}`;
        }

        function updateMetadataDisplay(photo) {
            // Use smooth content transition for photo changes
            transitionMetadataContent(photo);
        }

        // Phase 4B: Animated Element Updates
        async function updateSourceIndicatorAnimated(photo) {
            const sourceIndicator = document.querySelector('.source-indicator');
            if (!sourceIndicator || sourceIndicator.style.display === 'none') return;

            // Animate content change if needed
            const currentText = elements.sourceText.textContent;
            const newText = photo.type === 'google' ? 'Google Photos' : 'Local Photos';
            const currentIcon = elements.sourceIcon.className;
            const newIcon = photo.type === 'google' ? 'source-icon google' : 'source-icon local';

            if (currentText !== newText || currentIcon !== newIcon) {
                // Exit animation
                await animator.animateElementExit(sourceIndicator, 'fadeOut', 0);

                // Update content
                updateSourceIndicator(photo);

                // Entrance animation
                await animator.animateElementEntrance(sourceIndicator, 'slideInFromLeft', 50);
            }
        }

        async function updatePhotoCounterAnimated(current, total) {
            const photoCounter = document.querySelector('.photo-counter');
            if (!photoCounter || photoCounter.style.display === 'none') return;

            const currentText = elements.photoCounter.textContent;
            const newText = `${current + 1} / ${total}`;

            if (currentText !== newText) {
                // Animate counter change with number flip effect
                await animator.animateElementExit(photoCounter, 'scaleOut', 0);

                // Update content
                updatePhotoCounter(current, total);

                // Entrance animation
                await animator.animateElementEntrance(photoCounter, 'scaleIn', 100);
            }
        }

        async function updateMetadataDisplayAnimated(photo) {
            // Use existing smooth content transition but with enhanced animations
            transitionMetadataContent(photo);
        }

        // Store previous config state for position change detection
        let previousClockConfig = null;

        // Enhanced position change animations for Phase 3 integration
        async function animateClockPositionChange() {
            const clock = document.querySelector('.clock');
            if (clock && clock.style.display !== 'none') {
                // Check if config actually changed for position-related settings
                const currentConfig = {
                    position: config.clockPosition || 'bottom-right',
                    customX: config.clockCustomX,
                    customY: config.clockCustomY
                };

                // Initialize previousClockConfig if this is the first call
                const isFirstInitialization = !previousClockConfig;
                if (isFirstInitialization) {
                    previousClockConfig = { ...currentConfig };
                    console.log('Initialized clock config (applying without animation):', previousClockConfig);
                }

                const hasChanged = previousClockConfig.position !== currentConfig.position ||
                    previousClockConfig.customX !== currentConfig.customX ||
                    previousClockConfig.customY !== currentConfig.customY;

                if (hasChanged || isFirstInitialization) {
                    console.log('Clock position config changed:', { previous: previousClockConfig, current: currentConfig });

                    if (isFirstInitialization) {
                        // Apply position immediately without animation on startup
                        const newPosition = calculateClockPosition();
                        Object.assign(clock.style, newPosition);
                        console.log('Applied initial clock position without animation');
                    } else {
                        // Store current opacity and create smooth transition
                        const currentOpacity = window.getComputedStyle(clock).opacity;

                        // Manual opacity transition to 30%
                        clock.style.transition = 'opacity 0.3s ease-in';
                        clock.style.opacity = '0.3';

                        // Wait for fade out
                        await new Promise(resolve => setTimeout(resolve, 300));

                        // Calculate and apply new position during fade
                        const newPosition = calculateClockPosition();
                        Object.assign(clock.style, newPosition);

                        // Fade back to original opacity
                        clock.style.opacity = currentOpacity;

                        // Wait for fade in
                        await new Promise(resolve => setTimeout(resolve, 300));

                        // Clear transition
                        clock.style.transition = '';
                    }

                    // Update previous config
                    previousClockConfig = { ...currentConfig };
                } else {
                    console.log('Clock position config unchanged, skipping animation');
                }
            }
        }

        async function animateDatePositionChange() {
            const date = document.querySelector('.date');
            if (date && date.style.display !== 'none') {
                const currentStyle = {
                    top: date.style.top,
                    right: date.style.right,
                    bottom: date.style.bottom,
                    left: date.style.left,
                    transform: date.style.transform
                };

                const newPosition = calculateDatePosition();
                const hasChanged = (
                    currentStyle.top !== newPosition.top ||
                    currentStyle.right !== newPosition.right ||
                    currentStyle.bottom !== newPosition.bottom ||
                    currentStyle.left !== newPosition.left ||
                    currentStyle.transform !== newPosition.transform
                );

                if (hasChanged) {
                    await animator.animate(date, 'fade-out-partial', { duration: 'fast' });
                    Object.assign(date.style, newPosition);
                    await animator.animate(date, 'fadeIn', { duration: 'position' });
                }
            }
        }

        async function animateSourcePositionChange() {
            const sourceIndicator = document.querySelector('.source-indicator');
            if (sourceIndicator && sourceIndicator.style.display !== 'none') {
                const currentStyle = {
                    top: sourceIndicator.style.top,
                    right: sourceIndicator.style.right,
                    bottom: sourceIndicator.style.bottom,
                    left: sourceIndicator.style.left,
                    transform: sourceIndicator.style.transform
                };

                const newPosition = calculateSourcePosition();
                const hasChanged = (
                    currentStyle.top !== newPosition.top ||
                    currentStyle.right !== newPosition.right ||
                    currentStyle.bottom !== newPosition.bottom ||
                    currentStyle.left !== newPosition.left ||
                    currentStyle.transform !== newPosition.transform
                );

                if (hasChanged) {
                    await animator.animate(sourceIndicator, 'fade-out-partial', { duration: 'fast' });
                    Object.assign(sourceIndicator.style, newPosition);
                    await animator.animate(sourceIndicator, 'fadeIn', { duration: 'position' });
                }
            }
        }

        async function animateCounterPositionChange() {
            const counter = document.querySelector('.photo-counter');
            if (counter && counter.style.display !== 'none') {
                const currentStyle = {
                    top: counter.style.top,
                    right: counter.style.right,
                    bottom: counter.style.bottom,
                    left: counter.style.left,
                    transform: counter.style.transform
                };

                const newPosition = calculateCounterPosition();
                const hasChanged = (
                    currentStyle.top !== newPosition.top ||
                    currentStyle.right !== newPosition.right ||
                    currentStyle.bottom !== newPosition.bottom ||
                    currentStyle.left !== newPosition.left ||
                    currentStyle.transform !== newPosition.transform
                );

                if (hasChanged) {
                    await animator.animate(counter, 'fade-out-partial', { duration: 'fast' });
                    Object.assign(counter.style, newPosition);
                    await animator.animate(counter, 'fadeIn', { duration: 'position' });
                }
            }
        }

        async function animateMetadataPositionChange() {
            const metadata = document.querySelector('.metadata-overlay');
            if (metadata && metadata.style.display !== 'none') {
                const currentStyle = {
                    top: metadata.style.top,
                    right: metadata.style.right,
                    bottom: metadata.style.bottom,
                    left: metadata.style.left,
                    transform: metadata.style.transform
                };

                const newPosition = calculateMetadataPosition();
                const hasChanged = (
                    currentStyle.top !== newPosition.top ||
                    currentStyle.right !== newPosition.right ||
                    currentStyle.bottom !== newPosition.bottom ||
                    currentStyle.left !== newPosition.left ||
                    currentStyle.transform !== newPosition.transform
                );

                if (hasChanged) {
                    await animator.animate(metadata, 'fade-out-partial', { duration: 'fast' });
                    Object.assign(metadata.style, newPosition);
                    await animator.animate(metadata, 'fadeIn', { duration: 'position' });
                }
            }
        }

        // Position calculation functions - extract positioning logic for animations
        function calculateClockPosition() {
            const clockPos = config.clockPosition || 'bottom-right';
            const position = {
                position: 'absolute',
                zIndex: '10',
                top: 'auto',
                right: 'auto',
                bottom: 'auto',
                left: 'auto',
                transform: 'none'
            };

            // Check if custom coordinates are provided (handle empty strings, null, undefined)
            const hasCustomX = config.clockCustomX &&
                config.clockCustomX.toString().trim() !== '' &&
                config.clockCustomX.toString().trim() !== 'null' &&
                config.clockCustomX.toString().trim() !== 'undefined';
            const hasCustomY = config.clockCustomY &&
                config.clockCustomY.toString().trim() !== '' &&
                config.clockCustomY.toString().trim() !== 'null' &&
                config.clockCustomY.toString().trim() !== 'undefined';

            if (hasCustomX || hasCustomY) {
                // Mixed mode: use custom coordinates where provided, preset fallbacks where not
                if (hasCustomX) {
                    const xValue = /^\d+$/.test(config.clockCustomX.toString().trim()) ? config.clockCustomX + 'px' : config.clockCustomX;
                    position.left = xValue;
                } else {
                    // Fall back to preset X positioning
                    if (clockPos.includes('left')) {
                        position.left = '20px';
                    } else if (clockPos.includes('right')) {
                        position.right = '20px';
                    } else if (clockPos === 'center') {
                        position.left = '50%';
                    }
                }

                if (hasCustomY) {
                    const yValue = /^\d+$/.test(config.clockCustomY.toString().trim()) ? config.clockCustomY + 'px' : config.clockCustomY;
                    position.top = yValue;
                } else {
                    // Fall back to preset Y positioning
                    if (clockPos.includes('top')) {
                        position.top = '20px';
                    } else if (clockPos.includes('bottom')) {
                        position.bottom = '20px';
                    } else if (clockPos === 'center') {
                        position.top = '50%';
                        position.transform = 'translate(-50%, -50%)';
                    }
                }

                // Handle center transform when only one custom coordinate is set
                if (clockPos === 'center' && hasCustomX && !hasCustomY) {
                    position.transform = 'translateX(-50%)';
                } else if (clockPos === 'center' && !hasCustomX && hasCustomY) {
                    position.transform = 'translateY(-50%)';
                }
            } else {
                // Use full preset positioning when no custom coordinates
                switch(clockPos) {
                    case 'top-left':
                        position.top = '20px';
                        position.left = '20px';
                        break;
                    case 'top-right':
                        position.top = '20px';
                        position.right = '20px';
                        break;
                    case 'bottom-left':
                        position.bottom = '20px';
                        position.left = '20px';
                        break;
                    case 'bottom-right':
                        position.bottom = '20px';
                        position.right = '20px';
                        break;
                    case 'center':
                        position.top = '50%';
                        position.left = '50%';
                        position.transform = 'translate(-50%, -50%)';
                        break;
                }
            }

            return position;
        }

        function calculateDatePosition() {
            const datePos = config.datePosition || 'bottom-left';
            const position = {
                position: 'absolute',
                zIndex: '10',
                top: 'auto',
                right: 'auto',
                bottom: 'auto',
                left: 'auto',
                transform: 'none'
            };

            const hasCustomX = config.dateCustomX &&
                config.dateCustomX.toString().trim() !== '' &&
                config.dateCustomX.toString().trim() !== 'null' &&
                config.dateCustomX.toString().trim() !== 'undefined';
            const hasCustomY = config.dateCustomY &&
                config.dateCustomY.toString().trim() !== '' &&
                config.dateCustomY.toString().trim() !== 'null' &&
                config.dateCustomY.toString().trim() !== 'undefined';

            if (hasCustomX || hasCustomY) {
                if (hasCustomX) {
                    const xValue = /^\d+$/.test(config.dateCustomX.toString().trim()) ? config.dateCustomX + 'px' : config.dateCustomX;
                    position.left = xValue;
                } else {
                    if (datePos.includes('left')) {
                        position.left = '20px';
                    } else if (datePos.includes('right')) {
                        position.right = '20px';
                    } else if (datePos === 'center') {
                        position.left = '50%';
                    }
                }

                if (hasCustomY) {
                    const yValue = /^\d+$/.test(config.dateCustomY.toString().trim()) ? config.dateCustomY + 'px' : config.dateCustomY;
                    position.top = yValue;
                } else {
                    if (datePos.includes('top')) {
                        position.top = '20px';
                    } else if (datePos.includes('bottom')) {
                        position.bottom = '20px';
                    } else if (datePos === 'center') {
                        position.top = '50%';
                        position.transform = 'translate(-50%, -50%)';
                    }
                }

                if (datePos === 'center' && hasCustomX && !hasCustomY) {
                    position.transform = 'translateX(-50%)';
                } else if (datePos === 'center' && !hasCustomX && hasCustomY) {
                    position.transform = 'translateY(-50%)';
                }
            } else {
                switch(datePos) {
                    case 'top-left':
                        position.top = '20px';
                        position.left = '20px';
                        break;
                    case 'top-right':
                        position.top = '20px';
                        position.right = '20px';
                        break;
                    case 'bottom-left':
                        position.bottom = '20px';
                        position.left = '20px';
                        break;
                    case 'bottom-right':
                        position.bottom = '20px';
                        position.right = '20px';
                        break;
                    case 'center':
                        position.top = '50%';
                        position.left = '50%';
                        position.transform = 'translate(-50%, -50%)';
                        break;
                }
            }

            return position;
        }

        function calculateSourcePosition() {
            const sourcePos = config.sourcePosition || 'top-left';
            const position = {
                position: 'absolute',
                zIndex: '10',
                top: 'auto',
                right: 'auto',
                bottom: 'auto',
                left: 'auto',
                transform: 'none'
            };

            const hasCustomX = config.sourceCustomX &&
                config.sourceCustomX.toString().trim() !== '' &&
                config.sourceCustomX.toString().trim() !== 'null' &&
                config.sourceCustomX.toString().trim() !== 'undefined';
            const hasCustomY = config.sourceCustomY &&
                config.sourceCustomY.toString().trim() !== '' &&
                config.sourceCustomY.toString().trim() !== 'null' &&
                config.sourceCustomY.toString().trim() !== 'undefined';

            if (hasCustomX || hasCustomY) {
                if (hasCustomX) {
                    const xValue = /^\d+$/.test(config.sourceCustomX.toString().trim()) ? config.sourceCustomX + 'px' : config.sourceCustomX;
                    position.left = xValue;
                } else {
                    if (sourcePos.includes('left')) {
                        position.left = '20px';
                    } else if (sourcePos.includes('right')) {
                        position.right = '20px';
                    } else if (sourcePos === 'center') {
                        position.left = '50%';
                    }
                }

                if (hasCustomY) {
                    const yValue = /^\d+$/.test(config.sourceCustomY.toString().trim()) ? config.sourceCustomY + 'px' : config.sourceCustomY;
                    position.top = yValue;
                } else {
                    if (sourcePos.includes('top')) {
                        position.top = '20px';
                    } else if (sourcePos.includes('bottom')) {
                        position.bottom = '20px';
                    } else if (sourcePos === 'center') {
                        position.top = '50%';
                        position.transform = 'translate(-50%, -50%)';
                    }
                }

                if (sourcePos === 'center' && hasCustomX && !hasCustomY) {
                    position.transform = 'translateX(-50%)';
                } else if (sourcePos === 'center' && !hasCustomX && hasCustomY) {
                    position.transform = 'translateY(-50%)';
                }
            } else {
                switch(sourcePos) {
                    case 'top-left':
                        position.top = '20px';
                        position.left = '20px';
                        break;
                    case 'top-right':
                        position.top = '20px';
                        position.right = '20px';
                        break;
                    case 'bottom-left':
                        position.bottom = '20px';
                        position.left = '20px';
                        break;
                    case 'bottom-right':
                        position.bottom = '20px';
                        position.right = '20px';
                        break;
                    case 'center':
                        position.top = '50%';
                        position.left = '50%';
                        position.transform = 'translate(-50%, -50%)';
                        break;
                }
            }

            return position;
        }

        function calculateCounterPosition() {
            const counterPos = config.counterPosition || 'top-right';
            const position = {
                position: 'absolute',
                zIndex: '10',
                top: 'auto',
                right: 'auto',
                bottom: 'auto',
                left: 'auto',
                transform: 'none'
            };

            const hasCustomX = config.counterCustomX &&
                config.counterCustomX.toString().trim() !== '' &&
                config.counterCustomX.toString().trim() !== 'null' &&
                config.counterCustomX.toString().trim() !== 'undefined';
            const hasCustomY = config.counterCustomY &&
                config.counterCustomY.toString().trim() !== '' &&
                config.counterCustomY.toString().trim() !== 'null' &&
                config.counterCustomY.toString().trim() !== 'undefined';

            if (hasCustomX || hasCustomY) {
                if (hasCustomX) {
                    const xValue = /^\d+$/.test(config.counterCustomX.toString().trim()) ? config.counterCustomX + 'px' : config.counterCustomX;
                    position.left = xValue;
                } else {
                    if (counterPos.includes('left')) {
                        position.left = '20px';
                    } else if (counterPos.includes('right')) {
                        position.right = '20px';
                    } else if (counterPos === 'center') {
                        position.left = '50%';
                    }
                }

                if (hasCustomY) {
                    const yValue = /^\d+$/.test(config.counterCustomY.toString().trim()) ? config.counterCustomY + 'px' : config.counterCustomY;
                    position.top = yValue;
                } else {
                    if (counterPos.includes('top')) {
                        position.top = '20px';
                    } else if (counterPos.includes('bottom')) {
                        position.bottom = '20px';
                    } else if (counterPos === 'center') {
                        position.top = '50%';
                        position.transform = 'translate(-50%, -50%)';
                    }
                }

                if (counterPos === 'center' && hasCustomX && !hasCustomY) {
                    position.transform = 'translateX(-50%)';
                } else if (counterPos === 'center' && !hasCustomX && hasCustomY) {
                    position.transform = 'translateY(-50%)';
                }
            } else {
                switch(counterPos) {
                    case 'top-left':
                        position.top = '20px';
                        position.left = '20px';
                        break;
                    case 'top-right':
                        position.top = '20px';
                        position.right = '20px';
                        break;
                    case 'bottom-left':
                        position.bottom = '20px';
                        position.left = '20px';
                        break;
                    case 'bottom-right':
                        position.bottom = '20px';
                        position.right = '20px';
                        break;
                    case 'center':
                        position.top = '50%';
                        position.left = '50%';
                        position.transform = 'translate(-50%, -50%)';
                        break;
                }
            }

            return position;
        }

        function calculateMetadataPosition() {
            const metadataPos = config.metadataPosition || 'bottom-center';
            const position = {
                position: 'absolute',
                zIndex: '10',
                top: 'auto',
                right: 'auto',
                bottom: 'auto',
                left: 'auto',
                transform: 'none'
            };

            const hasCustomX = config.metadataCustomX &&
                config.metadataCustomX.toString().trim() !== '' &&
                config.metadataCustomX.toString().trim() !== 'null' &&
                config.metadataCustomX.toString().trim() !== 'undefined';
            const hasCustomY = config.metadataCustomY &&
                config.metadataCustomY.toString().trim() !== '' &&
                config.metadataCustomY.toString().trim() !== 'null' &&
                config.metadataCustomY.toString().trim() !== 'undefined';

            if (hasCustomX || hasCustomY) {
                if (hasCustomX) {
                    const xValue = /^\d+$/.test(config.metadataCustomX.toString().trim()) ? config.metadataCustomX + 'px' : config.metadataCustomX;
                    position.left = xValue;
                } else {
                    if (metadataPos.includes('left')) {
                        position.left = '20px';
                    } else if (metadataPos.includes('right')) {
                        position.right = '20px';
                    } else if (metadataPos.includes('center')) {
                        position.left = '50%';
                        position.transform = 'translateX(-50%)';
                    }
                }

                if (hasCustomY) {
                    const yValue = /^\d+$/.test(config.metadataCustomY.toString().trim()) ? config.metadataCustomY + 'px' : config.metadataCustomY;
                    position.top = yValue;
                } else {
                    if (metadataPos.includes('top')) {
                        position.top = '20px';
                    } else if (metadataPos.includes('bottom')) {
                        position.bottom = '20px';
                    } else if (metadataPos === 'center') {
                        position.top = '50%';
                        position.transform = 'translate(-50%, -50%)';
                    }
                }

                if (metadataPos.includes('center') && hasCustomX && !hasCustomY) {
                    position.transform = 'translateX(-50%)';
                } else if (metadataPos === 'center' && !hasCustomX && hasCustomY) {
                    position.transform = 'translateY(-50%)';
                } else if (metadataPos === 'center' && hasCustomX && hasCustomY) {
                    position.transform = 'none';
                }
            } else {
                switch(metadataPos) {
                    case 'top-left':
                        position.top = '20px';
                        position.left = '20px';
                        break;
                    case 'top-center':
                        position.top = '20px';
                        position.left = '50%';
                        position.transform = 'translateX(-50%)';
                        break;
                    case 'top-right':
                        position.top = '20px';
                        position.right = '20px';
                        break;
                    case 'bottom-left':
                        position.bottom = '20px';
                        position.left = '20px';
                        break;
                    case 'bottom-center':
                        position.bottom = '20px';
                        position.left = '50%';
                        position.transform = 'translateX(-50%)';
                        break;
                    case 'bottom-right':
                        position.bottom = '20px';
                        position.right = '20px';
                        break;
                    case 'center':
                        position.top = '50%';
                        position.left = '50%';
                        position.transform = 'translate(-50%, -50%)';
                        break;
                }
            }

            return position;
        }

        function showMetadataOverlay() {
            updateMetadataStyles();
            elements.metadataOverlay.style.display = 'block';
            // Force reflow before adding visible class
            elements.metadataOverlay.offsetHeight;
            elements.metadataOverlay.classList.add('visible');
        }

        function hideMetadataOverlay() {
            elements.metadataOverlay.classList.remove('visible');
            const transitionDuration = config.transitionDuration || 2000;
            setTimeout(() => {
                elements.metadataOverlay.style.display = 'none';
            }, transitionDuration / 2); // Match half transition duration
        }

        function transitionMetadataContent(newPhoto) {
            if (!config.showMetadata || !newPhoto.metadata) {
                hideMetadataOverlay();
                return;
            }

            const transitionType = config.metadataTransitionType || 'fade';
            const transitionDuration = config.transitionDuration || 2000; // Get slideshow transition duration
            const halfDuration = transitionDuration / 2;
            const metadataLines = elements.metadataOverlay.querySelectorAll('.metadata-line');

            // Update CSS transition duration to match slideshow
            metadataLines.forEach(line => {
                line.style.transition = `opacity ${halfDuration}ms ease-in-out, filter ${halfDuration}ms ease-in-out, transform ${halfDuration}ms ease-in-out, text-shadow ${halfDuration}ms ease-in-out, letter-spacing ${halfDuration}ms ease-in-out`;
            });

            // Start transition - apply appropriate out effect
            const outClass = `${transitionType}-out`;
            metadataLines.forEach(line => line.classList.add(outClass));

            // After fade out, update content and fade in
            setTimeout(() => {
                updateMetadataContent(newPhoto);

                // Fade in new content
                setTimeout(() => {
                    metadataLines.forEach(line => {
                        line.classList.remove('fade-out', 'blur-out', 'slide-up-out', 'slide-down-out', 'glow-out', 'typewriter-out');
                    });
                }, 50);
            }, halfDuration);
        }

        function updateMetadataContent(photo) {
            const metadata = photo.metadata;
            let hasContent = false;

            // Clear all fields first
            elements.metadataFilename.textContent = '';
            elements.metadataDate.textContent = '';
            elements.metadataCamera.textContent = '';
            elements.metadataExposure.textContent = '';
            elements.metadataLocation.textContent = '';

            // Show/hide filename
            if (config.showFilename && metadata.filename) {
                elements.metadataFilename.textContent = metadata.filename;
                elements.metadataFilename.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataFilename.style.display = 'none';
            }

            // Show/hide date taken
            if (config.showDateTaken && metadata.dateFormatted) {
                elements.metadataDate.textContent = metadata.dateFormatted;
                elements.metadataDate.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataDate.style.display = 'none';
            }

            // Show/hide camera info
            if (config.showCameraInfo && metadata.camera) {
                let cameraText = metadata.camera;
                if (metadata.lens) {
                    cameraText += `  ${metadata.lens}`;
                }
                elements.metadataCamera.textContent = cameraText;
                elements.metadataCamera.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataCamera.style.display = 'none';
            }

            // Show/hide exposure settings
            if (config.showCameraInfo && metadata.exposure) {
                elements.metadataExposure.textContent = metadata.exposure;
                elements.metadataExposure.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataExposure.style.display = 'none';
            }

            // Show/hide location (GPS coordinates)
            if (config.showLocation && metadata.location) {
                elements.metadataLocation.textContent = ` ${metadata.location.formatted}`;
                elements.metadataLocation.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataLocation.style.display = 'none';
            }

            // Show/hide entire overlay based on content
            if (hasContent) {
                if (elements.metadataOverlay.style.display === 'none') {
                    showMetadataOverlay();
                }
            } else {
                hideMetadataOverlay();
            }
        }

        function updateMetadataStyles() {
            const overlay = elements.metadataOverlay;

            // Preserve the visible state
            const wasVisible = overlay.classList.contains('visible');

            // Clear existing classes
            overlay.className = 'metadata-overlay';

            // Check if custom coordinates are provided
            const hasCustomX = config.metadataCustomX &&
                config.metadataCustomX.toString().trim() !== '' &&
                config.metadataCustomX.toString().trim() !== 'null' &&
                config.metadataCustomX.toString().trim() !== 'undefined';
            const hasCustomY = config.metadataCustomY &&
                config.metadataCustomY.toString().trim() !== '' &&
                config.metadataCustomY.toString().trim() !== 'null' &&
                config.metadataCustomY.toString().trim() !== 'undefined';

            if (hasCustomX || hasCustomY) {
                // Use custom positioning - don't add position class, apply directly
                overlay.style.position = 'absolute';
                overlay.style.top = 'auto';
                overlay.style.right = 'auto';
                overlay.style.bottom = 'auto';
                overlay.style.left = 'auto';
                overlay.style.transform = 'none';

                if (hasCustomX) {
                    // Ensure the value has units - if it's just a number, add 'px'
                    const xValue = /^\d+$/.test(config.metadataCustomX.toString().trim()) ? config.metadataCustomX + 'px' : config.metadataCustomX;
                    overlay.style.left = xValue;
                }
                if (hasCustomY) {
                    // Ensure the value has units - if it's just a number, add 'px'
                    const yValue = /^\d+$/.test(config.metadataCustomY.toString().trim()) ? config.metadataCustomY + 'px' : config.metadataCustomY;
                    overlay.style.top = yValue;
                }
            } else {
                // Use preset position with CSS classes
                overlay.classList.add(`pos-${config.metadataPosition || 'bottom-center'}`);
                // Clear any custom positioning
                overlay.style.position = '';
                overlay.style.top = '';
                overlay.style.right = '';
                overlay.style.bottom = '';
                overlay.style.left = '';
                overlay.style.transform = '';
            }

            // Apply background
            overlay.classList.add(`background-${config.metadataBackground || 'dark'}`);

            // Apply custom font size if specified
            if (config.metadataCustomFontSize && config.metadataCustomFontSize.trim() !== '') {
                overlay.style.fontSize = config.metadataCustomFontSize;
            } else {
                overlay.style.fontSize = ''; // Clear custom font size
            }

            // Restore visible state if it was visible
            if (wasVisible) {
                overlay.classList.add('visible');
            }

            // Apply custom opacity if set
            if (config.metadataBackgroundOpacity !== undefined) {
                const opacity = config.metadataBackgroundOpacity / 100;
                if (config.metadataBackground === 'dark') {
                    overlay.style.backgroundColor = `rgba(0, 0, 0, ${opacity})`;
                } else if (config.metadataBackground === 'light') {
                    overlay.style.backgroundColor = `rgba(255, 255, 255, ${opacity * 0.4})`;
                } else if (config.metadataBackground === 'blue') {
                    overlay.style.backgroundColor = `rgba(52, 152, 219, ${opacity})`;
                } else if (config.metadataBackground === 'green') {
                    overlay.style.backgroundColor = `rgba(52, 168, 83, ${opacity})`;
                } else if (config.metadataBackground === 'red') {
                    overlay.style.backgroundColor = `rgba(231, 76, 60, ${opacity})`;
                } else if (config.metadataBackground === 'purple') {
                    overlay.style.backgroundColor = `rgba(155, 89, 182, ${opacity})`;
                }
            }

            // Apply custom color if specified
            if (config.metadataColor) {
                overlay.style.color = config.metadataColor;
            }

            // Apply advanced styling options
            if (config.metadataBorderRadius && config.metadataBorderRadius.trim() !== '') {
                overlay.style.borderRadius = config.metadataBorderRadius;
            } else {
                overlay.style.borderRadius = ''; // Clear custom border radius
            }

            if (config.metadataPadding && config.metadataPadding.trim() !== '') {
                overlay.style.padding = config.metadataPadding;
            } else {
                overlay.style.padding = ''; // Clear custom padding
            }

            if (config.metadataShadow && config.metadataShadow.trim() !== '') {
                overlay.style.boxShadow = config.metadataShadow;
            } else {
                overlay.style.boxShadow = ''; // Clear custom shadow
            }
        }

        function showLoading() {
            elements.loadingIndicator.style.display = 'block';
            elements.errorMessage.style.display = 'none';
        }

        function hideLoading() {
            elements.loadingIndicator.style.display = 'none';
        }

        function showError(message = 'Failed to load photo') {
            elements.errorMessage.textContent = message;
            elements.errorMessage.style.display = 'block';
            elements.loadingIndicator.style.display = 'none';
        }

        function hideError() {
            elements.errorMessage.style.display = 'none';
        }

        function getPhotoUrl(photo, index) {
            if (photo.type === 'google') {
                return `http://localhost:${config.port || 8081}/google-photo/${encodeURIComponent(photo.url)}`;
            } else {
                return `http://localhost:${config.port || 8081}/photo/${index !== undefined ? index : photos.indexOf(photo)}`;
            }
        }

        function preloadNextPhoto(index) {
            if (photos.length === 0) return;

            const nextIndex = (index + 1) % photos.length;
            const nextPhoto = photos[nextIndex];

            if (nextPhoto) {
                elements.preloadPhoto.src = getPhotoUrl(nextPhoto, nextIndex);
            }
        }

        function showPhoto(photoData) {
            if (!photoData || !photoData.photo) {
                showError('No photo data received');
                return;
            }

            const { index, photo } = photoData;
            currentIndex = index;

            if (photos.length === 0) {
                elements.noPhotos.style.display = 'block';
                return;
            } else {
                elements.noPhotos.style.display = 'none';
            }

            hideError();

            // Animate element updates with entrance animations
            updateSourceIndicatorAnimated(photo);
            updatePhotoCounterAnimated(index, photos.length);
            updateMetadataDisplayAnimated(photo);

            const photoUrl = getPhotoUrl(photo, index);

            // Determine which photo element to use next
            const nextPhotoElement = currentPhotoElement === 1 ? 2 : 1;
            const currentPhoto = elements[`photo${currentPhotoElement}`];
            const nextPhoto = elements[`photo${nextPhotoElement}`];
            const currentBg = elements[`bg${currentPhotoElement}`];
            const nextBg = elements[`bg${nextPhotoElement}`];

            const newPhoto = new Image();

            newPhoto.onload = () => {
                // Set the source on both the foreground and background elements
                nextPhoto.src = photoUrl;
                nextBg.src = photoUrl;

                // Start transition: crossfade properly to avoid transparency gap
                setTimeout(() => {
                    // First, fade in the new photo
                    nextPhoto.classList.add('visible');
                    nextBg.classList.add('visible');

                    // Wait for new photo to be mostly visible before fading out old
                    setTimeout(() => {
                        currentPhoto.classList.remove('visible');
                        currentBg.classList.remove('visible');
                    }, 1000); // Halfway through 2s transition
                }, 50); // Small delay to ensure src is set

                // Update which element is current after transition completes
                setTimeout(() => {
                    currentPhotoElement = nextPhotoElement;
                }, 2000); // Match transition duration

                preloadNextPhoto(index);
            };

            newPhoto.onerror = () => {
                console.error('Failed to load photo:', photoUrl);
                showError(`Failed to load: ${photo.title || 'Unknown photo'}`);

                setTimeout(() => {
                    hideError();
                }, 3000);
            };

            newPhoto.src = photoUrl;
        }

        ipcRenderer.on('slideshow-config', async (event, data) => {
            console.log('Received slideshow config:', data);
            console.log('Clock position in config:', data.config?.clockPosition);

            // Check if we're currently in an entrance/exit animation
            const container = document.querySelector('.slideshow-container');
            const isAnimating = container.classList.contains('slideshow-entrance-animation') ||
                                container.classList.contains('slideshow-exit-animation');

            if (isAnimating) {
                console.log('Delaying config application - animation in progress');
                // Wait for animation to complete before applying config
                setTimeout(() => {
                    applyConfigData(data);
                }, 1500);
                return;
            }

            applyConfigData(data);
        });

        async function applyConfigData(data) {
            if (data.config) {
                config = data.config;

                // Clock and date configuration
                await applyClock();
                await applyDate();
                initializeClock();

                // Trigger position animations after applying styles
                console.log('Triggering position animations after config update');
                await animateClockPositionChange();

                // Source indicator configuration
                const sourceIndicator = document.querySelector('.source-indicator');
                if (config.showSourceIndicator !== false) {
                    sourceIndicator.style.display = 'flex';
                    const sourcePos = config.sourcePosition || 'top-left';

                    // Apply proper styling via the dedicated function
                    await applySourceIndicatorPosition();

                    sourceIndicator.style.opacity = config.sourceOpacity || 0.8;
                } else {
                    sourceIndicator.style.display = 'none';
                }

                // Photo counter configuration
                const photoCounter = document.querySelector('.photo-counter');
                if (config.showPhotoCounter) {
                    photoCounter.style.display = 'flex';
                    const counterPos = config.counterPosition || 'bottom-left';

                    // Apply proper styling via the dedicated function
                    await applyPhotoCounterPosition();

                    photoCounter.style.opacity = config.counterOpacity || 0.8;
                } else {
                    photoCounter.style.display = 'none';
                }

                // Metadata overlay configuration
                const metadataOverlay = document.querySelector('.metadata-overlay');
                if (config.showMetadata) {
                    // Update all metadata styles when config changes
                    updateMetadataStyles();
                    // Metadata visibility will be handled by updateMetadataDisplay when photos are shown
                } else {
                    metadataOverlay.style.display = 'none';
                }

                // Photo fit configuration - only update if it changed
                if (data.config.photoFit !== undefined) {
                    const photos = document.querySelectorAll('.photo');
                    photos.forEach(photo => {
                        // Preserve the visible state when updating photo fit
                        const wasVisible = photo.classList.contains('visible');
                        photo.className = `photo fit-${config.photoFit || 'contain'}`;
                        if (wasVisible) {
                            photo.classList.add('visible');
                        }
                    });
                }

                // Apply transition type - only update if it changed
                if (data.config.transitionType !== undefined) {
                    const container = document.querySelector('.slideshow-container');
                    container.className = `slideshow-container transition-${config.transitionType || 'fade'}`;
                }
            }

            if (data.photos) {
                photos = data.photos;
                updatePhotoCounter(currentIndex, photos.length);

                if (photos.length === 0) {
                    elements.noPhotos.style.display = 'block';
                }
            }
        });

        ipcRenderer.on('show-photo', (event, photoData) => {
            showPhoto(photoData);
        });

        // Slideshow Animation Event Handlers
        ipcRenderer.on('slideshow-entrance-animation', (event, data) => {
            const { theme, speed } = data;
            console.log(`Executing ${theme} entrance animation at ${speed}x speed`);

            // Reset activity detection when slideshow starts
            resetActivityDetection();

            const container = document.querySelector('.slideshow-container');
            const body = document.body;

            // Clear any existing animation classes
            container.classList.remove(
                'slideshow-entrance-animation', 'slideshow-exit-animation',
                'slideshow-entrance-default', 'slideshow-entrance-elegant',
                'slideshow-entrance-dynamic', 'slideshow-entrance-minimal', 'slideshow-entrance-playful',
                'slideshow-exit-default', 'slideshow-exit-elegant',
                'slideshow-exit-dynamic', 'slideshow-exit-minimal', 'slideshow-exit-playful'
            );

            // Apply entrance animation with correct duration for each theme
            const durations = {
                'default': 500,
                'elegant': 1200,
                'dynamic': 400,
                'minimal': 300,
                'playful': 600
            };
            const duration = durations[theme] || 500;

            // Apply animation classes and let CSS handle the opacity
            container.classList.add('slideshow-entrance-animation', `slideshow-entrance-${theme}`);
            container.style.animationDuration = `${duration / speed}ms`;
        });

        ipcRenderer.on('slideshow-exit-animation', (event, data) => {
            const { theme, speed } = data;
            console.log(`Executing ${theme} exit animation at ${speed}x speed`);

            const container = document.querySelector('.slideshow-container');
            const body = document.body;

            // Clear any existing animation classes
            container.classList.remove(
                'slideshow-entrance-animation', 'slideshow-exit-animation',
                'slideshow-entrance-default', 'slideshow-entrance-elegant',
                'slideshow-entrance-dynamic', 'slideshow-entrance-minimal', 'slideshow-entrance-playful',
                'slideshow-exit-default', 'slideshow-exit-elegant',
                'slideshow-exit-dynamic', 'slideshow-exit-minimal', 'slideshow-exit-playful'
            );

            // Apply exit animation with correct duration for each theme
            const durations = {
                'default': 500,
                'elegant': 1200,
                'dynamic': 400,
                'minimal': 300,
                'playful': 600
            };
            const duration = durations[theme] || 500;
            container.classList.add('slideshow-exit-animation', `slideshow-exit-${theme}`);
            container.style.animationDuration = `${duration / speed}ms`;
        });

        // Delay before enabling activity detection to prevent false triggers
        let activityDetectionEnabled = false;
        let activityDetectionTimeout = null;

        const resetActivityDetection = () => {
            activityDetectionEnabled = false;
            if (activityDetectionTimeout) {
                clearTimeout(activityDetectionTimeout);
            }
            // Wait 3 seconds after slideshow starts before enabling activity detection
            activityDetectionTimeout = setTimeout(() => {
                activityDetectionEnabled = true;
                console.log('Activity detection enabled');
            }, 3000);
        };

        // Initial delay on page load
        resetActivityDetection();

        // Aggressive event capture for VNC and remote clicks
        const triggerUserActivity = () => {
            if (activityDetectionEnabled) {
                console.log('User activity detected in slideshow');
                ipcRenderer.send('slideshow-user-activity');
            }
        };

        // Capture clicks on all elements
        document.addEventListener('click', triggerUserActivity, true);
        document.addEventListener('mousedown', triggerUserActivity, true);
        document.addEventListener('mouseup', triggerUserActivity, true);

        document.addEventListener('keydown', triggerUserActivity);

        // Throttled mousemove to prevent too many events
        let mouseMoveTimeout;
        let lastMouseX = 0;
        let lastMouseY = 0;
        document.addEventListener('mousemove', (e) => {
            // Only trigger on significant mouse movement
            const deltaX = Math.abs(e.clientX - lastMouseX);
            const deltaY = Math.abs(e.clientY - lastMouseY);

            if (deltaX > 10 || deltaY > 10) {
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;

                if (!mouseMoveTimeout) {
                    mouseMoveTimeout = setTimeout(() => {
                        triggerUserActivity();
                        mouseMoveTimeout = null;
                    }, 100);
                }
            }
        });

        document.addEventListener('touchstart', triggerUserActivity);

        // Also detect clicks on the slideshow container specifically
        document.querySelector('.slideshow-container').addEventListener('click', triggerUserActivity, true);

        window.addEventListener('beforeunload', () => {
            if (clockInterval) {
                clearInterval(clockInterval);
            }
        });

        // Create function to apply source indicator styling
        async function applySourceIndicatorPosition() {
            const sourceIndicator = document.querySelector('.source-indicator');
            if (config.showSourceIndicator && sourceIndicator) {
                sourceIndicator.style.display = 'flex';
                const sourcePos = config.sourcePosition || 'top-left';
                const sourceBackground = config.sourceBackground || 'dark';

                // Apply classes for background only (no size/font-size classes needed)
                sourceIndicator.className = `source-indicator background-${sourceBackground}`;

                // Apply custom font size if specified
                if (config.sourceCustomFontSize && config.sourceCustomFontSize.trim() !== '') {
                    sourceIndicator.style.fontSize = config.sourceCustomFontSize;
                } else {
                    sourceIndicator.style.fontSize = ''; // Clear custom font size
                }

                sourceIndicator.style.position = 'absolute';
                sourceIndicator.style.zIndex = '10';
                sourceIndicator.style.top = 'auto';
                sourceIndicator.style.right = 'auto';
                sourceIndicator.style.bottom = 'auto';
                sourceIndicator.style.left = 'auto';
                sourceIndicator.style.transform = 'none';

                // Check if custom coordinates are provided
                const hasCustomX = config.sourceCustomX && config.sourceCustomX.toString().trim() !== '';
                const hasCustomY = config.sourceCustomY && config.sourceCustomY.toString().trim() !== '';

                console.log('Source positioning debug:', {
                    sourceCustomX: config.sourceCustomX,
                    sourceCustomY: config.sourceCustomY,
                    hasCustomX,
                    hasCustomY
                });

                // Handle custom positioning independently for X and Y coordinates
                if (hasCustomX || hasCustomY) {
                    // Mixed mode: use custom coordinates where provided, preset fallbacks where not
                    if (hasCustomX) {
                        // Use custom X coordinate
                        const xValue = /^\d+$/.test(config.sourceCustomX.toString().trim()) ? config.sourceCustomX + 'px' : config.sourceCustomX;
                        sourceIndicator.style.left = xValue;
                        console.log('Applied custom source X:', xValue, '(original:', config.sourceCustomX, ')');
                    } else {
                        // Fall back to preset X positioning
                        if (sourcePos.includes('left')) {
                            sourceIndicator.style.left = '20px';
                        } else if (sourcePos.includes('right')) {
                            sourceIndicator.style.right = '20px';
                        } else if (sourcePos === 'center') {
                            sourceIndicator.style.left = '50%';
                        }
                    }

                    if (hasCustomY) {
                        // Use custom Y coordinate
                        const yValue = /^\d+$/.test(config.sourceCustomY.toString().trim()) ? config.sourceCustomY + 'px' : config.sourceCustomY;
                        sourceIndicator.style.top = yValue;
                        console.log('Applied custom source Y:', yValue, '(original:', config.sourceCustomY, ')');
                    } else {
                        // Fall back to preset Y positioning
                        if (sourcePos.includes('top')) {
                            sourceIndicator.style.top = '20px';
                        } else if (sourcePos.includes('bottom')) {
                            sourceIndicator.style.bottom = '20px';
                        } else if (sourcePos === 'center') {
                            sourceIndicator.style.top = '50%';
                            sourceIndicator.style.transform = 'translate(-50%, -50%)';
                        }
                    }

                    // Handle center transform when only one custom coordinate is set
                    if (sourcePos === 'center' && hasCustomX && !hasCustomY) {
                        sourceIndicator.style.transform = 'translateX(-50%)';
                    } else if (sourcePos === 'center' && !hasCustomX && hasCustomY) {
                        sourceIndicator.style.transform = 'translateY(-50%)';
                    }
                } else {
                    // Use full preset positioning when no custom coordinates
                    switch(sourcePos) {
                        case 'top-left':
                            sourceIndicator.style.top = '20px';
                            sourceIndicator.style.left = '20px';
                            break;
                        case 'top-right':
                            sourceIndicator.style.top = '20px';
                            sourceIndicator.style.right = '20px';
                            break;
                        case 'bottom-left':
                            sourceIndicator.style.bottom = '20px';
                            sourceIndicator.style.left = '20px';
                            break;
                        case 'bottom-right':
                            sourceIndicator.style.bottom = '20px';
                            sourceIndicator.style.right = '20px';
                            break;
                    }
                }

                // Apply custom color if specified
                if (config.sourceColor) {
                    sourceIndicator.style.color = config.sourceColor;
                }

                // Apply background opacity if background is not 'none'
                if (sourceBackground !== 'none' && config.sourceBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(sourceIndicator).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.sourceBackgroundOpacity / 100;
                            sourceIndicator.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                sourceIndicator.style.opacity = config.sourceOpacity || 0.8;

                // Apply advanced styling options
                if (config.sourceBorderRadius && config.sourceBorderRadius.trim() !== '') {
                    sourceIndicator.style.borderRadius = config.sourceBorderRadius;
                } else {
                    sourceIndicator.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.sourcePadding && config.sourcePadding.trim() !== '') {
                    sourceIndicator.style.padding = config.sourcePadding;
                } else {
                    sourceIndicator.style.padding = ''; // Clear custom padding
                }

                if (config.sourceShadow && config.sourceShadow.trim() !== '') {
                    sourceIndicator.style.boxShadow = config.sourceShadow;
                } else {
                    sourceIndicator.style.boxShadow = ''; // Clear custom shadow
                }

                // Animate position change for smooth transitions
                await animateSourcePositionChange();
            } else if (sourceIndicator) {
                sourceIndicator.style.display = 'none';
            }
        }

        // Create function to apply clock styling
        async function applyClock() {
            const clock = elements.clock;
            if (config.showClock && clock) {
                clock.style.display = 'block';
                const clockPos = config.clockPosition || 'bottom-right';
                const clockBackground = config.clockBackground || 'dark';
                const clockFontSize = config.clockFontSize || 'medium';

                // Apply classes for background and font size (if no custom size)
                if (config.clockCustomFontSize) {
                    clock.className = `clock background-${clockBackground}`;
                    clock.style.fontSize = config.clockCustomFontSize;
                } else {
                    clock.className = `clock background-${clockBackground} font-size-${clockFontSize}`;
                }

                // Set basic positioning styles - actual positioning handled by animation function
                clock.style.position = 'absolute';
                clock.style.zIndex = '10';

                // Apply initial position if no position is currently set
                if (!clock.style.top && !clock.style.bottom && !clock.style.left && !clock.style.right) {
                    const initialPosition = calculateClockPosition();
                    Object.assign(clock.style, initialPosition);
                }

                // Apply custom color if specified
                if (config.clockColor) {
                    clock.style.color = config.clockColor;
                }

                // Apply background opacity if background is not 'none'
                if (clockBackground !== 'none' && config.clockBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(clock).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.clockBackgroundOpacity / 100;
                            clock.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                clock.style.opacity = config.clockOpacity || 1.0;

                // Apply advanced styling options
                if (config.clockBorderRadius && config.clockBorderRadius.trim() !== '') {
                    clock.style.borderRadius = config.clockBorderRadius;
                } else {
                    clock.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.clockPadding && config.clockPadding.trim() !== '') {
                    clock.style.padding = config.clockPadding;
                } else {
                    clock.style.padding = ''; // Clear custom padding
                }

                if (config.clockShadow && config.clockShadow.trim() !== '') {
                    clock.style.boxShadow = config.clockShadow;
                } else {
                    clock.style.boxShadow = ''; // Clear custom shadow
                }

                // Animate position change for smooth transitions
                await animateClockPositionChange();
            } else if (clock) {
                clock.style.display = 'none';
            }
        }

        // Create function to apply date styling
        async function applyDate() {
            const date = elements.date;
            if (config.showDate !== false && date) {
                date.style.display = 'block';
                const datePos = config.datePosition || 'bottom-left';
                const dateBackground = config.dateBackground || 'dark';
                const dateFontSize = config.dateFontSize || 'medium';

                // Apply classes for background and position only
                if (config.dateCustomFontSize && config.dateCustomFontSize.trim() !== '') {
                    date.className = `date background-${dateBackground} pos-${datePos}`;
                    date.style.fontSize = config.dateCustomFontSize;
                } else {
                    date.className = `date background-${dateBackground} pos-${datePos}`;
                    date.style.fontSize = ''; // Clear custom font size
                }

                // Apply positioning - use custom coordinates if provided, otherwise use preset positions
                date.style.position = 'absolute';
                date.style.zIndex = '10';
                date.style.top = 'auto';
                date.style.right = 'auto';
                date.style.bottom = 'auto';
                date.style.left = 'auto';
                date.style.transform = 'none';

                // Check if custom coordinates are provided
                const hasCustomX = config.dateCustomX && config.dateCustomX.toString().trim() !== '';
                const hasCustomY = config.dateCustomY && config.dateCustomY.toString().trim() !== '';

                // Handle custom positioning independently for X and Y coordinates
                if (hasCustomX || hasCustomY) {
                    // Mixed mode: use custom coordinates where provided, preset fallbacks where not
                    if (hasCustomX) {
                        // Use custom X coordinate
                        const xValue = /^\d+$/.test(config.dateCustomX.toString().trim()) ? config.dateCustomX + 'px' : config.dateCustomX;
                        date.style.left = xValue;
                    } else {
                        // Fall back to preset X positioning
                        if (datePos.includes('left')) {
                            date.style.left = '20px';
                        } else if (datePos.includes('right')) {
                            date.style.right = '20px';
                        } else if (datePos === 'center') {
                            date.style.left = '50%';
                        }
                    }

                    if (hasCustomY) {
                        // Use custom Y coordinate
                        const yValue = /^\d+$/.test(config.dateCustomY.toString().trim()) ? config.dateCustomY + 'px' : config.dateCustomY;
                        date.style.top = yValue;
                    } else {
                        // Fall back to preset Y positioning
                        if (datePos.includes('top')) {
                            date.style.top = '20px';
                        } else if (datePos.includes('bottom')) {
                            date.style.bottom = '20px';
                        } else if (datePos === 'center') {
                            date.style.top = '50%';
                            date.style.transform = 'translate(-50%, -50%)';
                        }
                    }

                    // Handle center transform when only one custom coordinate is set
                    if (datePos === 'center' && hasCustomX && !hasCustomY) {
                        date.style.transform = 'translateX(-50%)';
                    } else if (datePos === 'center' && !hasCustomX && hasCustomY) {
                        date.style.transform = 'translateY(-50%)';
                    }
                } else {
                    // Use full preset positioning when no custom coordinates
                    switch(datePos) {
                        case 'top-left':
                            date.style.top = '20px';
                            date.style.left = '20px';
                            break;
                        case 'top-right':
                            date.style.top = '20px';
                            date.style.right = '20px';
                            break;
                        case 'bottom-left':
                            date.style.bottom = '20px';
                            date.style.left = '20px';
                            break;
                        case 'bottom-right':
                            date.style.bottom = '20px';
                            date.style.right = '20px';
                            break;
                        case 'center':
                            date.style.top = '50%';
                            date.style.left = '50%';
                            date.style.transform = 'translate(-50%, -50%)';
                            break;
                    }
                }

                // Apply custom color if specified
                if (config.dateColor) {
                    date.style.color = config.dateColor;
                }

                // Apply background opacity if background is not 'none'
                if (dateBackground !== 'none' && config.dateBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(date).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.dateBackgroundOpacity / 100;
                            date.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                date.style.opacity = config.dateOpacity || 0.8;

                // Apply advanced styling options
                if (config.dateBorderRadius && config.dateBorderRadius.trim() !== '') {
                    date.style.borderRadius = config.dateBorderRadius;
                } else {
                    date.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.datePadding && config.datePadding.trim() !== '') {
                    date.style.padding = config.datePadding;
                } else {
                    date.style.padding = ''; // Clear custom padding
                }

                if (config.dateShadow && config.dateShadow.trim() !== '') {
                    date.style.boxShadow = config.dateShadow;
                } else {
                    date.style.boxShadow = ''; // Clear custom shadow
                }

                // Animate position change for smooth transitions
                await animateDatePositionChange();
            } else if (date) {
                date.style.display = 'none';
            }
        }

        // Create function to apply photo counter styling
        async function applyPhotoCounterPosition() {
            const photoCounter = document.querySelector('.photo-counter');
            if (config.showPhotoCounter && photoCounter) {
                photoCounter.style.display = 'flex';
                const counterPos = config.counterPosition || 'bottom-left';
                const counterBackground = config.counterBackground || 'dark';

                // Apply classes for background only (no size/font-size classes needed)
                photoCounter.className = `photo-counter background-${counterBackground}`;

                // Apply custom font size if specified
                if (config.counterCustomFontSize && config.counterCustomFontSize.trim() !== '') {
                    photoCounter.style.fontSize = config.counterCustomFontSize;
                } else {
                    photoCounter.style.fontSize = ''; // Clear custom font size
                }

                photoCounter.style.position = 'absolute';
                photoCounter.style.zIndex = '10';
                photoCounter.style.top = 'auto';
                photoCounter.style.right = 'auto';
                photoCounter.style.bottom = 'auto';
                photoCounter.style.left = 'auto';
                photoCounter.style.transform = 'none';

                // Check if custom coordinates are provided
                const hasCustomX = config.counterCustomX && config.counterCustomX.toString().trim() !== '';
                const hasCustomY = config.counterCustomY && config.counterCustomY.toString().trim() !== '';

                console.log('Counter positioning debug:', {
                    counterCustomX: config.counterCustomX,
                    counterCustomY: config.counterCustomY,
                    hasCustomX,
                    hasCustomY
                });

                // Handle custom positioning independently for X and Y coordinates
                if (hasCustomX || hasCustomY) {
                    // Mixed mode: use custom coordinates where provided, preset fallbacks where not
                    if (hasCustomX) {
                        // Use custom X coordinate
                        const xValue = /^\d+$/.test(config.counterCustomX.toString().trim()) ? config.counterCustomX + 'px' : config.counterCustomX;
                        photoCounter.style.left = xValue;
                        console.log('Applied custom counter X:', xValue, '(original:', config.counterCustomX, ')');
                    } else {
                        // Fall back to preset X positioning
                        if (counterPos.includes('left')) {
                            photoCounter.style.left = '20px';
                        } else if (counterPos.includes('right')) {
                            photoCounter.style.right = '20px';
                        } else if (counterPos === 'center') {
                            photoCounter.style.left = '50%';
                        }
                    }

                    if (hasCustomY) {
                        // Use custom Y coordinate
                        const yValue = /^\d+$/.test(config.counterCustomY.toString().trim()) ? config.counterCustomY + 'px' : config.counterCustomY;
                        photoCounter.style.top = yValue;
                        console.log('Applied custom counter Y:', yValue, '(original:', config.counterCustomY, ')');
                    } else {
                        // Fall back to preset Y positioning
                        if (counterPos.includes('top')) {
                            photoCounter.style.top = '20px';
                        } else if (counterPos.includes('bottom')) {
                            photoCounter.style.bottom = '20px';
                        } else if (counterPos === 'center') {
                            photoCounter.style.top = '50%';
                            photoCounter.style.transform = 'translate(-50%, -50%)';
                        }
                    }

                    // Handle center transform when only one custom coordinate is set
                    if (counterPos === 'center' && hasCustomX && !hasCustomY) {
                        photoCounter.style.transform = 'translateX(-50%)';
                    } else if (counterPos === 'center' && !hasCustomX && hasCustomY) {
                        photoCounter.style.transform = 'translateY(-50%)';
                    }
                } else {
                    // Use full preset positioning when no custom coordinates
                    switch(counterPos) {
                        case 'top-left':
                            photoCounter.style.top = '20px';
                            photoCounter.style.left = '20px';
                            break;
                        case 'top-right':
                            photoCounter.style.top = '20px';
                            photoCounter.style.right = '20px';
                            break;
                        case 'bottom-left':
                            photoCounter.style.bottom = '20px';
                            photoCounter.style.left = '20px';
                            break;
                        case 'bottom-right':
                            photoCounter.style.bottom = '20px';
                            photoCounter.style.right = '20px';
                            break;
                    }
                }

                // Apply custom color if specified
                if (config.counterColor) {
                    photoCounter.style.color = config.counterColor;
                }

                // Apply background opacity if background is not 'none'
                if (counterBackground !== 'none' && config.counterBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(photoCounter).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.counterBackgroundOpacity / 100;
                            photoCounter.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                photoCounter.style.opacity = config.counterOpacity || 0.8;

                // Apply advanced styling options
                if (config.counterBorderRadius && config.counterBorderRadius.trim() !== '') {
                    photoCounter.style.borderRadius = config.counterBorderRadius;
                } else {
                    photoCounter.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.counterPadding && config.counterPadding.trim() !== '') {
                    photoCounter.style.padding = config.counterPadding;
                } else {
                    photoCounter.style.padding = ''; // Clear custom padding
                }

                if (config.counterShadow && config.counterShadow.trim() !== '') {
                    photoCounter.style.boxShadow = config.counterShadow;
                } else {
                    photoCounter.style.boxShadow = ''; // Clear custom shadow
                }

                // Animate position change for smooth transitions
                await animateCounterPositionChange();
            } else if (photoCounter) {
                photoCounter.style.display = 'none';
            }
        }

        // =================== Phase 4C: Advanced Animation Features ===================

        // Animation themes with different style combinations
        const animationThemes = {
            default: {
                entrance: 'fadeIn',
                exit: 'fadeOut',
                positionChange: 'fade-out-partial',
                contentChange: 'slideInFromLeft',
                stagger: 100
            },
            elegant: {
                entrance: 'scaleIn',
                exit: 'scaleOut',
                positionChange: 'fadeOut',
                contentChange: 'slideInFromBottom',
                stagger: 150
            },
            dynamic: {
                entrance: 'slideInFromRight',
                exit: 'slideOutToLeft',
                positionChange: 'bounceOut',
                contentChange: 'slideInFromTop',
                stagger: 80
            },
            minimal: {
                entrance: 'fadeIn',
                exit: 'fadeOut',
                positionChange: 'fadeOut',
                contentChange: 'fadeIn',
                stagger: 200
            },
            playful: {
                entrance: 'bounceIn',
                exit: 'bounceOut',
                positionChange: 'scaleOut',
                contentChange: 'slideInFromRight',
                stagger: 120
            }
        };

        // Current animation theme
        let currentAnimationTheme = 'default';

        // Smart timing based on user interaction patterns
        let lastInteractionTime = Date.now();
        let userActivityLevel = 'normal'; // 'low', 'normal', 'high'

        // Adaptive animation controller
        class AdaptiveAnimationController {
            constructor() {
                this.baseSpeed = 1.0;
                this.adaptiveSpeed = 1.0;
                this.interactionHistory = [];
                this.maxHistoryLength = 20;
                this.updateInterval = null;
                this.startAdaptiveTracking();
            }

            // Update user activity tracking
            trackUserActivity() {
                const now = Date.now();
                this.interactionHistory.push(now);

                // Keep only recent interactions
                this.interactionHistory = this.interactionHistory.filter(
                    time => now - time < 300000 // Last 5 minutes
                );

                // Calculate activity level
                const interactionCount = this.interactionHistory.length;
                if (interactionCount > 15) {
                    userActivityLevel = 'high';
                    this.adaptiveSpeed = 1.5; // Faster animations for active users
                } else if (interactionCount < 5) {
                    userActivityLevel = 'low';
                    this.adaptiveSpeed = 0.7; // Slower, more noticeable animations
                } else {
                    userActivityLevel = 'normal';
                    this.adaptiveSpeed = 1.0;
                }

                lastInteractionTime = now;
                this.updateAnimationSpeed();
            }

            // Start tracking user activity patterns
            startAdaptiveTracking() {
                // Track MQTT configuration changes as user interactions
                const originalUpdateConfig = window.updateConfig;
                if (originalUpdateConfig) {
                    window.updateConfig = async function(newConfig) {
                        adaptiveController.trackUserActivity();
                        return originalUpdateConfig.call(this, newConfig);
                    };
                }

                // Periodic check for idle state
                this.updateInterval = setInterval(() => {
                    const timeSinceLastInteraction = Date.now() - lastInteractionTime;

                    // If user has been idle for 10+ minutes, use slower animations
                    if (timeSinceLastInteraction > 600000) {
                        userActivityLevel = 'idle';
                        this.adaptiveSpeed = 0.5;
                        this.updateAnimationSpeed();
                    }
                }, 60000); // Check every minute
            }

            // Update global animation speed based on adaptive calculations
            updateAnimationSpeed() {
                const finalSpeed = this.baseSpeed * this.adaptiveSpeed;
                animator.setGlobalSpeed(finalSpeed);
                console.log(`Animation speed adapted: ${finalSpeed} (activity: ${userActivityLevel})`);
            }

            // Set base animation speed (from user config)
            setBaseSpeed(speed) {
                this.baseSpeed = Math.max(0.1, Math.min(5.0, speed));
                this.updateAnimationSpeed();
            }

            // Get current theme configuration
            getCurrentTheme() {
                return animationThemes[currentAnimationTheme] || animationThemes.default;
            }

            // Apply animation theme
            applyTheme(themeName) {
                if (animationThemes[themeName]) {
                    currentAnimationTheme = themeName;
                    console.log(`Animation theme changed to: ${themeName}`);
                    return true;
                }
                return false;
            }

            // Enhanced entrance animation with theme support
            async animateElementEntranceThemed(element, delay = 0) {
                const theme = this.getCurrentTheme();
                return animator.animateElementEntrance(element, theme.entrance, delay);
            }

            // Enhanced exit animation with theme support
            async animateElementExitThemed(element, delay = 0) {
                const theme = this.getCurrentTheme();
                return animator.animateElementExit(element, theme.exit, delay);
            }

            // Smart content transition with contextual animations
            async animateContentChangeThemed(element, newContent, updateFunction) {
                const theme = this.getCurrentTheme();

                // Exit current content
                await animator.animate(element, theme.exit, { duration: 'fast' });

                // Update content during transition
                if (updateFunction) {
                    updateFunction();
                }

                // Enter with new content
                return animator.animate(element, theme.contentChange, {
                    duration: 'content',
                    delay: theme.stagger / 3
                });
            }

            // Smart position change with theme and context awareness
            async animatePositionChangeThemed(element, newPositionFunction) {
                const theme = this.getCurrentTheme();

                // Check if this is a rapid series of position changes
                const elementId = element.id || element.className;
                const now = Date.now();
                const lastChangeKey = `${elementId}_lastChange`;
                const lastChange = this[lastChangeKey] || 0;

                // If rapid changes detected, use faster animation
                const isRapidChange = (now - lastChange) < 2000;
                const animationType = isRapidChange ? 'fade-out-partial' : theme.positionChange;
                const duration = isRapidChange ? 'fast' : 'position';

                this[lastChangeKey] = now;

                // Animate position change
                await animator.animate(element, animationType, { duration: 'fast' });

                // Apply new position
                if (newPositionFunction) {
                    newPositionFunction();
                }

                // Return to view
                return animator.animate(element, 'fadeIn', {
                    duration: duration,
                    delay: isRapidChange ? 50 : theme.stagger / 2
                });
            }

            // Orchestrated slideshow entrance (when slideshow starts)
            async animateSlideshowEntrance() {
                const theme = this.getCurrentTheme();
                const visibleElements = [
                    elements.clock,
                    elements.date,
                    document.querySelector('.source-indicator'),
                    elements.photoCounter,
                    document.querySelector('.metadata-overlay')
                ].filter(el => el && el.style.display !== 'none');

                // Staggered entrance animation
                const animations = visibleElements.map((element, index) => ({
                    element,
                    type: theme.entrance,
                    options: {
                        duration: 'content',
                        delay: index * theme.stagger
                    }
                }));

                return animator.animateSequence(animations, { parallel: true });
            }
        }

        // Initialize adaptive animation controller
        const adaptiveController = new AdaptiveAnimationController();

        // Enhanced photo transition with smart timing
        async function transitionToNextPhotoAnimated() {
            if (!photosArray.length) return;

            const theme = adaptiveController.getCurrentTheme();

            // Fade out overlay elements briefly
            const overlayElements = [
                document.querySelector('.source-indicator'),
                elements.photoCounter,
                document.querySelector('.metadata-overlay')
            ].filter(el => el && el.style.display !== 'none');

            // Quick fade out
            const fadeOutPromises = overlayElements.map(el =>
                animator.animate(el, 'fadeOut', { duration: 'fast' })
            );

            await Promise.all(fadeOutPromises);

            // Change photo (existing logic would go here)
            nextPhoto();

            // Staggered fade in with theme
            const fadeInAnimations = overlayElements.map((element, index) => ({
                element,
                type: theme.entrance,
                options: {
                    duration: 'content',
                    delay: index * (theme.stagger / 2)
                }
            }));

            return animator.animateSequence(fadeInAnimations, { parallel: true });
        }

        // =================== End Phase 4C ===================

        // Expose updateConfig function for backend communication
        window.updateConfig = async function(newConfig) {
            // Merge new config with existing config
            Object.assign(config, newConfig);

            // Re-apply source indicator styling if any source option changed
            if (currentPhotoIndex !== -1 && (newConfig.sourcePosition || newConfig.sourceBackground ||
                newConfig.sourceColor || newConfig.sourceFontSize || newConfig.sourceBackgroundOpacity || newConfig.sourceSize || newConfig.sourceOpacity || newConfig.sourceBorderRadius || newConfig.sourcePadding || newConfig.sourceShadow || newConfig.sourceCustomX || newConfig.sourceCustomY)) {
                await applySourceIndicatorPosition();
            }

            // Re-apply counter styling if any counter option changed
            if (currentPhotoIndex !== -1 && (newConfig.counterPosition || newConfig.counterBackground ||
                newConfig.counterColor || newConfig.counterFontSize || newConfig.counterBackgroundOpacity || newConfig.counterSize || newConfig.counterOpacity || newConfig.counterBorderRadius || newConfig.counterPadding || newConfig.counterShadow || newConfig.counterCustomX || newConfig.counterCustomY)) {
                await applyPhotoCounterPosition();
            }

            // Re-apply clock styling if any clock option changed
            if (newConfig.clockFontSize || newConfig.clockCustomFontSize || newConfig.clockColor || newConfig.clockBackground || newConfig.clockOpacity || newConfig.clockPosition || newConfig.clockBackgroundOpacity || newConfig.clockBorderRadius || newConfig.clockPadding || newConfig.clockShadow || newConfig.clockCustomX || newConfig.clockCustomY || newConfig.showClock !== undefined) {
                await applyClock();
            }

            // Re-apply date styling if any date option changed
            if (newConfig.dateFontSize || newConfig.dateCustomFontSize || newConfig.dateColor || newConfig.dateBackground || newConfig.dateSize || newConfig.dateOpacity || newConfig.datePosition || newConfig.dateBackgroundOpacity || newConfig.dateBorderRadius || newConfig.datePadding || newConfig.dateShadow || newConfig.dateCustomX || newConfig.dateCustomY || newConfig.showDate !== undefined) {
                await applyDate();
            }

            // Re-apply metadata styling if any metadata option changed
            if (newConfig.metadataColor || newConfig.metadataBackground || newConfig.metadataFontSize || newConfig.metadataBackgroundOpacity || newConfig.metadataBorderRadius || newConfig.metadataPadding || newConfig.metadataShadow || newConfig.metadataCustomX || newConfig.metadataCustomY) {
                if (currentPhotoIndex !== -1) {
                    updateMetadataOverlay();
                }
            }

            // Handle animation settings changes
            if (newConfig.animationTheme !== undefined) {
                adaptiveController.applyTheme(newConfig.animationTheme);
                console.log('Animation theme updated to:', newConfig.animationTheme);
            }

            if (newConfig.animationSpeed !== undefined) {
                adaptiveController.setBaseSpeed(newConfig.animationSpeed);
                console.log('Animation speed updated to:', newConfig.animationSpeed);
            }

            if (newConfig.animationEnabled !== undefined) {
                // Toggle animation system on/off
                if (newConfig.animationEnabled === false) {
                    animator.cancelAllAnimations();
                    animator.setGlobalSpeed(0.01); // Effectively disable animations
                } else {
                    adaptiveController.updateAnimationSpeed(); // Restore normal speed
                }
                console.log('Animations enabled:', newConfig.animationEnabled);
            }
        };

        console.log('Slideshow HTML loaded and ready');
    </script>
</body>
</html>