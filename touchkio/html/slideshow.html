<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TouchKio Slideshow</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            cursor: none;
            user-select: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .slideshow-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .photo-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .photo-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: blur(20px) brightness(0.3);
            transform: scale(1.1);
            opacity: 0;
            transition: opacity 2s ease-in-out;
        }

        .photo {
            position: absolute;
            opacity: 0;
            transform: scale(1);
            filter: blur(0px);
            transition: all 2s ease-in-out;
            z-index: 1;
        }

        .photo.fit-contain {
            /* Smart contain: fill viewport height for square/landscape, width for portrait */
            width: auto;
            height: 100vh;
            max-width: 100vw;
            object-fit: contain;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .photo.fit-contain-original {
            /* Original contain behavior */
            max-width: 100vw;
            max-height: 100vh;
            width: auto;
            height: auto;
            object-fit: contain;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .photo.fit-cover {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .photo.fit-fill {
            width: 100%;
            height: 100%;
            object-fit: fill;
        }

        /* Removed orientation-specific fit modes - smart contain handles all cases */

        .photo.visible {
            opacity: 1;
        }

        .photo-background.visible {
            opacity: 1;
        }

        .photo.loading {
            opacity: 0.3;
        }

        /* Fade transition */
        .transition-fade .photo {
            transition: opacity 2s ease-in-out;
        }

        /* Slide transition */
        .transition-slide .photo {
            transform: translateX(100%);
            transition: transform 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-slide .photo.visible {
            transform: translateX(0);
        }

        /* Zoom transition */
        .transition-zoom .photo {
            transform: scale(0.8);
            transition: transform 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-zoom .photo.visible {
            transform: scale(1);
        }

        /* Blur transition */
        .transition-blur .photo {
            filter: blur(10px);
            transition: filter 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-blur .photo.visible {
            filter: blur(0px);
        }

        /* Rotate transition */
        .transition-rotate .photo {
            transform: rotate(-10deg) scale(0.9);
            transition: transform 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-rotate .photo.visible {
            transform: rotate(0deg) scale(1);
        }

        .overlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0px;
            line-height: 0.9;
            z-index: 10;
        }

        .overlay.pos-center {
            align-items: center;
        }

        .overlay.pos-top-left,
        .overlay.pos-bottom-left {
            align-items: flex-start;
        }

        .overlay.background-dark {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
        }

        .overlay.background-light {
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .overlay.background-none {
            background: none;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* Position classes */
        .pos-top-left { top: 20px; left: 20px; right: auto; bottom: auto; }
        .pos-top-right { top: 20px; right: 20px; left: auto; bottom: auto; }
        .pos-bottom-left { bottom: 20px; left: 20px; right: auto; top: auto; }
        .pos-bottom-right { bottom: 20px; right: 20px; left: auto; top: auto; }
        .pos-center {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            right: auto;
            bottom: auto;
        }

        /* Size classes for clock */
        .clock.size-tiny { font-size: 1rem !important; }
        .clock.size-small { font-size: 1.5rem !important; }
        .clock.size-medium { font-size: 2rem !important; }
        .clock.size-large { font-size: 2.5rem !important; }
        .clock.size-xlarge { font-size: 4rem !important; }
        .clock.size-xxlarge { font-size: 6rem !important; }
        .clock.size-massive { font-size: 8rem !important; }
        .clock.size-giant { font-size: 12rem !important; }

        .date.size-tiny { font-size: 0.6rem !important; }
        .date.size-small { font-size: 0.8rem !important; }
        .date.size-medium { font-size: 1rem !important; }
        .date.size-large { font-size: 1.2rem !important; }
        .date.size-xlarge { font-size: 1.6rem !important; }
        .date.size-xxlarge { font-size: 2.2rem !important; }
        .date.size-massive { font-size: 3rem !important; }
        .date.size-giant { font-size: 4rem !important; }

        /* Size classes for indicators */
        .size-small {
            padding: 8px 12px;
            font-size: 0.7rem;
        }
        .size-medium {
            padding: 10px 15px;
            font-size: 0.8rem;
        }
        .size-large {
            padding: 12px 18px;
            font-size: 0.9rem;
        }

        .clock {
            font-weight: 300;
            letter-spacing: 2px;
            line-height: 1;
            margin: 0;
        }

        .date {
            opacity: 0.8;
            line-height: 1;
            margin: 0;
            margin-top: -0.1em;
        }

        .source-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        .source-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        .source-icon.google {
            background: #4285f4;
        }

        .source-icon.local {
            background: #34a853;
        }

        .photo-counter {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        .metadata-overlay {
            position: absolute;
            bottom: 20px;
            right: 50%;
            transform: translateX(50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.7rem;
            backdrop-filter: blur(10px);
            z-index: 10;
            text-align: center;
            max-width: 80%;
            display: none;
            transition: opacity 1s ease-in-out;
            opacity: 0;
        }

        .metadata-overlay.background-dark {
            background: rgba(0, 0, 0, 0.7);
        }

        .metadata-overlay.background-light {
            background: rgba(255, 255, 255, 0.3);
            color: #333;
        }

        .metadata-overlay.background-blue {
            background: rgba(52, 152, 219, 0.7);
            color: white;
        }

        .metadata-overlay.background-green {
            background: rgba(52, 168, 83, 0.7);
            color: white;
        }

        .metadata-overlay.background-red {
            background: rgba(231, 76, 60, 0.7);
            color: white;
        }

        .metadata-overlay.background-purple {
            background: rgba(155, 89, 182, 0.7);
            color: white;
        }

        .metadata-overlay.background-none {
            background: none !important;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .metadata-line {
            margin: 2px 0;
            line-height: 1.2;
        }

        .metadata-filename {
            font-weight: bold;
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .metadata-date {
            color: #ccc;
            font-size: 0.8em;
        }

        .metadata-camera {
            color: #aaa;
            font-size: 0.75em;
        }

        .metadata-exposure {
            color: #888;
            font-size: 0.7em;
            font-family: monospace;
        }

        .metadata-location {
            color: #999;
            font-size: 0.7em;
        }

        /* Metadata overlay positioning */
        .metadata-overlay.pos-top-left { top: 20px; left: 20px; right: auto; bottom: auto; transform: none; }
        .metadata-overlay.pos-top-center { top: 20px; left: 50%; right: auto; bottom: auto; transform: translateX(-50%); }
        .metadata-overlay.pos-top-right { top: 20px; right: 20px; left: auto; bottom: auto; transform: none; }
        .metadata-overlay.pos-bottom-left { bottom: 20px; left: 20px; right: auto; top: auto; transform: none; }
        .metadata-overlay.pos-bottom-center {
            bottom: 20px;
            left: 50%;
            right: auto;
            top: auto;
            transform: translateX(-50%);
        }
        .metadata-overlay.pos-bottom-right { bottom: 20px; right: 20px; left: auto; top: auto; transform: none; }
        .metadata-overlay.pos-center {
            top: 50%;
            left: 50%;
            right: auto;
            bottom: auto;
            transform: translate(-50%, -50%);
        }

        /* Font size classes for metadata */
        .metadata-overlay.font-tiny { font-size: 0.5rem !important; }
        .metadata-overlay.font-small { font-size: 0.7rem !important; }
        .metadata-overlay.font-medium { font-size: 0.9rem !important; }
        .metadata-overlay.font-large { font-size: 1.1rem !important; }
        .metadata-overlay.font-xlarge { font-size: 1.4rem !important; }
        .metadata-overlay.font-xxlarge { font-size: 1.8rem !important; }

        /* Smooth text content transitions - overlay stays in place */
        .metadata-overlay.visible {
            opacity: 1;
        }

        .metadata-overlay.transitioning {
            opacity: 0.3;
        }

        /* Individual metadata line transitions */
        .metadata-line {
            transition: opacity 1s ease-in-out, filter 1s ease-in-out;
        }

        .metadata-line.fade-out {
            opacity: 0;
        }

        .metadata-line.blur-out {
            opacity: 0;
            filter: blur(3px);
        }

        .metadata-line.slide-up-out {
            opacity: 0;
            transform: translateY(-20px);
        }

        .metadata-line.slide-down-out {
            opacity: 0;
            transform: translateY(20px);
        }

        .metadata-line.glow-out {
            opacity: 0;
            text-shadow: 0 0 15px currentColor;
        }

        .metadata-line.typewriter-out {
            opacity: 0;
            letter-spacing: 0.2em;
        }

        /* Enhanced transitions for transform effects */
        .metadata-line {
            transition: opacity 1s ease-in-out, filter 1s ease-in-out, transform 1s ease-in-out, text-shadow 1s ease-in-out, letter-spacing 1s ease-in-out;
        }

        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.9);
            padding: 20px 30px;
            border-radius: 10px;
            font-size: 1.2rem;
            text-align: center;
            display: none;
        }

        .no-photos {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0.7;
        }

        .no-photos h2 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .no-photos p {
            font-size: 1.2rem;
        }

        .preload-container {
            position: absolute;
            top: -9999px;
            left: -9999px;
            opacity: 0;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .clock {
                font-size: 2rem;
            }

            .overlay {
                bottom: 10px;
                right: 10px;
                padding: 10px 15px;
            }

            .source-indicator,
            .photo-counter {
                bottom: 10px;
                left: 10px;
                padding: 8px 12px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="slideshow-container">
        <div class="photo-container">
            <img id="bg1" class="photo-background" alt="Background 1">
            <img id="bg2" class="photo-background" alt="Background 2">
            <img id="photo1" class="photo" alt="Slideshow Photo 1">
            <img id="photo2" class="photo" alt="Slideshow Photo 2">
            <div class="preload-container">
                <img id="preloadPhoto" alt="Preload Photo">
            </div>
        </div>

        <div class="source-indicator">
            <div class="source-icon" id="sourceIcon"></div>
            <span id="sourceText">Local Photos</span>
        </div>

        <div class="photo-counter">
            <span id="photoCounter">0 / 0</span>
        </div>

        <div class="metadata-overlay" id="metadataOverlay">
            <div class="metadata-line metadata-filename" id="metadataFilename"></div>
            <div class="metadata-line metadata-date" id="metadataDate"></div>
            <div class="metadata-line metadata-camera" id="metadataCamera"></div>
            <div class="metadata-line metadata-exposure" id="metadataExposure"></div>
            <div class="metadata-line metadata-location" id="metadataLocation"></div>
        </div>

        <div class="overlay" id="clockOverlay">
            <div class="clock" id="clock">00:00</div>
            <div class="date" id="date">Loading...</div>
        </div>

        <div class="loading-indicator" id="loadingIndicator">
            <div class="spinner"></div>
        </div>

        <div class="error-message" id="errorMessage">
            Failed to load photo
        </div>

        <div class="no-photos" id="noPhotos" style="display: none;">
            <h2>No Photos Available</h2>
            <p>Add photos to your Pictures folder or configure Google Photos</p>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');

        let config = {};
        let photos = [];
        let currentIndex = 0;
        let clockInterval = null;
        let currentPhotoElement = 1; // Track which photo element is currently visible

        const elements = {
            bg1: document.getElementById('bg1'),
            bg2: document.getElementById('bg2'),
            photo1: document.getElementById('photo1'),
            photo2: document.getElementById('photo2'),
            preloadPhoto: document.getElementById('preloadPhoto'),
            sourceIcon: document.getElementById('sourceIcon'),
            sourceText: document.getElementById('sourceText'),
            photoCounter: document.getElementById('photoCounter'),
            metadataOverlay: document.getElementById('metadataOverlay'),
            metadataFilename: document.getElementById('metadataFilename'),
            metadataDate: document.getElementById('metadataDate'),
            metadataCamera: document.getElementById('metadataCamera'),
            metadataExposure: document.getElementById('metadataExposure'),
            metadataLocation: document.getElementById('metadataLocation'),
            clockOverlay: document.getElementById('clockOverlay'),
            clock: document.getElementById('clock'),
            date: document.getElementById('date'),
            loadingIndicator: document.getElementById('loadingIndicator'),
            errorMessage: document.getElementById('errorMessage'),
            noPhotos: document.getElementById('noPhotos')
        };

        function initializeClock() {
            if (clockInterval) {
                clearInterval(clockInterval);
            }

            function updateClock() {
                const now = new Date();
                const timeString = now.toLocaleTimeString([], {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
                const dateString = now.toLocaleDateString([], {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });

                elements.clock.textContent = timeString;
                elements.date.textContent = dateString;
            }

            updateClock();
            clockInterval = setInterval(updateClock, 1000);
        }

        function updateSourceIndicator(photo) {
            if (photo.type === 'google') {
                elements.sourceIcon.className = 'source-icon google';
                elements.sourceText.textContent = 'Google Photos';
            } else {
                elements.sourceIcon.className = 'source-icon local';
                elements.sourceText.textContent = 'Local Photos';
            }
        }

        function updatePhotoCounter(current, total) {
            elements.photoCounter.textContent = `${current + 1} / ${total}`;
        }

        function updateMetadataDisplay(photo) {
            // Use smooth content transition for photo changes
            transitionMetadataContent(photo);
        }

        function showMetadataOverlay() {
            updateMetadataStyles();
            elements.metadataOverlay.style.display = 'block';
            // Force reflow before adding visible class
            elements.metadataOverlay.offsetHeight;
            elements.metadataOverlay.classList.add('visible');
        }

        function hideMetadataOverlay() {
            elements.metadataOverlay.classList.remove('visible');
            const transitionDuration = config.transitionDuration || 2000;
            setTimeout(() => {
                elements.metadataOverlay.style.display = 'none';
            }, transitionDuration / 2); // Match half transition duration
        }

        function transitionMetadataContent(newPhoto) {
            if (!config.showMetadata || !newPhoto.metadata) {
                hideMetadataOverlay();
                return;
            }

            const transitionType = config.metadataTransitionType || 'fade';
            const transitionDuration = config.transitionDuration || 2000; // Get slideshow transition duration
            const halfDuration = transitionDuration / 2;
            const metadataLines = elements.metadataOverlay.querySelectorAll('.metadata-line');

            // Update CSS transition duration to match slideshow
            metadataLines.forEach(line => {
                line.style.transition = `opacity ${halfDuration}ms ease-in-out, filter ${halfDuration}ms ease-in-out, transform ${halfDuration}ms ease-in-out, text-shadow ${halfDuration}ms ease-in-out, letter-spacing ${halfDuration}ms ease-in-out`;
            });

            // Start transition - apply appropriate out effect
            const outClass = `${transitionType}-out`;
            metadataLines.forEach(line => line.classList.add(outClass));

            // After fade out, update content and fade in
            setTimeout(() => {
                updateMetadataContent(newPhoto);

                // Fade in new content
                setTimeout(() => {
                    metadataLines.forEach(line => {
                        line.classList.remove('fade-out', 'blur-out', 'slide-up-out', 'slide-down-out', 'glow-out', 'typewriter-out');
                    });
                }, 50);
            }, halfDuration);
        }

        function updateMetadataContent(photo) {
            const metadata = photo.metadata;
            let hasContent = false;

            // Clear all fields first
            elements.metadataFilename.textContent = '';
            elements.metadataDate.textContent = '';
            elements.metadataCamera.textContent = '';
            elements.metadataExposure.textContent = '';
            elements.metadataLocation.textContent = '';

            // Show/hide filename
            if (config.showFilename && metadata.filename) {
                elements.metadataFilename.textContent = metadata.filename;
                elements.metadataFilename.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataFilename.style.display = 'none';
            }

            // Show/hide date taken
            if (config.showDateTaken && metadata.dateFormatted) {
                elements.metadataDate.textContent = metadata.dateFormatted;
                elements.metadataDate.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataDate.style.display = 'none';
            }

            // Show/hide camera info
            if (config.showCameraInfo && metadata.camera) {
                let cameraText = metadata.camera;
                if (metadata.lens) {
                    cameraText += ` • ${metadata.lens}`;
                }
                elements.metadataCamera.textContent = cameraText;
                elements.metadataCamera.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataCamera.style.display = 'none';
            }

            // Show/hide exposure settings
            if (config.showCameraInfo && metadata.exposure) {
                elements.metadataExposure.textContent = metadata.exposure;
                elements.metadataExposure.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataExposure.style.display = 'none';
            }

            // Show/hide location (GPS coordinates)
            if (config.showLocation && metadata.location) {
                elements.metadataLocation.textContent = `📍 ${metadata.location.formatted}`;
                elements.metadataLocation.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataLocation.style.display = 'none';
            }

            // Show/hide entire overlay based on content
            if (hasContent) {
                if (elements.metadataOverlay.style.display === 'none') {
                    showMetadataOverlay();
                }
            } else {
                hideMetadataOverlay();
            }
        }

        function updateMetadataStyles() {
            const overlay = elements.metadataOverlay;

            // Preserve the visible state
            const wasVisible = overlay.classList.contains('visible');

            // Clear existing classes
            overlay.className = 'metadata-overlay';

            // Apply position
            overlay.classList.add(`pos-${config.metadataPosition || 'bottom-center'}`);

            // Apply font size
            overlay.classList.add(`font-${config.metadataFontSize || 'small'}`);

            // Apply background
            overlay.classList.add(`background-${config.metadataBackground || 'dark'}`);

            // Restore visible state if it was visible
            if (wasVisible) {
                overlay.classList.add('visible');
            }

            // Apply custom opacity if set
            if (config.metadataBackgroundOpacity !== undefined) {
                const opacity = config.metadataBackgroundOpacity / 100;
                if (config.metadataBackground === 'dark') {
                    overlay.style.backgroundColor = `rgba(0, 0, 0, ${opacity})`;
                } else if (config.metadataBackground === 'light') {
                    overlay.style.backgroundColor = `rgba(255, 255, 255, ${opacity * 0.4})`;
                } else if (config.metadataBackground === 'blue') {
                    overlay.style.backgroundColor = `rgba(52, 152, 219, ${opacity})`;
                } else if (config.metadataBackground === 'green') {
                    overlay.style.backgroundColor = `rgba(52, 168, 83, ${opacity})`;
                } else if (config.metadataBackground === 'red') {
                    overlay.style.backgroundColor = `rgba(231, 76, 60, ${opacity})`;
                } else if (config.metadataBackground === 'purple') {
                    overlay.style.backgroundColor = `rgba(155, 89, 182, ${opacity})`;
                }
            }
        }

        function showLoading() {
            elements.loadingIndicator.style.display = 'block';
            elements.errorMessage.style.display = 'none';
        }

        function hideLoading() {
            elements.loadingIndicator.style.display = 'none';
        }

        function showError(message = 'Failed to load photo') {
            elements.errorMessage.textContent = message;
            elements.errorMessage.style.display = 'block';
            elements.loadingIndicator.style.display = 'none';
        }

        function hideError() {
            elements.errorMessage.style.display = 'none';
        }

        function getPhotoUrl(photo, index) {
            if (photo.type === 'google') {
                return `http://localhost:${config.port || 8081}/google-photo/${encodeURIComponent(photo.url)}`;
            } else {
                return `http://localhost:${config.port || 8081}/photo/${index !== undefined ? index : photos.indexOf(photo)}`;
            }
        }

        function preloadNextPhoto(index) {
            if (photos.length === 0) return;

            const nextIndex = (index + 1) % photos.length;
            const nextPhoto = photos[nextIndex];

            if (nextPhoto) {
                elements.preloadPhoto.src = getPhotoUrl(nextPhoto, nextIndex);
            }
        }

        function showPhoto(photoData) {
            if (!photoData || !photoData.photo) {
                showError('No photo data received');
                return;
            }

            const { index, photo } = photoData;
            currentIndex = index;

            if (photos.length === 0) {
                elements.noPhotos.style.display = 'block';
                return;
            } else {
                elements.noPhotos.style.display = 'none';
            }

            hideError();

            updateSourceIndicator(photo);
            updatePhotoCounter(index, photos.length);
            updateMetadataDisplay(photo);

            const photoUrl = getPhotoUrl(photo, index);

            // Determine which photo element to use next
            const nextPhotoElement = currentPhotoElement === 1 ? 2 : 1;
            const currentPhoto = elements[`photo${currentPhotoElement}`];
            const nextPhoto = elements[`photo${nextPhotoElement}`];
            const currentBg = elements[`bg${currentPhotoElement}`];
            const nextBg = elements[`bg${nextPhotoElement}`];

            const newPhoto = new Image();

            newPhoto.onload = () => {
                // Set the source on both the foreground and background elements
                nextPhoto.src = photoUrl;
                nextBg.src = photoUrl;

                // Start transition: fade in new photo and background
                setTimeout(() => {
                    nextPhoto.classList.add('visible');
                    nextBg.classList.add('visible');
                    currentPhoto.classList.remove('visible');
                    currentBg.classList.remove('visible');
                }, 50); // Small delay to ensure src is set

                // Update which element is current after transition completes
                setTimeout(() => {
                    currentPhotoElement = nextPhotoElement;
                }, 2000); // Match transition duration

                preloadNextPhoto(index);
            };

            newPhoto.onerror = () => {
                console.error('Failed to load photo:', photoUrl);
                showError(`Failed to load: ${photo.title || 'Unknown photo'}`);

                setTimeout(() => {
                    hideError();
                }, 3000);
            };

            newPhoto.src = photoUrl;
        }

        ipcRenderer.on('slideshow-config', (event, data) => {
            console.log('Received slideshow config:', data);

            if (data.config) {
                config = data.config;

                // Clock configuration
                elements.clockOverlay.style.display = config.showClock ? 'flex' : 'none';
                if (config.showClock) {
                    const clockClasses = [
                        'overlay',
                        `background-${config.clockBackground || 'dark'}`,
                        `pos-${config.clockPosition || 'bottom-right'}`
                    ];
                    elements.clockOverlay.className = clockClasses.join(' ');
                    elements.clockOverlay.style.opacity = config.clockOpacity || 0.7;

                    elements.clock.className = `clock size-${config.clockSize || 'large'}`;
                    elements.date.className = `date size-${config.clockSize || 'large'}`;
                    elements.clock.style.color = config.clockColor || '#ffffff';
                    elements.date.style.color = config.clockColor || '#ffffff';

                    initializeClock();
                }

                // Source indicator configuration
                const sourceIndicator = document.querySelector('.source-indicator');
                sourceIndicator.style.display = config.showSourceIndicator ? 'flex' : 'none';
                if (config.showSourceIndicator) {
                    const sourceClasses = [
                        'source-indicator',
                        `pos-${config.sourcePosition || 'top-left'}`,
                        `size-${config.sourceSize || 'medium'}`
                    ];
                    sourceIndicator.className = sourceClasses.join(' ');
                    sourceIndicator.style.opacity = config.sourceOpacity || 0.8;
                }

                // Photo counter configuration
                const photoCounter = document.querySelector('.photo-counter');
                photoCounter.style.display = config.showPhotoCounter ? 'flex' : 'none';
                if (config.showPhotoCounter) {
                    const counterClasses = [
                        'photo-counter',
                        `pos-${config.counterPosition || 'bottom-left'}`,
                        `size-${config.counterSize || 'medium'}`
                    ];
                    photoCounter.className = counterClasses.join(' ');
                    photoCounter.style.opacity = config.counterOpacity || 0.8;
                }

                // Metadata overlay configuration
                const metadataOverlay = document.querySelector('.metadata-overlay');
                if (config.showMetadata) {
                    // Update all metadata styles when config changes
                    updateMetadataStyles();
                    // Metadata visibility will be handled by updateMetadataDisplay when photos are shown
                } else {
                    metadataOverlay.style.display = 'none';
                }

                // Photo fit configuration - only update if it changed
                if (data.config.photoFit !== undefined) {
                    const photos = document.querySelectorAll('.photo');
                    photos.forEach(photo => {
                        // Preserve the visible state when updating photo fit
                        const wasVisible = photo.classList.contains('visible');
                        photo.className = `photo fit-${config.photoFit || 'contain'}`;
                        if (wasVisible) {
                            photo.classList.add('visible');
                        }
                    });
                }

                // Apply transition type - only update if it changed
                if (data.config.transitionType !== undefined) {
                    const container = document.querySelector('.slideshow-container');
                    container.className = `slideshow-container transition-${config.transitionType || 'fade'}`;
                }
            }

            if (data.photos) {
                photos = data.photos;
                updatePhotoCounter(currentIndex, photos.length);

                if (photos.length === 0) {
                    elements.noPhotos.style.display = 'block';
                }
            }
        });

        ipcRenderer.on('show-photo', (event, photoData) => {
            showPhoto(photoData);
        });

        // Delay before enabling activity detection to prevent false triggers
        let activityDetectionEnabled = false;
        setTimeout(() => {
            activityDetectionEnabled = true;
            console.log('Activity detection enabled');
        }, 1000); // Wait 1 second before enabling

        // Aggressive event capture for VNC and remote clicks
        const triggerUserActivity = () => {
            if (activityDetectionEnabled) {
                console.log('User activity detected in slideshow');
                ipcRenderer.send('slideshow-user-activity');
            }
        };

        // Capture clicks on all elements
        document.addEventListener('click', triggerUserActivity, true);
        document.addEventListener('mousedown', triggerUserActivity, true);
        document.addEventListener('mouseup', triggerUserActivity, true);

        document.addEventListener('keydown', triggerUserActivity);

        // Throttled mousemove to prevent too many events
        let mouseMoveTimeout;
        let lastMouseX = 0;
        let lastMouseY = 0;
        document.addEventListener('mousemove', (e) => {
            // Only trigger on significant mouse movement
            const deltaX = Math.abs(e.clientX - lastMouseX);
            const deltaY = Math.abs(e.clientY - lastMouseY);

            if (deltaX > 10 || deltaY > 10) {
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;

                if (!mouseMoveTimeout) {
                    mouseMoveTimeout = setTimeout(() => {
                        triggerUserActivity();
                        mouseMoveTimeout = null;
                    }, 100);
                }
            }
        });

        document.addEventListener('touchstart', triggerUserActivity);

        // Also detect clicks on the slideshow container specifically
        document.querySelector('.slideshow-container').addEventListener('click', triggerUserActivity, true);

        window.addEventListener('beforeunload', () => {
            if (clockInterval) {
                clearInterval(clockInterval);
            }
        });

        console.log('Slideshow HTML loaded and ready');
    </script>
</body>
</html>