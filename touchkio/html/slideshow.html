<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TouchKio Slideshow</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            cursor: none;
            user-select: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .slideshow-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .photo-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .photo-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: blur(20px) brightness(0.3);
            transform: scale(1.1);
            opacity: 0;
            transition: opacity 2s ease-in-out;
        }

        .photo {
            position: absolute;
            opacity: 0;
            transform: scale(1);
            filter: blur(0px);
            transition: all 2s ease-in-out;
            z-index: 1;
        }

        .photo.fit-contain {
            /* Smart contain: fill viewport height for square/landscape, width for portrait */
            width: auto;
            height: 100vh;
            max-width: 100vw;
            object-fit: contain;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .photo.fit-contain-original {
            /* Original contain behavior */
            max-width: 100vw;
            max-height: 100vh;
            width: auto;
            height: auto;
            object-fit: contain;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .photo.fit-cover {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .photo.fit-fill {
            width: 100%;
            height: 100%;
            object-fit: fill;
        }

        /* Removed orientation-specific fit modes - smart contain handles all cases */

        .photo.visible {
            opacity: 1;
        }

        .photo-background.visible {
            opacity: 1;
        }

        .photo.loading {
            opacity: 0.3;
        }

        /* Fade transition */
        .transition-fade .photo {
            transition: opacity 2s ease-in-out;
        }

        /* Slide transition */
        .transition-slide .photo {
            transform: translateX(100%);
            transition: transform 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-slide .photo.visible {
            transform: translateX(0);
        }

        /* Zoom transition */
        .transition-zoom .photo {
            transform: scale(0.8);
            transition: transform 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-zoom .photo.visible {
            transform: scale(1);
        }

        /* Blur transition */
        .transition-blur .photo {
            filter: blur(10px);
            transition: filter 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-blur .photo.visible {
            filter: blur(0px);
        }

        /* Rotate transition */
        .transition-rotate .photo {
            transform: rotate(-10deg) scale(0.9);
            transition: transform 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-rotate .photo.visible {
            transform: rotate(0deg) scale(1);
        }

        .overlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0px;
            line-height: 0.9;
            z-index: 10;
        }

        .overlay.pos-center {
            align-items: center;
        }

        .overlay.pos-top-left,
        .overlay.pos-bottom-left {
            align-items: flex-start;
        }

        .overlay.background-dark {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
        }

        .overlay.background-light {
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .overlay.background-none {
            background: none;
            backdrop-filter: none !important;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* Position classes */
        .pos-top-left { top: 20px; left: 20px; right: auto; bottom: auto; }
        .pos-top-right { top: 20px; right: 20px; left: auto; bottom: auto; }
        .pos-bottom-left { bottom: 20px; left: 20px; right: auto; top: auto; }
        .pos-bottom-right { bottom: 20px; right: 20px; left: auto; top: auto; }
        .pos-center {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            right: auto;
            bottom: auto;
        }


        .date.size-tiny { font-size: 0.6rem !important; }
        .date.size-small { font-size: 0.8rem !important; }
        .date.size-medium { font-size: 1rem !important; }
        .date.size-large { font-size: 1.2rem !important; }
        .date.size-xlarge { font-size: 1.6rem !important; }
        .date.size-xxlarge { font-size: 2.2rem !important; }
        .date.size-massive { font-size: 3rem !important; }
        .date.size-giant { font-size: 4rem !important; }

        /* Size classes for indicators */
        .size-small {
            padding: 8px 12px;
            font-size: 0.7rem;
        }
        .size-medium {
            padding: 10px 15px;
            font-size: 0.8rem;
        }
        .size-large {
            padding: 12px 18px;
            font-size: 0.9rem;
        }

        .clock {
            position: absolute;
            font-weight: 300;
            letter-spacing: 2px;
            line-height: 1;
            margin: 0;
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        .date {
            position: absolute;
            opacity: 0.8;
            line-height: 1;
            margin: 0;
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        .source-indicator {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
            /* NO default position - will be set by pos- classes */
        }

        .source-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        .source-icon.google {
            background: #4285f4;
        }

        .source-icon.local {
            background: #34a853;
        }

        .photo-counter {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
            /* NO default position - will be set by pos- classes */
        }

        /* Photo counter positioning - uses general .pos- classes */

        /* Source indicator size classes */
        .source-indicator.size-small {
            font-size: 0.7rem !important;
            padding: 8px 12px !important;
        }
        .source-indicator.size-medium {
            font-size: 0.9rem !important;
            padding: 10px 15px !important;
        }
        .source-indicator.size-large {
            font-size: 1.1rem !important;
            padding: 12px 18px !important;
        }

        /* Photo counter size classes */
        .photo-counter.size-small {
            font-size: 0.7rem !important;
            padding: 8px 12px !important;
        }
        .photo-counter.size-medium {
            font-size: 0.9rem !important;
            padding: 10px 15px !important;
        }
        .photo-counter.size-large {
            font-size: 1.1rem !important;
            padding: 12px 18px !important;
        }

        /* Source indicator background colors */
        .source-indicator.background-dark { background: rgba(0, 0, 0, 0.7) !important; color: white; }
        .source-indicator.background-light { background: rgba(255, 255, 255, 0.8) !important; color: #333; }
        .source-indicator.background-blue { background: rgba(52, 152, 219, 0.7) !important; color: white; }
        .source-indicator.background-green { background: rgba(46, 204, 113, 0.7) !important; color: white; }
        .source-indicator.background-red { background: rgba(231, 76, 60, 0.7) !important; color: white; }
        .source-indicator.background-purple { background: rgba(155, 89, 182, 0.7) !important; color: white; }
        .source-indicator.background-none { background: transparent !important; backdrop-filter: none !important; }

        /* Photo counter background colors */
        .photo-counter.background-dark { background: rgba(0, 0, 0, 0.7) !important; color: white; }
        .photo-counter.background-light { background: rgba(255, 255, 255, 0.8) !important; color: #333; }
        .photo-counter.background-blue { background: rgba(52, 152, 219, 0.7) !important; color: white; }
        .photo-counter.background-green { background: rgba(46, 204, 113, 0.7) !important; color: white; }
        .photo-counter.background-red { background: rgba(231, 76, 60, 0.7) !important; color: white; }
        .photo-counter.background-purple { background: rgba(155, 89, 182, 0.7) !important; color: white; }
        .photo-counter.background-none { background: transparent !important; backdrop-filter: none !important; }

        /* Background classes for clock and date */
        .clock.background-dark, .date.background-dark { background: rgba(0, 0, 0, 0.7) !important; color: white; }
        .clock.background-light, .date.background-light { background: rgba(255, 255, 255, 0.8) !important; color: #333; }
        .clock.background-blue, .date.background-blue { background: rgba(52, 152, 219, 0.7) !important; color: white; }
        .clock.background-green, .date.background-green { background: rgba(46, 204, 113, 0.7) !important; color: white; }
        .clock.background-red, .date.background-red { background: rgba(231, 76, 60, 0.7) !important; color: white; }
        .clock.background-purple, .date.background-purple { background: rgba(155, 89, 182, 0.7) !important; color: white; }
        .clock.background-none, .date.background-none { background: transparent !important; backdrop-filter: none !important; }

        /* Font size classes for all elements - high specificity to override size classes */
        .clock.font-size-tiny, .date.font-size-tiny { font-size: 0.6rem !important; }
        .clock.font-size-small, .date.font-size-small { font-size: 0.8rem !important; }
        .clock.font-size-medium, .date.font-size-medium { font-size: 1.0rem !important; }
        .clock.font-size-large, .date.font-size-large { font-size: 1.2rem !important; }
        .clock.font-size-xlarge, .date.font-size-xlarge { font-size: 1.4rem !important; }
        .clock.font-size-xxlarge, .date.font-size-xxlarge { font-size: 1.6rem !important; }

        .source-indicator.font-size-tiny { font-size: 0.6rem !important; }
        .source-indicator.font-size-small { font-size: 0.8rem !important; }
        .source-indicator.font-size-medium { font-size: 1.0rem !important; }
        .source-indicator.font-size-large { font-size: 1.2rem !important; }
        .source-indicator.font-size-xlarge { font-size: 1.4rem !important; }
        .source-indicator.font-size-xxlarge { font-size: 1.6rem !important; }

        .photo-counter.font-size-tiny { font-size: 0.6rem !important; }
        .photo-counter.font-size-small { font-size: 0.8rem !important; }
        .photo-counter.font-size-medium { font-size: 1.0rem !important; }
        .photo-counter.font-size-large { font-size: 1.2rem !important; }
        .photo-counter.font-size-xlarge { font-size: 1.4rem !important; }
        .photo-counter.font-size-xxlarge { font-size: 1.6rem !important; }

        .metadata-overlay {
            position: absolute;
            bottom: 20px;
            right: 50%;
            transform: translateX(50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.7rem;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
            text-align: center;
            max-width: 80%;
            display: none;
            transition: opacity 1s ease-in-out;
            opacity: 0;
        }

        .metadata-overlay.background-dark {
            background: rgba(0, 0, 0, 0.7);
        }

        .metadata-overlay.background-light {
            background: rgba(255, 255, 255, 0.3);
            color: #333;
        }

        .metadata-overlay.background-blue {
            background: rgba(52, 152, 219, 0.7);
            color: white;
        }

        .metadata-overlay.background-green {
            background: rgba(52, 168, 83, 0.7);
            color: white;
        }

        .metadata-overlay.background-red {
            background: rgba(231, 76, 60, 0.7);
            color: white;
        }

        .metadata-overlay.background-purple {
            background: rgba(155, 89, 182, 0.7);
            color: white;
        }

        .metadata-overlay.background-none {
            background: none !important;
            backdrop-filter: none !important;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .metadata-line {
            margin: 2px 0;
            line-height: 1.2;
        }

        .metadata-filename {
            font-weight: bold;
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .metadata-date {
            color: #ccc;
            font-size: 0.8em;
        }

        .metadata-camera {
            color: #aaa;
            font-size: 0.75em;
        }

        .metadata-exposure {
            color: #888;
            font-size: 0.7em;
            font-family: monospace;
        }

        .metadata-location {
            color: #999;
            font-size: 0.7em;
        }

        /* Metadata overlay positioning */
        .metadata-overlay.pos-top-left { top: 20px; left: 20px; right: auto; bottom: auto; transform: none; }
        .metadata-overlay.pos-top-center { top: 20px; left: 50%; right: auto; bottom: auto; transform: translateX(-50%); }
        .metadata-overlay.pos-top-right { top: 20px; right: 20px; left: auto; bottom: auto; transform: none; }
        .metadata-overlay.pos-bottom-left { bottom: 20px; left: 20px; right: auto; top: auto; transform: none; }
        .metadata-overlay.pos-bottom-center {
            bottom: 20px;
            left: 50%;
            right: auto;
            top: auto;
            transform: translateX(-50%);
        }
        .metadata-overlay.pos-bottom-right { bottom: 20px; right: 20px; left: auto; top: auto; transform: none; }
        .metadata-overlay.pos-center {
            top: 50%;
            left: 50%;
            right: auto;
            bottom: auto;
            transform: translate(-50%, -50%);
        }

        /* Font size classes for metadata */
        .metadata-overlay.font-tiny { font-size: 0.5rem !important; }
        .metadata-overlay.font-small { font-size: 0.7rem !important; }
        .metadata-overlay.font-medium { font-size: 0.9rem !important; }
        .metadata-overlay.font-large { font-size: 1.1rem !important; }
        .metadata-overlay.font-xlarge { font-size: 1.4rem !important; }
        .metadata-overlay.font-xxlarge { font-size: 1.8rem !important; }

        /* Smooth text content transitions - overlay stays in place */
        .metadata-overlay.visible {
            opacity: 1;
        }

        .metadata-overlay.transitioning {
            opacity: 0.3;
        }

        /* Individual metadata line transitions */
        .metadata-line {
            transition: opacity 1s ease-in-out, filter 1s ease-in-out;
        }

        .metadata-line.fade-out {
            opacity: 0;
        }

        .metadata-line.blur-out {
            opacity: 0;
            filter: blur(3px);
        }

        .metadata-line.slide-up-out {
            opacity: 0;
            transform: translateY(-20px);
        }

        .metadata-line.slide-down-out {
            opacity: 0;
            transform: translateY(20px);
        }

        .metadata-line.glow-out {
            opacity: 0;
            text-shadow: 0 0 15px currentColor;
        }

        .metadata-line.typewriter-out {
            opacity: 0;
            letter-spacing: 0.2em;
        }

        /* Enhanced transitions for transform effects */
        .metadata-line {
            transition: opacity 1s ease-in-out, filter 1s ease-in-out, transform 1s ease-in-out, text-shadow 1s ease-in-out, letter-spacing 1s ease-in-out;
        }

        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.9);
            padding: 20px 30px;
            border-radius: 10px;
            font-size: 1.2rem;
            text-align: center;
            display: none;
        }

        .no-photos {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0.7;
        }

        .no-photos h2 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .no-photos p {
            font-size: 1.2rem;
        }

        .preload-container {
            position: absolute;
            top: -9999px;
            left: -9999px;
            opacity: 0;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .clock {
                font-size: 2rem;
            }

            .overlay {
                bottom: 10px;
                right: 10px;
                padding: 10px 15px;
            }

            .source-indicator,
            .photo-counter {
                padding: 8px 12px;
                font-size: 0.8rem;
                /* Removed fixed positioning - pos- classes will handle this */
            }
        }
    </style>
</head>
<body>
    <div class="slideshow-container">
        <div class="photo-container">
            <img id="bg1" class="photo-background" alt="Background 1">
            <img id="bg2" class="photo-background" alt="Background 2">
            <img id="photo1" class="photo" alt="Slideshow Photo 1">
            <img id="photo2" class="photo" alt="Slideshow Photo 2">
            <div class="preload-container">
                <img id="preloadPhoto" alt="Preload Photo">
            </div>
        </div>

        <div class="source-indicator pos-top-left size-medium">
            <div class="source-icon" id="sourceIcon"></div>
            <span id="sourceText">Local Photos</span>
        </div>

        <div class="photo-counter pos-bottom-left size-medium">
            <span id="photoCounter">0 / 0</span>
        </div>

        <div class="metadata-overlay" id="metadataOverlay">
            <div class="metadata-line metadata-filename" id="metadataFilename"></div>
            <div class="metadata-line metadata-date" id="metadataDate"></div>
            <div class="metadata-line metadata-camera" id="metadataCamera"></div>
            <div class="metadata-line metadata-exposure" id="metadataExposure"></div>
            <div class="metadata-line metadata-location" id="metadataLocation"></div>
        </div>

        <div class="clock pos-bottom-right size-large background-dark" id="clock">00:00</div>
        <div class="date pos-bottom-left size-medium background-dark" id="date">Loading...</div>

        <div class="loading-indicator" id="loadingIndicator">
            <div class="spinner"></div>
        </div>

        <div class="error-message" id="errorMessage">
            Failed to load photo
        </div>

        <div class="no-photos" id="noPhotos" style="display: none;">
            <h2>No Photos Available</h2>
            <p>Add photos to your Pictures folder or configure Google Photos</p>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');

        let config = {};
        let photos = [];
        let currentIndex = 0;
        let clockInterval = null;
        let currentPhotoElement = 1; // Track which photo element is currently visible

        const elements = {
            bg1: document.getElementById('bg1'),
            bg2: document.getElementById('bg2'),
            photo1: document.getElementById('photo1'),
            photo2: document.getElementById('photo2'),
            preloadPhoto: document.getElementById('preloadPhoto'),
            sourceIcon: document.getElementById('sourceIcon'),
            sourceText: document.getElementById('sourceText'),
            photoCounter: document.getElementById('photoCounter'),
            metadataOverlay: document.getElementById('metadataOverlay'),
            metadataFilename: document.getElementById('metadataFilename'),
            metadataDate: document.getElementById('metadataDate'),
            metadataCamera: document.getElementById('metadataCamera'),
            metadataExposure: document.getElementById('metadataExposure'),
            metadataLocation: document.getElementById('metadataLocation'),
            clock: document.getElementById('clock'),
            date: document.getElementById('date'),
            loadingIndicator: document.getElementById('loadingIndicator'),
            errorMessage: document.getElementById('errorMessage'),
            noPhotos: document.getElementById('noPhotos')
        };

        function initializeClock() {
            if (clockInterval) {
                clearInterval(clockInterval);
            }

            function updateClock() {
                const now = new Date();
                const timeString = now.toLocaleTimeString([], {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
                const dateString = now.toLocaleDateString([], {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });

                elements.clock.textContent = timeString;
                elements.date.textContent = dateString;
            }

            updateClock();
            clockInterval = setInterval(updateClock, 1000);
        }

        function updateSourceIndicator(photo) {
            if (photo.type === 'google') {
                elements.sourceIcon.className = 'source-icon google';
                elements.sourceText.textContent = 'Google Photos';
            } else {
                elements.sourceIcon.className = 'source-icon local';
                elements.sourceText.textContent = 'Local Photos';
            }
        }

        function updatePhotoCounter(current, total) {
            elements.photoCounter.textContent = `${current + 1} / ${total}`;
        }

        function updateMetadataDisplay(photo) {
            // Use smooth content transition for photo changes
            transitionMetadataContent(photo);
        }

        function showMetadataOverlay() {
            updateMetadataStyles();
            elements.metadataOverlay.style.display = 'block';
            // Force reflow before adding visible class
            elements.metadataOverlay.offsetHeight;
            elements.metadataOverlay.classList.add('visible');
        }

        function hideMetadataOverlay() {
            elements.metadataOverlay.classList.remove('visible');
            const transitionDuration = config.transitionDuration || 2000;
            setTimeout(() => {
                elements.metadataOverlay.style.display = 'none';
            }, transitionDuration / 2); // Match half transition duration
        }

        function transitionMetadataContent(newPhoto) {
            if (!config.showMetadata || !newPhoto.metadata) {
                hideMetadataOverlay();
                return;
            }

            const transitionType = config.metadataTransitionType || 'fade';
            const transitionDuration = config.transitionDuration || 2000; // Get slideshow transition duration
            const halfDuration = transitionDuration / 2;
            const metadataLines = elements.metadataOverlay.querySelectorAll('.metadata-line');

            // Update CSS transition duration to match slideshow
            metadataLines.forEach(line => {
                line.style.transition = `opacity ${halfDuration}ms ease-in-out, filter ${halfDuration}ms ease-in-out, transform ${halfDuration}ms ease-in-out, text-shadow ${halfDuration}ms ease-in-out, letter-spacing ${halfDuration}ms ease-in-out`;
            });

            // Start transition - apply appropriate out effect
            const outClass = `${transitionType}-out`;
            metadataLines.forEach(line => line.classList.add(outClass));

            // After fade out, update content and fade in
            setTimeout(() => {
                updateMetadataContent(newPhoto);

                // Fade in new content
                setTimeout(() => {
                    metadataLines.forEach(line => {
                        line.classList.remove('fade-out', 'blur-out', 'slide-up-out', 'slide-down-out', 'glow-out', 'typewriter-out');
                    });
                }, 50);
            }, halfDuration);
        }

        function updateMetadataContent(photo) {
            const metadata = photo.metadata;
            let hasContent = false;

            // Clear all fields first
            elements.metadataFilename.textContent = '';
            elements.metadataDate.textContent = '';
            elements.metadataCamera.textContent = '';
            elements.metadataExposure.textContent = '';
            elements.metadataLocation.textContent = '';

            // Show/hide filename
            if (config.showFilename && metadata.filename) {
                elements.metadataFilename.textContent = metadata.filename;
                elements.metadataFilename.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataFilename.style.display = 'none';
            }

            // Show/hide date taken
            if (config.showDateTaken && metadata.dateFormatted) {
                elements.metadataDate.textContent = metadata.dateFormatted;
                elements.metadataDate.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataDate.style.display = 'none';
            }

            // Show/hide camera info
            if (config.showCameraInfo && metadata.camera) {
                let cameraText = metadata.camera;
                if (metadata.lens) {
                    cameraText += ` • ${metadata.lens}`;
                }
                elements.metadataCamera.textContent = cameraText;
                elements.metadataCamera.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataCamera.style.display = 'none';
            }

            // Show/hide exposure settings
            if (config.showCameraInfo && metadata.exposure) {
                elements.metadataExposure.textContent = metadata.exposure;
                elements.metadataExposure.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataExposure.style.display = 'none';
            }

            // Show/hide location (GPS coordinates)
            if (config.showLocation && metadata.location) {
                elements.metadataLocation.textContent = `📍 ${metadata.location.formatted}`;
                elements.metadataLocation.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataLocation.style.display = 'none';
            }

            // Show/hide entire overlay based on content
            if (hasContent) {
                if (elements.metadataOverlay.style.display === 'none') {
                    showMetadataOverlay();
                }
            } else {
                hideMetadataOverlay();
            }
        }

        function updateMetadataStyles() {
            const overlay = elements.metadataOverlay;

            // Preserve the visible state
            const wasVisible = overlay.classList.contains('visible');

            // Clear existing classes
            overlay.className = 'metadata-overlay';

            // Apply position
            overlay.classList.add(`pos-${config.metadataPosition || 'bottom-center'}`);

            // Apply background
            overlay.classList.add(`background-${config.metadataBackground || 'dark'}`);

            // Apply custom font size if specified
            if (config.metadataCustomFontSize && config.metadataCustomFontSize.trim() !== '') {
                overlay.style.fontSize = config.metadataCustomFontSize;
            } else {
                overlay.style.fontSize = ''; // Clear custom font size
            }

            // Restore visible state if it was visible
            if (wasVisible) {
                overlay.classList.add('visible');
            }

            // Apply custom opacity if set
            if (config.metadataBackgroundOpacity !== undefined) {
                const opacity = config.metadataBackgroundOpacity / 100;
                if (config.metadataBackground === 'dark') {
                    overlay.style.backgroundColor = `rgba(0, 0, 0, ${opacity})`;
                } else if (config.metadataBackground === 'light') {
                    overlay.style.backgroundColor = `rgba(255, 255, 255, ${opacity * 0.4})`;
                } else if (config.metadataBackground === 'blue') {
                    overlay.style.backgroundColor = `rgba(52, 152, 219, ${opacity})`;
                } else if (config.metadataBackground === 'green') {
                    overlay.style.backgroundColor = `rgba(52, 168, 83, ${opacity})`;
                } else if (config.metadataBackground === 'red') {
                    overlay.style.backgroundColor = `rgba(231, 76, 60, ${opacity})`;
                } else if (config.metadataBackground === 'purple') {
                    overlay.style.backgroundColor = `rgba(155, 89, 182, ${opacity})`;
                }
            }

            // Apply custom color if specified
            if (config.metadataColor) {
                overlay.style.color = config.metadataColor;
            }

            // Apply advanced styling options
            if (config.metadataBorderRadius && config.metadataBorderRadius.trim() !== '') {
                overlay.style.borderRadius = config.metadataBorderRadius;
            } else {
                overlay.style.borderRadius = ''; // Clear custom border radius
            }

            if (config.metadataPadding && config.metadataPadding.trim() !== '') {
                overlay.style.padding = config.metadataPadding;
            } else {
                overlay.style.padding = ''; // Clear custom padding
            }

            if (config.metadataShadow && config.metadataShadow.trim() !== '') {
                overlay.style.boxShadow = config.metadataShadow;
            } else {
                overlay.style.boxShadow = ''; // Clear custom shadow
            }
        }

        function showLoading() {
            elements.loadingIndicator.style.display = 'block';
            elements.errorMessage.style.display = 'none';
        }

        function hideLoading() {
            elements.loadingIndicator.style.display = 'none';
        }

        function showError(message = 'Failed to load photo') {
            elements.errorMessage.textContent = message;
            elements.errorMessage.style.display = 'block';
            elements.loadingIndicator.style.display = 'none';
        }

        function hideError() {
            elements.errorMessage.style.display = 'none';
        }

        function getPhotoUrl(photo, index) {
            if (photo.type === 'google') {
                return `http://localhost:${config.port || 8081}/google-photo/${encodeURIComponent(photo.url)}`;
            } else {
                return `http://localhost:${config.port || 8081}/photo/${index !== undefined ? index : photos.indexOf(photo)}`;
            }
        }

        function preloadNextPhoto(index) {
            if (photos.length === 0) return;

            const nextIndex = (index + 1) % photos.length;
            const nextPhoto = photos[nextIndex];

            if (nextPhoto) {
                elements.preloadPhoto.src = getPhotoUrl(nextPhoto, nextIndex);
            }
        }

        function showPhoto(photoData) {
            if (!photoData || !photoData.photo) {
                showError('No photo data received');
                return;
            }

            const { index, photo } = photoData;
            currentIndex = index;

            if (photos.length === 0) {
                elements.noPhotos.style.display = 'block';
                return;
            } else {
                elements.noPhotos.style.display = 'none';
            }

            hideError();

            updateSourceIndicator(photo);
            updatePhotoCounter(index, photos.length);
            updateMetadataDisplay(photo);

            const photoUrl = getPhotoUrl(photo, index);

            // Determine which photo element to use next
            const nextPhotoElement = currentPhotoElement === 1 ? 2 : 1;
            const currentPhoto = elements[`photo${currentPhotoElement}`];
            const nextPhoto = elements[`photo${nextPhotoElement}`];
            const currentBg = elements[`bg${currentPhotoElement}`];
            const nextBg = elements[`bg${nextPhotoElement}`];

            const newPhoto = new Image();

            newPhoto.onload = () => {
                // Set the source on both the foreground and background elements
                nextPhoto.src = photoUrl;
                nextBg.src = photoUrl;

                // Start transition: fade in new photo and background
                setTimeout(() => {
                    nextPhoto.classList.add('visible');
                    nextBg.classList.add('visible');
                    currentPhoto.classList.remove('visible');
                    currentBg.classList.remove('visible');
                }, 50); // Small delay to ensure src is set

                // Update which element is current after transition completes
                setTimeout(() => {
                    currentPhotoElement = nextPhotoElement;
                }, 2000); // Match transition duration

                preloadNextPhoto(index);
            };

            newPhoto.onerror = () => {
                console.error('Failed to load photo:', photoUrl);
                showError(`Failed to load: ${photo.title || 'Unknown photo'}`);

                setTimeout(() => {
                    hideError();
                }, 3000);
            };

            newPhoto.src = photoUrl;
        }

        ipcRenderer.on('slideshow-config', (event, data) => {
            console.log('Received slideshow config:', data);

            if (data.config) {
                config = data.config;

                // Clock and date configuration
                applyClock();
                applyDate();
                initializeClock();

                // Source indicator configuration
                const sourceIndicator = document.querySelector('.source-indicator');
                if (config.showSourceIndicator !== false) {
                    sourceIndicator.style.display = 'flex';
                    const sourcePos = config.sourcePosition || 'top-left';

                    // Apply proper styling via the dedicated function
                    applySourceIndicatorPosition();

                    // Set absolute positioning directly
                    sourceIndicator.style.position = 'absolute';
                    sourceIndicator.style.zIndex = '10';

                    // Clear all positioning
                    sourceIndicator.style.top = 'auto';
                    sourceIndicator.style.right = 'auto';
                    sourceIndicator.style.bottom = 'auto';
                    sourceIndicator.style.left = 'auto';

                    // Apply specific position
                    switch(sourcePos) {
                        case 'top-left':
                            sourceIndicator.style.top = '20px';
                            sourceIndicator.style.left = '20px';
                            break;
                        case 'top-right':
                            sourceIndicator.style.top = '20px';
                            sourceIndicator.style.right = '20px';
                            break;
                        case 'bottom-left':
                            sourceIndicator.style.bottom = '20px';
                            sourceIndicator.style.left = '20px';
                            break;
                        case 'bottom-right':
                            sourceIndicator.style.bottom = '20px';
                            sourceIndicator.style.right = '20px';
                            break;
                    }

                    sourceIndicator.style.opacity = config.sourceOpacity || 0.8;
                } else {
                    sourceIndicator.style.display = 'none';
                }

                // Photo counter configuration
                const photoCounter = document.querySelector('.photo-counter');
                if (config.showPhotoCounter) {
                    photoCounter.style.display = 'flex';
                    const counterPos = config.counterPosition || 'bottom-left';

                    // Apply proper styling via the dedicated function
                    applyPhotoCounterPosition();

                    // Set absolute positioning directly
                    photoCounter.style.position = 'absolute';
                    photoCounter.style.zIndex = '10';

                    // Clear all positioning
                    photoCounter.style.top = 'auto';
                    photoCounter.style.right = 'auto';
                    photoCounter.style.bottom = 'auto';
                    photoCounter.style.left = 'auto';

                    // Apply specific position
                    switch(counterPos) {
                        case 'top-left':
                            photoCounter.style.top = '20px';
                            photoCounter.style.left = '20px';
                            break;
                        case 'top-right':
                            photoCounter.style.top = '20px';
                            photoCounter.style.right = '20px';
                            break;
                        case 'bottom-left':
                            photoCounter.style.bottom = '20px';
                            photoCounter.style.left = '20px';
                            break;
                        case 'bottom-right':
                            photoCounter.style.bottom = '20px';
                            photoCounter.style.right = '20px';
                            break;
                    }

                    photoCounter.style.opacity = config.counterOpacity || 0.8;
                } else {
                    photoCounter.style.display = 'none';
                }

                // Metadata overlay configuration
                const metadataOverlay = document.querySelector('.metadata-overlay');
                if (config.showMetadata) {
                    // Update all metadata styles when config changes
                    updateMetadataStyles();
                    // Metadata visibility will be handled by updateMetadataDisplay when photos are shown
                } else {
                    metadataOverlay.style.display = 'none';
                }

                // Photo fit configuration - only update if it changed
                if (data.config.photoFit !== undefined) {
                    const photos = document.querySelectorAll('.photo');
                    photos.forEach(photo => {
                        // Preserve the visible state when updating photo fit
                        const wasVisible = photo.classList.contains('visible');
                        photo.className = `photo fit-${config.photoFit || 'contain'}`;
                        if (wasVisible) {
                            photo.classList.add('visible');
                        }
                    });
                }

                // Apply transition type - only update if it changed
                if (data.config.transitionType !== undefined) {
                    const container = document.querySelector('.slideshow-container');
                    container.className = `slideshow-container transition-${config.transitionType || 'fade'}`;
                }
            }

            if (data.photos) {
                photos = data.photos;
                updatePhotoCounter(currentIndex, photos.length);

                if (photos.length === 0) {
                    elements.noPhotos.style.display = 'block';
                }
            }
        });

        ipcRenderer.on('show-photo', (event, photoData) => {
            showPhoto(photoData);
        });

        // Delay before enabling activity detection to prevent false triggers
        let activityDetectionEnabled = false;
        setTimeout(() => {
            activityDetectionEnabled = true;
            console.log('Activity detection enabled');
        }, 1000); // Wait 1 second before enabling

        // Aggressive event capture for VNC and remote clicks
        const triggerUserActivity = () => {
            if (activityDetectionEnabled) {
                console.log('User activity detected in slideshow');
                ipcRenderer.send('slideshow-user-activity');
            }
        };

        // Capture clicks on all elements
        document.addEventListener('click', triggerUserActivity, true);
        document.addEventListener('mousedown', triggerUserActivity, true);
        document.addEventListener('mouseup', triggerUserActivity, true);

        document.addEventListener('keydown', triggerUserActivity);

        // Throttled mousemove to prevent too many events
        let mouseMoveTimeout;
        let lastMouseX = 0;
        let lastMouseY = 0;
        document.addEventListener('mousemove', (e) => {
            // Only trigger on significant mouse movement
            const deltaX = Math.abs(e.clientX - lastMouseX);
            const deltaY = Math.abs(e.clientY - lastMouseY);

            if (deltaX > 10 || deltaY > 10) {
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;

                if (!mouseMoveTimeout) {
                    mouseMoveTimeout = setTimeout(() => {
                        triggerUserActivity();
                        mouseMoveTimeout = null;
                    }, 100);
                }
            }
        });

        document.addEventListener('touchstart', triggerUserActivity);

        // Also detect clicks on the slideshow container specifically
        document.querySelector('.slideshow-container').addEventListener('click', triggerUserActivity, true);

        window.addEventListener('beforeunload', () => {
            if (clockInterval) {
                clearInterval(clockInterval);
            }
        });

        // Create function to apply source indicator styling
        function applySourceIndicatorPosition() {
            const sourceIndicator = document.querySelector('.source-indicator');
            if (config.showSourceIndicator && sourceIndicator) {
                sourceIndicator.style.display = 'flex';
                const sourcePos = config.sourcePosition || 'top-left';
                const sourceBackground = config.sourceBackground || 'dark';

                // Apply classes for background only (no size/font-size classes needed)
                sourceIndicator.className = `source-indicator background-${sourceBackground}`;

                // Apply custom font size if specified
                if (config.sourceCustomFontSize && config.sourceCustomFontSize.trim() !== '') {
                    sourceIndicator.style.fontSize = config.sourceCustomFontSize;
                } else {
                    sourceIndicator.style.fontSize = ''; // Clear custom font size
                }

                sourceIndicator.style.position = 'absolute';
                sourceIndicator.style.zIndex = '10';
                sourceIndicator.style.top = 'auto';
                sourceIndicator.style.right = 'auto';
                sourceIndicator.style.bottom = 'auto';
                sourceIndicator.style.left = 'auto';

                // Apply positioning
                switch(sourcePos) {
                    case 'top-left':
                        sourceIndicator.style.top = '20px';
                        sourceIndicator.style.left = '20px';
                        break;
                    case 'top-right':
                        sourceIndicator.style.top = '20px';
                        sourceIndicator.style.right = '20px';
                        break;
                    case 'bottom-left':
                        sourceIndicator.style.bottom = '20px';
                        sourceIndicator.style.left = '20px';
                        break;
                    case 'bottom-right':
                        sourceIndicator.style.bottom = '20px';
                        sourceIndicator.style.right = '20px';
                        break;
                }

                // Apply custom color if specified
                if (config.sourceColor) {
                    sourceIndicator.style.color = config.sourceColor;
                }

                // Apply background opacity if background is not 'none'
                if (sourceBackground !== 'none' && config.sourceBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(sourceIndicator).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.sourceBackgroundOpacity / 100;
                            sourceIndicator.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                sourceIndicator.style.opacity = config.sourceOpacity || 0.8;

                // Apply advanced styling options
                if (config.sourceBorderRadius && config.sourceBorderRadius.trim() !== '') {
                    sourceIndicator.style.borderRadius = config.sourceBorderRadius;
                } else {
                    sourceIndicator.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.sourcePadding && config.sourcePadding.trim() !== '') {
                    sourceIndicator.style.padding = config.sourcePadding;
                } else {
                    sourceIndicator.style.padding = ''; // Clear custom padding
                }

                if (config.sourceShadow && config.sourceShadow.trim() !== '') {
                    sourceIndicator.style.boxShadow = config.sourceShadow;
                } else {
                    sourceIndicator.style.boxShadow = ''; // Clear custom shadow
                }
            } else if (sourceIndicator) {
                sourceIndicator.style.display = 'none';
            }
        }

        // Create function to apply clock styling
        function applyClock() {
            const clock = elements.clock;
            if (config.showClock && clock) {
                clock.style.display = 'block';
                const clockPos = config.clockPosition || 'bottom-right';
                const clockBackground = config.clockBackground || 'dark';
                const clockFontSize = config.clockFontSize || 'medium';

                // Apply classes for background and font size (if no custom size)
                if (config.clockCustomFontSize) {
                    clock.className = `clock background-${clockBackground} pos-${clockPos}`;
                    clock.style.fontSize = config.clockCustomFontSize;
                } else {
                    clock.className = `clock background-${clockBackground} font-size-${clockFontSize} pos-${clockPos}`;
                }

                // Apply positioning directly
                clock.style.position = 'absolute';
                clock.style.zIndex = '10';
                clock.style.top = 'auto';
                clock.style.right = 'auto';
                clock.style.bottom = 'auto';
                clock.style.left = 'auto';

                // Apply specific position
                switch(clockPos) {
                    case 'top-left':
                        clock.style.top = '20px';
                        clock.style.left = '20px';
                        break;
                    case 'top-right':
                        clock.style.top = '20px';
                        clock.style.right = '20px';
                        break;
                    case 'bottom-left':
                        clock.style.bottom = '20px';
                        clock.style.left = '20px';
                        break;
                    case 'bottom-right':
                        clock.style.bottom = '20px';
                        clock.style.right = '20px';
                        break;
                    case 'center':
                        clock.style.top = '50%';
                        clock.style.left = '50%';
                        clock.style.transform = 'translate(-50%, -50%)';
                        break;
                }

                // Apply custom color if specified
                if (config.clockColor) {
                    clock.style.color = config.clockColor;
                }

                // Apply background opacity if background is not 'none'
                if (clockBackground !== 'none' && config.clockBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(clock).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.clockBackgroundOpacity / 100;
                            clock.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                clock.style.opacity = config.clockOpacity || 1.0;

                // Apply advanced styling options
                if (config.clockBorderRadius && config.clockBorderRadius.trim() !== '') {
                    clock.style.borderRadius = config.clockBorderRadius;
                } else {
                    clock.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.clockPadding && config.clockPadding.trim() !== '') {
                    clock.style.padding = config.clockPadding;
                } else {
                    clock.style.padding = ''; // Clear custom padding
                }

                if (config.clockShadow && config.clockShadow.trim() !== '') {
                    clock.style.boxShadow = config.clockShadow;
                } else {
                    clock.style.boxShadow = ''; // Clear custom shadow
                }
            } else if (clock) {
                clock.style.display = 'none';
            }
        }

        // Create function to apply date styling
        function applyDate() {
            const date = elements.date;
            if (config.showDate !== false && date) {
                date.style.display = 'block';
                const datePos = config.datePosition || 'bottom-left';
                const dateBackground = config.dateBackground || 'dark';
                const dateFontSize = config.dateFontSize || 'medium';

                // Apply classes for background and position only
                if (config.dateCustomFontSize && config.dateCustomFontSize.trim() !== '') {
                    date.className = `date background-${dateBackground} pos-${datePos}`;
                    date.style.fontSize = config.dateCustomFontSize;
                } else {
                    date.className = `date background-${dateBackground} pos-${datePos}`;
                    date.style.fontSize = ''; // Clear custom font size
                }

                // Apply positioning directly
                date.style.position = 'absolute';
                date.style.zIndex = '10';
                date.style.top = 'auto';
                date.style.right = 'auto';
                date.style.bottom = 'auto';
                date.style.left = 'auto';

                // Apply specific position
                switch(datePos) {
                    case 'top-left':
                        date.style.top = '20px';
                        date.style.left = '20px';
                        break;
                    case 'top-right':
                        date.style.top = '20px';
                        date.style.right = '20px';
                        break;
                    case 'bottom-left':
                        date.style.bottom = '20px';
                        date.style.left = '20px';
                        break;
                    case 'bottom-right':
                        date.style.bottom = '20px';
                        date.style.right = '20px';
                        break;
                    case 'center':
                        date.style.top = '50%';
                        date.style.left = '50%';
                        date.style.transform = 'translate(-50%, -50%)';
                        break;
                }

                // Apply custom color if specified
                if (config.dateColor) {
                    date.style.color = config.dateColor;
                }

                // Apply background opacity if background is not 'none'
                if (dateBackground !== 'none' && config.dateBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(date).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.dateBackgroundOpacity / 100;
                            date.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                date.style.opacity = config.dateOpacity || 0.8;

                // Apply advanced styling options
                if (config.dateBorderRadius && config.dateBorderRadius.trim() !== '') {
                    date.style.borderRadius = config.dateBorderRadius;
                } else {
                    date.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.datePadding && config.datePadding.trim() !== '') {
                    date.style.padding = config.datePadding;
                } else {
                    date.style.padding = ''; // Clear custom padding
                }

                if (config.dateShadow && config.dateShadow.trim() !== '') {
                    date.style.boxShadow = config.dateShadow;
                } else {
                    date.style.boxShadow = ''; // Clear custom shadow
                }
            } else if (date) {
                date.style.display = 'none';
            }
        }

        // Create function to apply photo counter styling
        function applyPhotoCounterPosition() {
            const photoCounter = document.querySelector('.photo-counter');
            if (config.showPhotoCounter && photoCounter) {
                photoCounter.style.display = 'flex';
                const counterPos = config.counterPosition || 'bottom-left';
                const counterBackground = config.counterBackground || 'dark';

                // Apply classes for background only (no size/font-size classes needed)
                photoCounter.className = `photo-counter background-${counterBackground}`;

                // Apply custom font size if specified
                if (config.counterCustomFontSize && config.counterCustomFontSize.trim() !== '') {
                    photoCounter.style.fontSize = config.counterCustomFontSize;
                } else {
                    photoCounter.style.fontSize = ''; // Clear custom font size
                }

                photoCounter.style.position = 'absolute';
                photoCounter.style.zIndex = '10';
                photoCounter.style.top = 'auto';
                photoCounter.style.right = 'auto';
                photoCounter.style.bottom = 'auto';
                photoCounter.style.left = 'auto';

                // Apply positioning
                switch(counterPos) {
                    case 'top-left':
                        photoCounter.style.top = '20px';
                        photoCounter.style.left = '20px';
                        break;
                    case 'top-right':
                        photoCounter.style.top = '20px';
                        photoCounter.style.right = '20px';
                        break;
                    case 'bottom-left':
                        photoCounter.style.bottom = '20px';
                        photoCounter.style.left = '20px';
                        break;
                    case 'bottom-right':
                        photoCounter.style.bottom = '20px';
                        photoCounter.style.right = '20px';
                        break;
                }

                // Apply custom color if specified
                if (config.counterColor) {
                    photoCounter.style.color = config.counterColor;
                }

                // Apply background opacity if background is not 'none'
                if (counterBackground !== 'none' && config.counterBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(photoCounter).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.counterBackgroundOpacity / 100;
                            photoCounter.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                photoCounter.style.opacity = config.counterOpacity || 0.8;

                // Apply advanced styling options
                if (config.counterBorderRadius && config.counterBorderRadius.trim() !== '') {
                    photoCounter.style.borderRadius = config.counterBorderRadius;
                } else {
                    photoCounter.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.counterPadding && config.counterPadding.trim() !== '') {
                    photoCounter.style.padding = config.counterPadding;
                } else {
                    photoCounter.style.padding = ''; // Clear custom padding
                }

                if (config.counterShadow && config.counterShadow.trim() !== '') {
                    photoCounter.style.boxShadow = config.counterShadow;
                } else {
                    photoCounter.style.boxShadow = ''; // Clear custom shadow
                }
            } else if (photoCounter) {
                photoCounter.style.display = 'none';
            }
        }

        // Expose updateConfig function for backend communication
        window.updateConfig = function(newConfig) {
            // Merge new config with existing config
            Object.assign(config, newConfig);

            // Re-apply source indicator styling if any source option changed
            if (currentPhotoIndex !== -1 && (newConfig.sourcePosition || newConfig.sourceBackground ||
                newConfig.sourceColor || newConfig.sourceFontSize || newConfig.sourceBackgroundOpacity || newConfig.sourceSize || newConfig.sourceOpacity || newConfig.sourceBorderRadius || newConfig.sourcePadding || newConfig.sourceShadow)) {
                applySourceIndicatorPosition();
            }

            // Re-apply counter styling if any counter option changed
            if (currentPhotoIndex !== -1 && (newConfig.counterPosition || newConfig.counterBackground ||
                newConfig.counterColor || newConfig.counterFontSize || newConfig.counterBackgroundOpacity || newConfig.counterSize || newConfig.counterOpacity || newConfig.counterBorderRadius || newConfig.counterPadding || newConfig.counterShadow)) {
                applyPhotoCounterPosition();
            }

            // Re-apply clock styling if any clock option changed
            if (newConfig.clockFontSize || newConfig.clockCustomFontSize || newConfig.clockColor || newConfig.clockBackground || newConfig.clockOpacity || newConfig.clockPosition || newConfig.clockBackgroundOpacity || newConfig.clockBorderRadius || newConfig.clockPadding || newConfig.clockShadow || newConfig.showClock !== undefined) {
                applyClock();
            }

            // Re-apply date styling if any date option changed
            if (newConfig.dateFontSize || newConfig.dateCustomFontSize || newConfig.dateColor || newConfig.dateBackground || newConfig.dateSize || newConfig.dateOpacity || newConfig.datePosition || newConfig.dateBackgroundOpacity || newConfig.dateBorderRadius || newConfig.datePadding || newConfig.dateShadow || newConfig.showDate !== undefined) {
                applyDate();
            }

            // Re-apply metadata styling if any metadata option changed
            if (newConfig.metadataColor || newConfig.metadataBackground || newConfig.metadataFontSize || newConfig.metadataBackgroundOpacity || newConfig.metadataBorderRadius || newConfig.metadataPadding || newConfig.metadataShadow) {
                if (currentPhotoIndex !== -1) {
                    updateMetadataOverlay();
                }
            }
        };

        console.log('Slideshow HTML loaded and ready');
    </script>
</body>
</html>