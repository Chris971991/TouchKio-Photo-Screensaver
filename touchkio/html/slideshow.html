<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TouchKio Slideshow</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            cursor: none;
            user-select: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .slideshow-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
            background: transparent;
            transition: background-color 0.3s ease-in-out;
            /* GPU acceleration */
            contain: strict;
            isolation: isolate;
            will-change: background-color;
            transform: translateZ(0);
        }

        .slideshow-container.transitioning {
            background: rgba(0, 0, 0, 0.95); /* Semi-transparent black only during photo transitions */
        }

        .photo-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            /* GPU acceleration */
            will-change: transform, opacity;
            transform: translateZ(0);
            contain: layout style paint;
        }

        .photo-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: blur(20px) brightness(0.3);
            transform: scale(1.1);
            opacity: 0;
            transition: opacity 2s ease-in-out;
            /* GPU acceleration */
            will-change: opacity, filter, transform;
            backface-visibility: hidden;
            transform-style: preserve-3d;
        }

        .photo {
            position: absolute;
            opacity: 0;
            transform: scale(1);
            filter: blur(0px);
            transition: all 2s ease-in-out;
            z-index: 1;
            /* GPU acceleration */
            will-change: transform, opacity, filter;
            backface-visibility: hidden;
            transform-style: preserve-3d;
        }

        .photo.fit-contain {
            /* Smart contain: fill viewport height for square/landscape, width for portrait */
            width: auto;
            height: 100vh;
            max-width: 100vw;
            object-fit: contain;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .photo.fit-contain-original {
            /* Original contain behavior */
            max-width: 100vw;
            max-height: 100vh;
            width: auto;
            height: auto;
            object-fit: contain;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .photo.fit-cover {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .photo.fit-fill {
            width: 100%;
            height: 100%;
            object-fit: fill;
        }

        /* Removed orientation-specific fit modes - smart contain handles all cases */

        .photo.visible {
            opacity: 1;
        }

        .photo-background.visible {
            opacity: 1;
        }

        .photo.loading {
            opacity: 0.3;
        }

        /* Fade transition */
        .transition-fade .photo {
            transition: opacity 2s ease-in-out;
        }

        /* Slide transition */
        .transition-slide .photo {
            transform: translateX(100%);
            transition: transform 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-slide .photo.visible {
            transform: translateX(0);
        }

        /* Zoom transition */
        .transition-zoom .photo {
            transform: scale(0.8);
            transition: transform 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-zoom .photo.visible {
            transform: scale(1);
        }

        /* Blur transition */
        .transition-blur .photo {
            filter: blur(10px);
            transition: filter 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-blur .photo.visible {
            filter: blur(0px);
        }

        /* Rotate transition */
        .transition-rotate .photo {
            transform: rotate(-10deg) scale(0.9);
            transition: transform 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-rotate .photo.visible {
            transform: rotate(0deg) scale(1);
        }

        .overlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0px;
            line-height: 0.9;
            z-index: 10;
        }

        .overlay.pos-center {
            align-items: center;
        }

        .overlay.pos-top-left,
        .overlay.pos-bottom-left {
            align-items: flex-start;
        }

        .overlay.background-dark {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
        }

        .overlay.background-light {
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .overlay.background-none {
            background: none;
            backdrop-filter: none !important;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* Position classes */
        .pos-top-left { top: 20px; left: 20px; right: auto; bottom: auto; }
        .pos-top-right { top: 20px; right: 20px; left: auto; bottom: auto; }
        .pos-bottom-left { bottom: 20px; left: 20px; right: auto; top: auto; }
        .pos-bottom-right { bottom: 20px; right: 20px; left: auto; top: auto; }
        .pos-center {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            right: auto;
            bottom: auto;
        }


        .date.size-tiny { font-size: 0.6rem !important; }
        .date.size-small { font-size: 0.8rem !important; }
        .date.size-medium { font-size: 1rem !important; }
        .date.size-large { font-size: 1.2rem !important; }
        .date.size-xlarge { font-size: 1.6rem !important; }
        .date.size-xxlarge { font-size: 2.2rem !important; }
        .date.size-massive { font-size: 3rem !important; }
        .date.size-giant { font-size: 4rem !important; }

        /* Size classes for indicators */
        .size-small {
            padding: 8px 12px;
            font-size: 0.7rem;
        }
        .size-medium {
            padding: 10px 15px;
            font-size: 0.8rem;
        }
        .size-large {
            padding: 12px 18px;
            font-size: 0.9rem;
        }

        .clock {
            position: absolute;
            font-weight: 300;
            letter-spacing: 2px;
            line-height: 1;
            margin: 0;
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        .date {
            position: absolute;
            opacity: 0.8;
            line-height: 1;
            margin: 0;
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        .source-indicator {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
            /* NO default position - will be set by pos- classes */
        }

        .source-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        .source-icon.google {
            background: #4285f4;
        }

        .source-icon.local {
            background: #34a853;
        }

        .photo-counter {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
            /* NO default position - will be set by pos- classes */
        }

        /* Photo counter positioning - uses general .pos- classes */

        /* Source indicator size classes */
        .source-indicator.size-small {
            font-size: 0.7rem !important;
            padding: 8px 12px !important;
        }
        .source-indicator.size-medium {
            font-size: 0.9rem !important;
            padding: 10px 15px !important;
        }
        .source-indicator.size-large {
            font-size: 1.1rem !important;
            padding: 12px 18px !important;
        }

        /* Photo counter size classes */
        .photo-counter.size-small {
            font-size: 0.7rem !important;
            padding: 8px 12px !important;
        }
        .photo-counter.size-medium {
            font-size: 0.9rem !important;
            padding: 10px 15px !important;
        }
        .photo-counter.size-large {
            font-size: 1.1rem !important;
            padding: 12px 18px !important;
        }

        /* Source indicator background colors */
        .source-indicator.background-dark { background: rgba(0, 0, 0, 0.7) !important; color: white; }
        .source-indicator.background-light { background: rgba(255, 255, 255, 0.8) !important; color: #333; }
        .source-indicator.background-blue { background: rgba(52, 152, 219, 0.7) !important; color: white; }
        .source-indicator.background-green { background: rgba(46, 204, 113, 0.7) !important; color: white; }
        .source-indicator.background-red { background: rgba(231, 76, 60, 0.7) !important; color: white; }
        .source-indicator.background-purple { background: rgba(155, 89, 182, 0.7) !important; color: white; }
        .source-indicator.background-none { background: transparent !important; backdrop-filter: none !important; }

        /* Photo counter background colors */
        .photo-counter.background-dark { background: rgba(0, 0, 0, 0.7) !important; color: white; }
        .photo-counter.background-light { background: rgba(255, 255, 255, 0.8) !important; color: #333; }
        .photo-counter.background-blue { background: rgba(52, 152, 219, 0.7) !important; color: white; }
        .photo-counter.background-green { background: rgba(46, 204, 113, 0.7) !important; color: white; }
        .photo-counter.background-red { background: rgba(231, 76, 60, 0.7) !important; color: white; }
        .photo-counter.background-purple { background: rgba(155, 89, 182, 0.7) !important; color: white; }
        .photo-counter.background-none { background: transparent !important; backdrop-filter: none !important; }

        /* Background classes for clock and date */
        .clock.background-dark, .date.background-dark { background: rgba(0, 0, 0, 0.7) !important; color: white; }
        .clock.background-light, .date.background-light { background: rgba(255, 255, 255, 0.8) !important; color: #333; }
        .clock.background-blue, .date.background-blue { background: rgba(52, 152, 219, 0.7) !important; color: white; }
        .clock.background-green, .date.background-green { background: rgba(46, 204, 113, 0.7) !important; color: white; }
        .clock.background-red, .date.background-red { background: rgba(231, 76, 60, 0.7) !important; color: white; }
        .clock.background-purple, .date.background-purple { background: rgba(155, 89, 182, 0.7) !important; color: white; }
        .clock.background-none, .date.background-none { background: transparent !important; backdrop-filter: none !important; }

        /* Font size classes for all elements - high specificity to override size classes */
        .clock.font-size-tiny, .date.font-size-tiny { font-size: 0.6rem !important; }
        .clock.font-size-small, .date.font-size-small { font-size: 0.8rem !important; }
        .clock.font-size-medium, .date.font-size-medium { font-size: 1.0rem !important; }
        .clock.font-size-large, .date.font-size-large { font-size: 1.2rem !important; }
        .clock.font-size-xlarge, .date.font-size-xlarge { font-size: 1.4rem !important; }
        .clock.font-size-xxlarge, .date.font-size-xxlarge { font-size: 1.6rem !important; }

        .source-indicator.font-size-tiny { font-size: 0.6rem !important; }
        .source-indicator.font-size-small { font-size: 0.8rem !important; }
        .source-indicator.font-size-medium { font-size: 1.0rem !important; }
        .source-indicator.font-size-large { font-size: 1.2rem !important; }
        .source-indicator.font-size-xlarge { font-size: 1.4rem !important; }
        .source-indicator.font-size-xxlarge { font-size: 1.6rem !important; }

        .photo-counter.font-size-tiny { font-size: 0.6rem !important; }
        .photo-counter.font-size-small { font-size: 0.8rem !important; }
        .photo-counter.font-size-medium { font-size: 1.0rem !important; }
        .photo-counter.font-size-large { font-size: 1.2rem !important; }
        .photo-counter.font-size-xlarge { font-size: 1.4rem !important; }
        .photo-counter.font-size-xxlarge { font-size: 1.6rem !important; }

        .metadata-overlay {
            position: absolute;
            bottom: 20px;
            right: 50%;
            transform: translateX(50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.7rem;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
            text-align: center;
            max-width: 80%;
            display: none;
            transition: opacity 1s ease-in-out;
            opacity: 0;
        }

        .metadata-overlay.background-dark {
            background: rgba(0, 0, 0, 0.7);
        }

        .metadata-overlay.background-light {
            background: rgba(255, 255, 255, 0.3);
            color: #333;
        }

        .metadata-overlay.background-blue {
            background: rgba(52, 152, 219, 0.7);
            color: white;
        }

        .metadata-overlay.background-green {
            background: rgba(52, 168, 83, 0.7);
            color: white;
        }

        .metadata-overlay.background-red {
            background: rgba(231, 76, 60, 0.7);
            color: white;
        }

        .metadata-overlay.background-purple {
            background: rgba(155, 89, 182, 0.7);
            color: white;
        }

        .metadata-overlay.background-none {
            background: none !important;
            backdrop-filter: none !important;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .metadata-line {
            margin: 2px 0;
            line-height: 1.2;
        }

        .metadata-filename {
            font-weight: bold;
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .metadata-date {
            color: #ccc;
            font-size: 0.8em;
        }

        .metadata-camera {
            color: #aaa;
            font-size: 0.75em;
        }

        .metadata-exposure {
            color: #888;
            font-size: 0.7em;
            font-family: monospace;
        }

        .metadata-location {
            color: #999;
            font-size: 0.7em;
        }

        /* Metadata overlay positioning */
        .metadata-overlay.pos-top-left { top: 20px; left: 20px; right: auto; bottom: auto; transform: none; }
        .metadata-overlay.pos-top-center { top: 20px; left: 50%; right: auto; bottom: auto; transform: translateX(-50%); }
        .metadata-overlay.pos-top-right { top: 20px; right: 20px; left: auto; bottom: auto; transform: none; }
        .metadata-overlay.pos-bottom-left { bottom: 20px; left: 20px; right: auto; top: auto; transform: none; }
        .metadata-overlay.pos-bottom-center {
            bottom: 20px;
            left: 50%;
            right: auto;
            top: auto;
            transform: translateX(-50%);
        }
        .metadata-overlay.pos-bottom-right { bottom: 20px; right: 20px; left: auto; top: auto; transform: none; }
        .metadata-overlay.pos-center {
            top: 50%;
            left: 50%;
            right: auto;
            bottom: auto;
            transform: translate(-50%, -50%);
        }

        /* Font size classes for metadata */
        .metadata-overlay.font-tiny { font-size: 0.5rem !important; }
        .metadata-overlay.font-small { font-size: 0.7rem !important; }
        .metadata-overlay.font-medium { font-size: 0.9rem !important; }
        .metadata-overlay.font-large { font-size: 1.1rem !important; }
        .metadata-overlay.font-xlarge { font-size: 1.4rem !important; }
        .metadata-overlay.font-xxlarge { font-size: 1.8rem !important; }

        /* Smooth text content transitions - overlay stays in place */
        .metadata-overlay.visible {
            opacity: 1;
        }

        .metadata-overlay.transitioning {
            opacity: 0.3;
        }

        /* Individual metadata line transitions */
        .metadata-line {
            transition: opacity 1s ease-in-out, filter 1s ease-in-out;
        }

        .metadata-line.fade-out {
            opacity: 0;
        }

        .metadata-line.blur-out {
            opacity: 0;
            filter: blur(3px);
        }

        .metadata-line.slide-up-out {
            opacity: 0;
            transform: translateY(-20px);
        }

        .metadata-line.slide-down-out {
            opacity: 0;
            transform: translateY(20px);
        }

        .metadata-line.glow-out {
            opacity: 0;
            text-shadow: 0 0 15px currentColor;
        }

        .metadata-line.typewriter-out {
            opacity: 0;
            letter-spacing: 0.2em;
        }

        /* Enhanced transitions for transform effects */
        .metadata-line {
            transition: opacity 1s ease-in-out, filter 1s ease-in-out, transform 1s ease-in-out, text-shadow 1s ease-in-out, letter-spacing 1s ease-in-out;
        }

        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Elegant animation keyframes - fade with background control */
        @keyframes elegantIn {
            0% {
                opacity: 0;
                background-color: transparent;
            }
            100% {
                opacity: 1;
                background-color: transparent;
            }
        }

        @keyframes elegantOut {
            0% {
                opacity: 1;
                background-color: black;
            }
            1% {
                opacity: 1;
                background-color: transparent;
            }
            100% {
                opacity: 0;
                background-color: transparent;
            }
        }

        /* Animation classes - timing will be set dynamically */
        .animate-elegant-in {
            animation: elegantIn var(--animation-duration, 0.4s) ease-out forwards;
        }

        .animate-elegant-out {
            animation: elegantOut var(--animation-duration, 0.4s) ease-out forwards;
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.9);
            padding: 20px 30px;
            border-radius: 10px;
            font-size: 1.2rem;
            text-align: center;
            display: none;
        }

        .no-photos {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0.7;
        }

        .no-photos h2 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .no-photos p {
            font-size: 1.2rem;
        }

        .preload-container {
            position: absolute;
            top: -9999px;
            left: -9999px;
            opacity: 0;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .clock {
                font-size: 2rem;
            }

            .overlay {
                bottom: 10px;
                right: 10px;
                padding: 10px 15px;
            }

            .source-indicator,
            .photo-counter {
                padding: 8px 12px;
                font-size: 0.8rem;
                /* Removed fixed positioning - pos- classes will handle this */
            }
        }
    </style>
</head>
<body>
    <div class="slideshow-container">
        <!-- EDITOR GRID: Inside slideshow container for correct stacking context -->
        <div id="editor-grid-overlay" style="
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-size: 20px 20px;
            background-image:
                linear-gradient(rgba(255,255,255,0.3) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.3) 1px, transparent 1px);
            pointer-events: none;
            z-index: 5;
            display: none;
        "></div>
        <div class="photo-container">
            <img id="bg1" class="photo-background" alt="Background 1">
            <img id="bg2" class="photo-background" alt="Background 2">
            <img id="photo1" class="photo" alt="Slideshow Photo 1">
            <img id="photo2" class="photo" alt="Slideshow Photo 2">
            <div class="preload-container">
                <img id="preloadPhoto" alt="Preload Photo">
            </div>
        </div>

        <div class="source-indicator pos-top-left size-medium">
            <div class="source-icon" id="sourceIcon"></div>
            <span id="sourceText">Local Photos</span>
        </div>

        <div class="photo-counter pos-bottom-left size-medium">
            <span id="photoCounter">0 / 0</span>
        </div>

        <div class="metadata-overlay" id="metadataOverlay">
            <div class="metadata-line metadata-filename" id="metadataFilename"></div>
            <div class="metadata-line metadata-date" id="metadataDate"></div>
            <div class="metadata-line metadata-camera" id="metadataCamera"></div>
            <div class="metadata-line metadata-exposure" id="metadataExposure"></div>
            <div class="metadata-line metadata-location" id="metadataLocation"></div>
        </div>

        <div class="clock pos-bottom-right size-large background-dark" id="clock">00:00</div>
        <div class="date pos-bottom-left size-medium background-dark" id="date">Loading...</div>

        <div class="loading-indicator" id="loadingIndicator">
            <div class="spinner"></div>
        </div>

        <div class="error-message" id="errorMessage">
            Failed to load photo
        </div>

        <div class="no-photos" id="noPhotos" style="display: none;">
            <h2>No Photos Available</h2>
            <p>Add photos to your Pictures folder or configure Google Photos</p>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');

        let config = {};
        let photos = [];
        let currentIndex = 0;
        let clockInterval = null;
        let currentPhotoElement = 1; // Track which photo element is currently visible

        const elements = {
            bg1: document.getElementById('bg1'),
            bg2: document.getElementById('bg2'),
            photo1: document.getElementById('photo1'),
            photo2: document.getElementById('photo2'),
            preloadPhoto: document.getElementById('preloadPhoto'),
            sourceIcon: document.getElementById('sourceIcon'),
            sourceText: document.getElementById('sourceText'),
            photoCounter: document.getElementById('photoCounter'),
            metadataOverlay: document.getElementById('metadataOverlay'),
            metadataFilename: document.getElementById('metadataFilename'),
            metadataDate: document.getElementById('metadataDate'),
            metadataCamera: document.getElementById('metadataCamera'),
            metadataExposure: document.getElementById('metadataExposure'),
            metadataLocation: document.getElementById('metadataLocation'),
            clock: document.getElementById('clock'),
            date: document.getElementById('date'),
            loadingIndicator: document.getElementById('loadingIndicator'),
            errorMessage: document.getElementById('errorMessage'),
            noPhotos: document.getElementById('noPhotos')
        };

        function initializeClock() {
            if (clockInterval) {
                clearInterval(clockInterval);
            }

            function updateClock() {
                const now = new Date();
                const timeString = now.toLocaleTimeString([], {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
                const dateString = now.toLocaleDateString([], {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });

                elements.clock.textContent = timeString;
                elements.date.textContent = dateString;
            }

            updateClock();
            // Use animation controller instead of setInterval
            if (window.animationController) {
                window.animationController.scheduleInterval(updateClock, 1000, 'clock_update');
            }
        }

        function updateSourceIndicator(photo) {
            if (photo.type === 'google') {
                elements.sourceIcon.className = 'source-icon google';
                elements.sourceText.textContent = 'Google Photos';
            } else {
                elements.sourceIcon.className = 'source-icon local';
                elements.sourceText.textContent = 'Local Photos';
            }
        }

        function updatePhotoCounter(current, total) {
            elements.photoCounter.textContent = `${current + 1} / ${total}`;
        }

        function updateMetadataDisplay(photo) {
            // Use smooth content transition for photo changes
            transitionMetadataContent(photo);
        }

        function showMetadataOverlay() {
            updateMetadataStyles();
            elements.metadataOverlay.style.display = 'block';
            // Force reflow before adding visible class
            elements.metadataOverlay.offsetHeight;
            elements.metadataOverlay.classList.add('visible');
        }

        function hideMetadataOverlay() {
            elements.metadataOverlay.classList.remove('visible');
            const transitionDuration = config.transitionDuration || 2000;
            setTimeout(() => {
                elements.metadataOverlay.style.display = 'none';
            }, transitionDuration / 2); // Match half transition duration
        }

        function transitionMetadataContent(newPhoto) {
            if (!config.showMetadata || !newPhoto.metadata) {
                hideMetadataOverlay();
                return;
            }

            const transitionType = config.metadataTransitionType || 'fade';
            const transitionDuration = config.transitionDuration || 2000; // Get slideshow transition duration
            const halfDuration = transitionDuration / 2;
            const metadataLines = elements.metadataOverlay.querySelectorAll('.metadata-line');

            // Update CSS transition duration to match slideshow
            metadataLines.forEach(line => {
                line.style.transition = `opacity ${halfDuration}ms ease-in-out, filter ${halfDuration}ms ease-in-out, transform ${halfDuration}ms ease-in-out, text-shadow ${halfDuration}ms ease-in-out, letter-spacing ${halfDuration}ms ease-in-out`;
            });

            // Start transition - apply appropriate out effect
            const outClass = `${transitionType}-out`;
            metadataLines.forEach(line => line.classList.add(outClass));

            // After fade out, update content and fade in
            setTimeout(() => {
                updateMetadataContent(newPhoto);

                // Fade in new content
                setTimeout(() => {
                    metadataLines.forEach(line => {
                        line.classList.remove('fade-out', 'blur-out', 'slide-up-out', 'slide-down-out', 'glow-out', 'typewriter-out');
                    });
                }, 50);
            }, halfDuration);
        }

        function updateMetadataContent(photo) {
            const metadata = photo.metadata;
            let hasContent = false;

            // Clear all fields first
            elements.metadataFilename.textContent = '';
            elements.metadataDate.textContent = '';
            elements.metadataCamera.textContent = '';
            elements.metadataExposure.textContent = '';
            elements.metadataLocation.textContent = '';

            // Show/hide filename
            if (config.showFilename && metadata.filename) {
                elements.metadataFilename.textContent = metadata.filename;
                elements.metadataFilename.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataFilename.style.display = 'none';
            }

            // Show/hide date taken
            if (config.showDateTaken && metadata.dateFormatted) {
                elements.metadataDate.textContent = metadata.dateFormatted;
                elements.metadataDate.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataDate.style.display = 'none';
            }

            // Show/hide camera info
            if (config.showCameraInfo && metadata.camera) {
                let cameraText = metadata.camera;
                if (metadata.lens) {
                    cameraText += ` • ${metadata.lens}`;
                }
                elements.metadataCamera.textContent = cameraText;
                elements.metadataCamera.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataCamera.style.display = 'none';
            }

            // Show/hide exposure settings
            if (config.showCameraInfo && metadata.exposure) {
                elements.metadataExposure.textContent = metadata.exposure;
                elements.metadataExposure.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataExposure.style.display = 'none';
            }

            // Show/hide location (GPS coordinates)
            if (config.showLocation && metadata.location) {
                elements.metadataLocation.textContent = `📍 ${metadata.location.formatted}`;
                elements.metadataLocation.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataLocation.style.display = 'none';
            }

            // Show/hide entire overlay based on content
            if (hasContent) {
                if (elements.metadataOverlay.style.display === 'none') {
                    showMetadataOverlay();
                }
            } else {
                hideMetadataOverlay();
            }
        }

        function updateMetadataStyles() {
            const overlay = elements.metadataOverlay;

            // Preserve the visible state
            const wasVisible = overlay.classList.contains('visible');

            // Clear existing classes
            overlay.className = 'metadata-overlay';

            // Check if custom coordinates are provided
            const hasCustomX = config.metadataCustomX && config.metadataCustomX.trim() !== '';
            const hasCustomY = config.metadataCustomY && config.metadataCustomY.trim() !== '';

            if (hasCustomX || hasCustomY) {
                // Use custom positioning - don't add position class, apply directly
                overlay.style.position = 'absolute';
                overlay.style.top = 'auto';
                overlay.style.right = 'auto';
                overlay.style.bottom = 'auto';
                overlay.style.left = 'auto';
                overlay.style.transform = 'none';

                if (hasCustomX) {
                    overlay.style.left = config.metadataCustomX;
                }
                if (hasCustomY) {
                    overlay.style.top = config.metadataCustomY;
                }
            } else {
                // Use preset position with CSS classes
                overlay.classList.add(`pos-${config.metadataPosition || 'bottom-center'}`);
                // Clear any custom positioning
                overlay.style.position = '';
                overlay.style.top = '';
                overlay.style.right = '';
                overlay.style.bottom = '';
                overlay.style.left = '';
                overlay.style.transform = '';
            }

            // Apply background
            overlay.classList.add(`background-${config.metadataBackground || 'dark'}`);

            // Apply custom font size if specified
            if (config.metadataCustomFontSize && config.metadataCustomFontSize.trim() !== '') {
                overlay.style.fontSize = config.metadataCustomFontSize;
            } else {
                overlay.style.fontSize = ''; // Clear custom font size
            }

            // Restore visible state if it was visible
            if (wasVisible) {
                overlay.classList.add('visible');
            }

            // Apply custom opacity if set
            if (config.metadataBackgroundOpacity !== undefined) {
                const opacity = config.metadataBackgroundOpacity / 100;
                if (config.metadataBackground === 'dark') {
                    overlay.style.backgroundColor = `rgba(0, 0, 0, ${opacity})`;
                } else if (config.metadataBackground === 'light') {
                    overlay.style.backgroundColor = `rgba(255, 255, 255, ${opacity * 0.4})`;
                } else if (config.metadataBackground === 'blue') {
                    overlay.style.backgroundColor = `rgba(52, 152, 219, ${opacity})`;
                } else if (config.metadataBackground === 'green') {
                    overlay.style.backgroundColor = `rgba(52, 168, 83, ${opacity})`;
                } else if (config.metadataBackground === 'red') {
                    overlay.style.backgroundColor = `rgba(231, 76, 60, ${opacity})`;
                } else if (config.metadataBackground === 'purple') {
                    overlay.style.backgroundColor = `rgba(155, 89, 182, ${opacity})`;
                }
            }

            // Apply custom color if specified
            if (config.metadataColor) {
                overlay.style.color = config.metadataColor;
            }

            // Apply advanced styling options
            if (config.metadataBorderRadius && config.metadataBorderRadius.trim() !== '') {
                overlay.style.borderRadius = config.metadataBorderRadius;
            } else {
                overlay.style.borderRadius = ''; // Clear custom border radius
            }

            if (config.metadataPadding && config.metadataPadding.trim() !== '') {
                overlay.style.padding = config.metadataPadding;
            } else {
                overlay.style.padding = ''; // Clear custom padding
            }

            if (config.metadataShadow && config.metadataShadow.trim() !== '') {
                overlay.style.boxShadow = config.metadataShadow;
            } else {
                overlay.style.boxShadow = ''; // Clear custom shadow
            }
        }

        function showLoading() {
            elements.loadingIndicator.style.display = 'block';
            elements.errorMessage.style.display = 'none';
        }

        function hideLoading() {
            elements.loadingIndicator.style.display = 'none';
        }

        function showError(message = 'Failed to load photo') {
            elements.errorMessage.textContent = message;
            elements.errorMessage.style.display = 'block';
            elements.loadingIndicator.style.display = 'none';
        }

        function hideError() {
            elements.errorMessage.style.display = 'none';
        }

        function getPhotoUrl(photo, index) {
            if (photo.type === 'google') {
                return `http://localhost:${config.port || 8081}/google-photo/${encodeURIComponent(photo.url)}`;
            } else {
                return `http://localhost:${config.port || 8081}/photo/${index !== undefined ? index : photos.indexOf(photo)}`;
            }
        }

        function preloadNextPhoto(index) {
            if (photos.length === 0) return;

            const nextIndex = (index + 1) % photos.length;
            const nextPhoto = photos[nextIndex];

            if (nextPhoto) {
                elements.preloadPhoto.src = getPhotoUrl(nextPhoto, nextIndex);
            }
        }

        function showPhoto(photoData) {
            if (!photoData || !photoData.photo) {
                showError('No photo data received');
                return;
            }

            const { index, photo } = photoData;
            currentIndex = index;

            if (photos.length === 0) {
                elements.noPhotos.style.display = 'block';
                return;
            } else {
                elements.noPhotos.style.display = 'none';
            }

            hideError();

            updateSourceIndicator(photo);
            updatePhotoCounter(index, photos.length);
            updateMetadataDisplay(photo);

            const photoUrl = getPhotoUrl(photo, index);

            // Determine which photo element to use next
            const nextPhotoElement = currentPhotoElement === 1 ? 2 : 1;
            const currentPhoto = elements[`photo${currentPhotoElement}`];
            const nextPhoto = elements[`photo${nextPhotoElement}`];
            const currentBg = elements[`bg${currentPhotoElement}`];
            const nextBg = elements[`bg${nextPhotoElement}`];

            const newPhoto = new Image();

            // Track the preload image for memory management
            window.memoryManager.trackImage(newPhoto, `preload_${Date.now()}`);

            newPhoto.onload = () => {
                // Set the source on both the foreground and background elements
                nextPhoto.src = photoUrl;
                nextBg.src = photoUrl;

                // Track the actual display images for memory management
                window.memoryManager.trackImage(nextPhoto, `display_photo_${nextPhotoElement}`);
                window.memoryManager.trackImage(nextBg, `display_bg_${nextPhotoElement}`);

                // Add transitioning background during photo change
                const container = document.querySelector('.slideshow-container');
                container.classList.add('transitioning');

                // Start transition: fade in new photo while keeping current at full opacity
                setTimeout(() => {
                    nextPhoto.classList.add('visible');
                    nextBg.classList.add('visible');
                    // Don't fade out current photo yet - wait for transition to complete
                }, 50); // Small delay to ensure src is set

                // Get actual transition duration from config
                const transitionDuration = config.transitionDuration || 2000;

                // Track transition performance
                window.performanceMonitor.logTransition(transitionDuration);

                // Only fade out old photo after new photo is fully visible
                setTimeout(() => {
                    currentPhoto.classList.remove('visible');
                    currentBg.classList.remove('visible');
                }, transitionDuration / 2 + 50); // Halfway through transition + delay

                // Release old images from memory AFTER fade out transition completes
                setTimeout(() => {
                    window.memoryManager.releaseImage(currentPhoto);
                    window.memoryManager.releaseImage(currentBg);
                }, transitionDuration + 200); // Wait until fade out is completely done

                // Remove transitioning background after transition completes
                setTimeout(() => {
                    container.classList.remove('transitioning');
                }, transitionDuration + 100); // After full transition completes

                // Update which element is current after transition completes
                setTimeout(() => {
                    currentPhotoElement = nextPhotoElement;
                }, transitionDuration); // Match actual transition duration

                preloadNextPhoto(index);
            };

            newPhoto.onerror = () => {
                console.error('Failed to load photo:', photoUrl);
                showError(`Failed to load: ${photo.title || 'Unknown photo'}`);

                setTimeout(() => {
                    hideError();
                }, 3000);
            };

            newPhoto.src = photoUrl;
        }

        ipcRenderer.on('slideshow-config', (event, data) => {
            console.log('===== IPC MESSAGE RECEIVED =====');
            console.log('Received slideshow config:', data);
            console.log('Data type:', typeof data);
            console.log('Data keys:', Object.keys(data || {}));

            // Debug box removed - no longer needed

            if (data.config) {
                config = data.config;

                // Handle editor mode - simple immediate activation for testing
                if (config.editorMode !== undefined) {
                    console.log('Editor mode config received:', config.editorMode);

                    // Debug indicator removed - using blue notification instead

                    if (config.editorMode) {
                        // Show slideshow when editor mode is enabled
                        console.log('Making slideshow container visible for editor mode');
                        const slideshowContainer = document.querySelector('.slideshow-container');
                        if (slideshowContainer) {
                            slideshowContainer.style.display = 'flex';
                            slideshowContainer.style.visibility = 'visible';
                            slideshowContainer.style.opacity = '1';
                            console.log('Slideshow container made visible');
                        } else {
                            console.log('Slideshow container not found');
                        }

                        // Disable activity detection
                        window.activityDetectionEnabled = false;

                        // Add editor notification
                        if (!document.getElementById('editor-notification')) {
                            const notification = document.createElement('div');
                            notification.id = 'editor-notification';
                            notification.textContent = 'Editor Mode Active - Drag elements to reposition';
                            notification.style.cssText = `
                                position: fixed;
                                top: 20px;
                                left: 50%;
                                transform: translateX(-50%);
                                background: rgba(74, 144, 226, 0.9);
                                color: white;
                                padding: 12px 24px;
                                border-radius: 8px;
                                font-size: 14px;
                                font-weight: 600;
                                z-index: 10001;
                            `;
                            document.body.appendChild(notification);
                        }

                        // Show editor grid overlay
                        console.log('Showing editor grid overlay...');
                        const gridOverlay = document.getElementById('editor-grid-overlay');
                        if (gridOverlay) {
                            gridOverlay.style.display = 'block';
                            console.log('Editor grid overlay made visible');
                        } else {
                            console.log('ERROR: Editor grid overlay element not found');
                        }

                        // Show all elements
                        ['clock', 'date', 'source', 'counter', 'metadata'].forEach(id => {
                            const element = document.getElementById(id);
                            if (element) {
                                element.style.display = 'block';
                                element.style.opacity = '1';
                            }
                        });

                    } else {
                        // Deactivate editor mode - just re-enable activity detection

                        // Re-enable activity detection
                        window.activityDetectionEnabled = true;

                        // Remove editor UI
                        const notification = document.getElementById('editor-notification');
                        if (notification) notification.remove();

                        // Hide editor grid overlay
                        const gridOverlay = document.getElementById('editor-grid-overlay');
                        if (gridOverlay) {
                            gridOverlay.style.display = 'none';
                            console.log('Editor grid overlay hidden');
                        }

                        // Don't hide slideshow - just let normal activity detection handle it
                    }
                }

                // Clock and date configuration
                applyClock();
                applyDate();
                initializeClock();

                // Source indicator configuration
                const sourceIndicator = document.querySelector('.source-indicator');
                if (config.showSourceIndicator !== false) {
                    sourceIndicator.style.display = 'flex';
                    const sourcePos = config.sourcePosition || 'top-left';

                    // Apply proper styling via the dedicated function
                    applySourceIndicatorPosition();

                    // Set absolute positioning directly
                    sourceIndicator.style.position = 'absolute';
                    sourceIndicator.style.zIndex = '10';

                    // Clear all positioning
                    sourceIndicator.style.top = 'auto';
                    sourceIndicator.style.right = 'auto';
                    sourceIndicator.style.bottom = 'auto';
                    sourceIndicator.style.left = 'auto';

                    // Apply specific position
                    switch(sourcePos) {
                        case 'top-left':
                            sourceIndicator.style.top = '20px';
                            sourceIndicator.style.left = '20px';
                            break;
                        case 'top-right':
                            sourceIndicator.style.top = '20px';
                            sourceIndicator.style.right = '20px';
                            break;
                        case 'bottom-left':
                            sourceIndicator.style.bottom = '20px';
                            sourceIndicator.style.left = '20px';
                            break;
                        case 'bottom-right':
                            sourceIndicator.style.bottom = '20px';
                            sourceIndicator.style.right = '20px';
                            break;
                    }

                    sourceIndicator.style.opacity = config.sourceOpacity || 0.8;
                } else {
                    sourceIndicator.style.display = 'none';
                }

                // Photo counter configuration
                const photoCounter = document.querySelector('.photo-counter');
                if (config.showPhotoCounter) {
                    photoCounter.style.display = 'flex';
                    const counterPos = config.counterPosition || 'bottom-left';

                    // Apply proper styling via the dedicated function
                    applyPhotoCounterPosition();

                    // Set absolute positioning directly
                    photoCounter.style.position = 'absolute';
                    photoCounter.style.zIndex = '10';

                    // Clear all positioning
                    photoCounter.style.top = 'auto';
                    photoCounter.style.right = 'auto';
                    photoCounter.style.bottom = 'auto';
                    photoCounter.style.left = 'auto';

                    // Apply specific position
                    switch(counterPos) {
                        case 'top-left':
                            photoCounter.style.top = '20px';
                            photoCounter.style.left = '20px';
                            break;
                        case 'top-right':
                            photoCounter.style.top = '20px';
                            photoCounter.style.right = '20px';
                            break;
                        case 'bottom-left':
                            photoCounter.style.bottom = '20px';
                            photoCounter.style.left = '20px';
                            break;
                        case 'bottom-right':
                            photoCounter.style.bottom = '20px';
                            photoCounter.style.right = '20px';
                            break;
                    }

                    photoCounter.style.opacity = config.counterOpacity || 0.8;
                } else {
                    photoCounter.style.display = 'none';
                }

                // Metadata overlay configuration
                const metadataOverlay = document.querySelector('.metadata-overlay');
                if (config.showMetadata) {
                    // Update all metadata styles when config changes
                    updateMetadataStyles();
                    // Metadata visibility will be handled by updateMetadataDisplay when photos are shown
                } else {
                    metadataOverlay.style.display = 'none';
                }

                // Photo fit configuration - only update if it changed
                if (data.config.photoFit !== undefined) {
                    const photos = document.querySelectorAll('.photo');
                    photos.forEach(photo => {
                        // Preserve the visible state when updating photo fit
                        const wasVisible = photo.classList.contains('visible');
                        photo.className = `photo fit-${config.photoFit || 'contain'}`;
                        if (wasVisible) {
                            photo.classList.add('visible');
                        }
                    });
                }

                // Apply transition type - only update if it changed
                if (data.config.transitionType !== undefined) {
                    const container = document.querySelector('.slideshow-container');
                    container.className = `slideshow-container transition-${config.transitionType || 'fade'}`;
                }
            }

            if (data.photos) {
                photos = data.photos;
                updatePhotoCounter(currentIndex, photos.length);

                if (photos.length === 0) {
                    elements.noPhotos.style.display = 'block';
                }
            }
        });

        ipcRenderer.on('show-photo', (event, photoData) => {
            showPhoto(photoData);
        });

        // Delay before enabling activity detection to prevent false triggers
        window.activityDetectionEnabled = false;
        setTimeout(() => {
            window.activityDetectionEnabled = true;
            console.log('Activity detection enabled');
        }, 1000); // Wait 1 second before enabling

        // Aggressive event capture for VNC and remote clicks
        const triggerUserActivity = () => {
            if (window.activityDetectionEnabled) {
                console.log('User activity detected in slideshow');
                ipcRenderer.send('slideshow-user-activity');
            }
        };

        // Capture clicks on all elements
        document.addEventListener('click', triggerUserActivity, true);
        document.addEventListener('mousedown', triggerUserActivity, true);
        document.addEventListener('mouseup', triggerUserActivity, true);

        document.addEventListener('keydown', triggerUserActivity);

        // Throttled mousemove to prevent too many events
        let mouseMoveTimeout;
        let lastMouseX = 0;
        let lastMouseY = 0;
        document.addEventListener('mousemove', (e) => {
            // Only trigger on significant mouse movement
            const deltaX = Math.abs(e.clientX - lastMouseX);
            const deltaY = Math.abs(e.clientY - lastMouseY);

            if (deltaX > 10 || deltaY > 10) {
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;

                if (!mouseMoveTimeout) {
                    mouseMoveTimeout = setTimeout(() => {
                        triggerUserActivity();
                        mouseMoveTimeout = null;
                    }, 100);
                }
            }
        });

        document.addEventListener('touchstart', triggerUserActivity);

        // Also detect clicks on the slideshow container specifically
        document.querySelector('.slideshow-container').addEventListener('click', triggerUserActivity, true);

        window.addEventListener('beforeunload', () => {
            if (clockInterval) {
                clearInterval(clockInterval);
            }
        });

        // Create function to apply source indicator styling
        function applySourceIndicatorPosition() {
            const sourceIndicator = document.querySelector('.source-indicator');
            if (config.showSourceIndicator && sourceIndicator) {
                sourceIndicator.style.display = 'flex';
                const sourcePos = config.sourcePosition || 'top-left';
                const sourceBackground = config.sourceBackground || 'dark';

                // Apply classes for background only (no size/font-size classes needed)
                sourceIndicator.className = `source-indicator background-${sourceBackground}`;

                // Apply custom font size if specified
                if (config.sourceCustomFontSize && config.sourceCustomFontSize.trim() !== '') {
                    sourceIndicator.style.fontSize = config.sourceCustomFontSize;
                } else {
                    sourceIndicator.style.fontSize = ''; // Clear custom font size
                }

                sourceIndicator.style.position = 'absolute';
                sourceIndicator.style.zIndex = '10';
                sourceIndicator.style.top = 'auto';
                sourceIndicator.style.right = 'auto';
                sourceIndicator.style.bottom = 'auto';
                sourceIndicator.style.left = 'auto';
                sourceIndicator.style.transform = 'none';

                // Check if custom coordinates are provided
                const hasCustomX = config.sourceCustomX && config.sourceCustomX.trim() !== '';
                const hasCustomY = config.sourceCustomY && config.sourceCustomY.trim() !== '';

                if (hasCustomX || hasCustomY) {
                    // Use custom positioning - clear preset styles first
                    sourceIndicator.style.top = 'auto';
                    sourceIndicator.style.right = 'auto';
                    sourceIndicator.style.bottom = 'auto';
                    sourceIndicator.style.left = 'auto';
                    sourceIndicator.style.transform = 'none';

                    if (hasCustomX) {
                        sourceIndicator.style.left = config.sourceCustomX;
                    }
                    if (hasCustomY) {
                        sourceIndicator.style.top = config.sourceCustomY;
                    }
                } else {
                    // Use preset position - clear all custom positioning first
                    sourceIndicator.style.top = 'auto';
                    sourceIndicator.style.right = 'auto';
                    sourceIndicator.style.bottom = 'auto';
                    sourceIndicator.style.left = 'auto';
                    sourceIndicator.style.transform = 'none';

                    switch(sourcePos) {
                        case 'top-left':
                            sourceIndicator.style.top = '20px';
                            sourceIndicator.style.left = '20px';
                            break;
                        case 'top-right':
                            sourceIndicator.style.top = '20px';
                            sourceIndicator.style.right = '20px';
                            break;
                        case 'bottom-left':
                            sourceIndicator.style.bottom = '20px';
                            sourceIndicator.style.left = '20px';
                            break;
                        case 'bottom-right':
                            sourceIndicator.style.bottom = '20px';
                            sourceIndicator.style.right = '20px';
                            break;
                    }
                }

                // Apply custom color if specified
                if (config.sourceColor) {
                    sourceIndicator.style.color = config.sourceColor;
                }

                // Apply background opacity if background is not 'none'
                if (sourceBackground !== 'none' && config.sourceBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(sourceIndicator).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.sourceBackgroundOpacity / 100;
                            sourceIndicator.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                sourceIndicator.style.opacity = config.sourceOpacity || 0.8;

                // Apply advanced styling options
                if (config.sourceBorderRadius && config.sourceBorderRadius.trim() !== '') {
                    sourceIndicator.style.borderRadius = config.sourceBorderRadius;
                } else {
                    sourceIndicator.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.sourcePadding && config.sourcePadding.trim() !== '') {
                    sourceIndicator.style.padding = config.sourcePadding;
                } else {
                    sourceIndicator.style.padding = ''; // Clear custom padding
                }

                if (config.sourceShadow && config.sourceShadow.trim() !== '') {
                    sourceIndicator.style.boxShadow = config.sourceShadow;
                } else {
                    sourceIndicator.style.boxShadow = ''; // Clear custom shadow
                }
            } else if (sourceIndicator) {
                sourceIndicator.style.display = 'none';
            }
        }

        // Create function to apply clock styling
        function applyClock() {
            const clock = elements.clock;
            if (config.showClock && clock) {
                clock.style.display = 'block';
                const clockPos = config.clockPosition || 'bottom-right';
                const clockBackground = config.clockBackground || 'dark';
                const clockFontSize = config.clockFontSize || 'medium';

                // Apply classes for background and font size (if no custom size)
                if (config.clockCustomFontSize) {
                    clock.className = `clock background-${clockBackground} pos-${clockPos}`;
                    clock.style.fontSize = config.clockCustomFontSize;
                } else {
                    clock.className = `clock background-${clockBackground} font-size-${clockFontSize} pos-${clockPos}`;
                }

                // Apply positioning - use custom coordinates if provided, otherwise use preset positions
                clock.style.position = 'absolute';
                clock.style.zIndex = '10';
                clock.style.top = 'auto';
                clock.style.right = 'auto';
                clock.style.bottom = 'auto';
                clock.style.left = 'auto';
                clock.style.transform = 'none';

                // Check if custom coordinates are provided (handle empty strings and undefined)
                const hasCustomX = config.clockCustomX && config.clockCustomX.toString().trim() !== '';
                const hasCustomY = config.clockCustomY && config.clockCustomY.toString().trim() !== '';

                console.log('Clock positioning debug:', {
                    clockCustomX: config.clockCustomX,
                    clockCustomY: config.clockCustomY,
                    hasCustomX,
                    hasCustomY
                });

                if (hasCustomX || hasCustomY) {
                    // Use custom positioning - clear preset styles first
                    clock.style.top = 'auto';
                    clock.style.right = 'auto';
                    clock.style.bottom = 'auto';
                    clock.style.left = 'auto';
                    clock.style.transform = 'none';

                    if (hasCustomX) {
                        clock.style.left = config.clockCustomX;
                        console.log('Applied custom clock X:', config.clockCustomX);
                    }
                    if (hasCustomY) {
                        clock.style.top = config.clockCustomY;
                        console.log('Applied custom clock Y:', config.clockCustomY);
                    }
                } else {
                    // Use preset position - clear all custom positioning first
                    clock.style.top = 'auto';
                    clock.style.right = 'auto';
                    clock.style.bottom = 'auto';
                    clock.style.left = 'auto';
                    clock.style.transform = 'none';

                    switch(clockPos) {
                        case 'top-left':
                            clock.style.top = '20px';
                            clock.style.left = '20px';
                            break;
                        case 'top-right':
                            clock.style.top = '20px';
                            clock.style.right = '20px';
                            break;
                        case 'bottom-left':
                            clock.style.bottom = '20px';
                            clock.style.left = '20px';
                            break;
                        case 'bottom-right':
                            clock.style.bottom = '20px';
                            clock.style.right = '20px';
                            break;
                        case 'center':
                            clock.style.top = '50%';
                            clock.style.left = '50%';
                            clock.style.transform = 'translate(-50%, -50%)';
                            break;
                    }
                }

                // Apply custom color if specified
                if (config.clockColor) {
                    clock.style.color = config.clockColor;
                }

                // Apply background opacity if background is not 'none'
                if (clockBackground !== 'none' && config.clockBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(clock).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.clockBackgroundOpacity / 100;
                            clock.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                clock.style.opacity = config.clockOpacity || 1.0;

                // Apply advanced styling options
                if (config.clockBorderRadius && config.clockBorderRadius.trim() !== '') {
                    clock.style.borderRadius = config.clockBorderRadius;
                } else {
                    clock.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.clockPadding && config.clockPadding.trim() !== '') {
                    clock.style.padding = config.clockPadding;
                } else {
                    clock.style.padding = ''; // Clear custom padding
                }

                if (config.clockShadow && config.clockShadow.trim() !== '') {
                    clock.style.boxShadow = config.clockShadow;
                } else {
                    clock.style.boxShadow = ''; // Clear custom shadow
                }
            } else if (clock) {
                clock.style.display = 'none';
            }
        }

        // Create function to apply date styling
        function applyDate() {
            const date = elements.date;
            if (config.showDate !== false && date) {
                date.style.display = 'block';
                const datePos = config.datePosition || 'bottom-left';
                const dateBackground = config.dateBackground || 'dark';
                const dateFontSize = config.dateFontSize || 'medium';

                // Apply classes for background and position only
                if (config.dateCustomFontSize && config.dateCustomFontSize.trim() !== '') {
                    date.className = `date background-${dateBackground} pos-${datePos}`;
                    date.style.fontSize = config.dateCustomFontSize;
                } else {
                    date.className = `date background-${dateBackground} pos-${datePos}`;
                    date.style.fontSize = ''; // Clear custom font size
                }

                // Apply positioning - use custom coordinates if provided, otherwise use preset positions
                date.style.position = 'absolute';
                date.style.zIndex = '10';
                date.style.top = 'auto';
                date.style.right = 'auto';
                date.style.bottom = 'auto';
                date.style.left = 'auto';
                date.style.transform = 'none';

                // Check if custom coordinates are provided
                const hasCustomX = config.dateCustomX && config.dateCustomX.trim() !== '';
                const hasCustomY = config.dateCustomY && config.dateCustomY.trim() !== '';

                if (hasCustomX || hasCustomY) {
                    // Use custom positioning - clear preset styles first
                    date.style.top = 'auto';
                    date.style.right = 'auto';
                    date.style.bottom = 'auto';
                    date.style.left = 'auto';
                    date.style.transform = 'none';

                    if (hasCustomX) {
                        date.style.left = config.dateCustomX;
                    }
                    if (hasCustomY) {
                        date.style.top = config.dateCustomY;
                    }
                } else {
                    // Use preset position - clear all custom positioning first
                    date.style.top = 'auto';
                    date.style.right = 'auto';
                    date.style.bottom = 'auto';
                    date.style.left = 'auto';
                    date.style.transform = 'none';

                    switch(datePos) {
                        case 'top-left':
                            date.style.top = '20px';
                            date.style.left = '20px';
                            break;
                        case 'top-right':
                            date.style.top = '20px';
                            date.style.right = '20px';
                            break;
                        case 'bottom-left':
                            date.style.bottom = '20px';
                            date.style.left = '20px';
                            break;
                        case 'bottom-right':
                            date.style.bottom = '20px';
                            date.style.right = '20px';
                            break;
                        case 'center':
                            date.style.top = '50%';
                            date.style.left = '50%';
                            date.style.transform = 'translate(-50%, -50%)';
                            break;
                    }
                }

                // Apply custom color if specified
                if (config.dateColor) {
                    date.style.color = config.dateColor;
                }

                // Apply background opacity if background is not 'none'
                if (dateBackground !== 'none' && config.dateBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(date).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.dateBackgroundOpacity / 100;
                            date.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                date.style.opacity = config.dateOpacity || 0.8;

                // Apply advanced styling options
                if (config.dateBorderRadius && config.dateBorderRadius.trim() !== '') {
                    date.style.borderRadius = config.dateBorderRadius;
                } else {
                    date.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.datePadding && config.datePadding.trim() !== '') {
                    date.style.padding = config.datePadding;
                } else {
                    date.style.padding = ''; // Clear custom padding
                }

                if (config.dateShadow && config.dateShadow.trim() !== '') {
                    date.style.boxShadow = config.dateShadow;
                } else {
                    date.style.boxShadow = ''; // Clear custom shadow
                }
            } else if (date) {
                date.style.display = 'none';
            }
        }

        // Create function to apply photo counter styling
        function applyPhotoCounterPosition() {
            const photoCounter = document.querySelector('.photo-counter');
            if (config.showPhotoCounter && photoCounter) {
                photoCounter.style.display = 'flex';
                const counterPos = config.counterPosition || 'bottom-left';
                const counterBackground = config.counterBackground || 'dark';

                // Apply classes for background only (no size/font-size classes needed)
                photoCounter.className = `photo-counter background-${counterBackground}`;

                // Apply custom font size if specified
                if (config.counterCustomFontSize && config.counterCustomFontSize.trim() !== '') {
                    photoCounter.style.fontSize = config.counterCustomFontSize;
                } else {
                    photoCounter.style.fontSize = ''; // Clear custom font size
                }

                photoCounter.style.position = 'absolute';
                photoCounter.style.zIndex = '10';
                photoCounter.style.top = 'auto';
                photoCounter.style.right = 'auto';
                photoCounter.style.bottom = 'auto';
                photoCounter.style.left = 'auto';
                photoCounter.style.transform = 'none';

                // Check if custom coordinates are provided
                const hasCustomX = config.counterCustomX && config.counterCustomX.trim() !== '';
                const hasCustomY = config.counterCustomY && config.counterCustomY.trim() !== '';

                if (hasCustomX || hasCustomY) {
                    // Use custom positioning - clear preset styles first
                    photoCounter.style.top = 'auto';
                    photoCounter.style.right = 'auto';
                    photoCounter.style.bottom = 'auto';
                    photoCounter.style.left = 'auto';
                    photoCounter.style.transform = 'none';

                    if (hasCustomX) {
                        photoCounter.style.left = config.counterCustomX;
                    }
                    if (hasCustomY) {
                        photoCounter.style.top = config.counterCustomY;
                    }
                } else {
                    // Use preset position - clear all custom positioning first
                    photoCounter.style.top = 'auto';
                    photoCounter.style.right = 'auto';
                    photoCounter.style.bottom = 'auto';
                    photoCounter.style.left = 'auto';
                    photoCounter.style.transform = 'none';

                    switch(counterPos) {
                        case 'top-left':
                            photoCounter.style.top = '20px';
                            photoCounter.style.left = '20px';
                            break;
                        case 'top-right':
                            photoCounter.style.top = '20px';
                            photoCounter.style.right = '20px';
                            break;
                        case 'bottom-left':
                            photoCounter.style.bottom = '20px';
                            photoCounter.style.left = '20px';
                            break;
                        case 'bottom-right':
                            photoCounter.style.bottom = '20px';
                            photoCounter.style.right = '20px';
                            break;
                    }
                }

                // Apply custom color if specified
                if (config.counterColor) {
                    photoCounter.style.color = config.counterColor;
                }

                // Apply background opacity if background is not 'none'
                if (counterBackground !== 'none' && config.counterBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(photoCounter).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.counterBackgroundOpacity / 100;
                            photoCounter.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                photoCounter.style.opacity = config.counterOpacity || 0.8;

                // Apply advanced styling options
                if (config.counterBorderRadius && config.counterBorderRadius.trim() !== '') {
                    photoCounter.style.borderRadius = config.counterBorderRadius;
                } else {
                    photoCounter.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.counterPadding && config.counterPadding.trim() !== '') {
                    photoCounter.style.padding = config.counterPadding;
                } else {
                    photoCounter.style.padding = ''; // Clear custom padding
                }

                if (config.counterShadow && config.counterShadow.trim() !== '') {
                    photoCounter.style.boxShadow = config.counterShadow;
                } else {
                    photoCounter.style.boxShadow = ''; // Clear custom shadow
                }
            } else if (photoCounter) {
                photoCounter.style.display = 'none';
            }
        }

        // Expose updateConfig function for backend communication
        window.updateConfig = function(newConfig) {
            // Merge new config with existing config
            Object.assign(config, newConfig);

            // Re-apply source indicator styling if any source option changed
            if (currentPhotoIndex !== -1 && (newConfig.sourcePosition || newConfig.sourceBackground ||
                newConfig.sourceColor || newConfig.sourceFontSize || newConfig.sourceBackgroundOpacity || newConfig.sourceSize || newConfig.sourceOpacity || newConfig.sourceBorderRadius || newConfig.sourcePadding || newConfig.sourceShadow || newConfig.sourceCustomX || newConfig.sourceCustomY)) {
                applySourceIndicatorPosition();
            }

            // Re-apply counter styling if any counter option changed
            if (currentPhotoIndex !== -1 && (newConfig.counterPosition || newConfig.counterBackground ||
                newConfig.counterColor || newConfig.counterFontSize || newConfig.counterBackgroundOpacity || newConfig.counterSize || newConfig.counterOpacity || newConfig.counterBorderRadius || newConfig.counterPadding || newConfig.counterShadow || newConfig.counterCustomX || newConfig.counterCustomY)) {
                applyPhotoCounterPosition();
            }

            // Re-apply clock styling if any clock option changed
            if (newConfig.clockFontSize || newConfig.clockCustomFontSize || newConfig.clockColor || newConfig.clockBackground || newConfig.clockOpacity || newConfig.clockPosition || newConfig.clockBackgroundOpacity || newConfig.clockBorderRadius || newConfig.clockPadding || newConfig.clockShadow || newConfig.clockCustomX || newConfig.clockCustomY || newConfig.showClock !== undefined) {
                applyClock();
            }

            // Re-apply date styling if any date option changed
            if (newConfig.dateFontSize || newConfig.dateCustomFontSize || newConfig.dateColor || newConfig.dateBackground || newConfig.dateSize || newConfig.dateOpacity || newConfig.datePosition || newConfig.dateBackgroundOpacity || newConfig.dateBorderRadius || newConfig.datePadding || newConfig.dateShadow || newConfig.dateCustomX || newConfig.dateCustomY || newConfig.showDate !== undefined) {
                applyDate();
            }

            // Re-apply metadata styling if any metadata option changed
            if (newConfig.metadataColor || newConfig.metadataBackground || newConfig.metadataFontSize || newConfig.metadataBackgroundOpacity || newConfig.metadataBorderRadius || newConfig.metadataPadding || newConfig.metadataShadow || newConfig.metadataCustomX || newConfig.metadataCustomY) {
                if (currentPhotoIndex !== -1) {
                    updateMetadataOverlay();
                }
            }
        };

        // Listen for slideshow ready event - backend handles visibility
        ipcRenderer.on('slideshow-ready', () => {
            console.log('Slideshow content ready - backend will handle elegant animations');
        });

        // Animation functions
        function applySlideshowEntranceAnimation(duration = 400) {
            console.log('Applying elegant entrance animation with duration:', duration + 'ms');

            // Set animation duration via CSS custom property
            document.documentElement.style.setProperty('--animation-duration', duration + 'ms');

            document.body.classList.add('animate-elegant-in');
            document.body.classList.remove('animate-elegant-out');

            // Remove the animation class after it completes and ensure background stays black
            window.animationController.scheduleTimeout(() => {
                document.body.classList.remove('animate-elegant-in');
                // Ensure background is black for normal slideshow operation (hide image transitions)
                document.body.style.backgroundColor = 'black';
                console.log('Entrance animation complete - background set to black for slideshow operation');
            }, duration, 'entrance_cleanup');
        }

        function applySlideshowExitAnimation(duration = 400) {
            console.log('Applying elegant exit animation with duration:', duration + 'ms');

            // Set animation duration via CSS custom property
            document.documentElement.style.setProperty('--animation-duration', duration + 'ms');

            // Prepare for exit by making background transparent for smooth fade out
            console.log('Preparing exit animation - making background transparent for smooth fade');
            document.body.style.backgroundColor = 'transparent';

            document.body.classList.add('animate-elegant-out');
            document.body.classList.remove('animate-elegant-in');

            // Remove the animation class after it completes and ensure background stays transparent
            window.animationController.scheduleTimeout(() => {
                document.body.classList.remove('animate-elegant-out');
                // Keep background transparent after exit
                document.body.style.backgroundColor = 'transparent';
                console.log('Exit animation complete - background remains transparent');
            }, duration, 'exit_cleanup');
        }

        // Listen for animation events from backend
        ipcRenderer.on('apply-entrance-animation', (event, duration) => {
            applySlideshowEntranceAnimation(duration);
        });

        ipcRenderer.on('apply-exit-animation', (event, duration) => {
            applySlideshowExitAnimation(duration);
        });

        // Central Animation Controller - replaces scattered setTimeout calls
        class AnimationController {
            constructor() {
                this.activeAnimations = new Map();
                this.frameId = null;
                this.timers = new Map();
                this.isRunning = false;
            }

            // RequestAnimationFrame-based smooth transitions
            smoothTransition(element, property, from, to, duration, callback) {
                const id = `${element.id || 'element'}_${property}_${Date.now()}`;
                const start = performance.now();

                const animate = (now) => {
                    const progress = Math.min((now - start) / duration, 1);
                    const value = from + (to - from) * this.easeOutCubic(progress);

                    element.style[property] = typeof value === 'number' ? value + 'px' : value;

                    if (progress < 1) {
                        this.activeAnimations.set(id, requestAnimationFrame(animate));
                    } else {
                        this.activeAnimations.delete(id);
                        if (callback) callback();
                    }
                };

                this.activeAnimations.set(id, requestAnimationFrame(animate));
                return id;
            }

            // Easing function for smooth animations
            easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }

            // Replace setTimeout with coordinated timing
            scheduleTimeout(callback, delay, id = null) {
                const timerId = id || `timeout_${Date.now()}`;
                const start = performance.now();

                const checkTimer = (now) => {
                    if (now - start >= delay) {
                        this.timers.delete(timerId);
                        callback();
                    } else {
                        this.timers.set(timerId, requestAnimationFrame(checkTimer));
                    }
                };

                this.timers.set(timerId, requestAnimationFrame(checkTimer));
                return timerId;
            }

            // Replace setInterval with coordinated timing
            scheduleInterval(callback, interval, id = null) {
                const intervalId = id || `interval_${Date.now()}`;
                let lastCall = performance.now();

                const checkInterval = (now) => {
                    if (now - lastCall >= interval) {
                        lastCall = now;
                        callback();
                    }
                    this.timers.set(intervalId, requestAnimationFrame(checkInterval));
                };

                this.timers.set(intervalId, requestAnimationFrame(checkInterval));
                return intervalId;
            }

            // Clear timer
            clearTimer(id) {
                if (this.timers.has(id)) {
                    cancelAnimationFrame(this.timers.get(id));
                    this.timers.delete(id);
                }
                if (this.activeAnimations.has(id)) {
                    cancelAnimationFrame(this.activeAnimations.get(id));
                    this.activeAnimations.delete(id);
                }
            }

            // Clear all animations and timers
            clearAll() {
                this.activeAnimations.forEach(id => cancelAnimationFrame(id));
                this.timers.forEach(id => cancelAnimationFrame(id));
                this.activeAnimations.clear();
                this.timers.clear();
            }
        }

        // Memory Management System
        class MemoryManager {
            constructor() {
                this.imageReferences = new Set();
                this.maxImages = 10; // Keep only 10 images in memory
                this.memoryPressureThreshold = 150 * 1024 * 1024; // 150MB
                this.cleanupInterval = null;
                this.isMonitoring = false;
            }

            // Track image element for cleanup
            trackImage(imgElement, id = null) {
                const imageId = id || `img_${Date.now()}_${Math.random()}`;
                imgElement.dataset.memoryId = imageId;
                this.imageReferences.add({
                    id: imageId,
                    element: imgElement,
                    timestamp: Date.now()
                });

                // Auto-cleanup if we exceed max images
                if (this.imageReferences.size > this.maxImages) {
                    this.cleanupOldImages();
                }

                return imageId;
            }

            // Release specific image from memory
            releaseImage(imgElement) {
                if (!imgElement) return;

                const imageId = imgElement.dataset.memoryId;

                // Clear image source and data
                imgElement.src = '';
                imgElement.srcset = '';
                imgElement.removeAttribute('src');
                imgElement.removeAttribute('srcset');

                // Remove from tracking
                if (imageId) {
                    this.imageReferences.forEach(ref => {
                        if (ref.id === imageId) {
                            this.imageReferences.delete(ref);
                        }
                    });
                    delete imgElement.dataset.memoryId;
                }

                console.log(`Released image from memory: ${imageId || 'unknown'}`);
            }

            // Clean up oldest images when over limit
            cleanupOldImages() {
                const sortedImages = Array.from(this.imageReferences)
                    .sort((a, b) => a.timestamp - b.timestamp);

                const toRemove = sortedImages.slice(0, sortedImages.length - this.maxImages);

                toRemove.forEach(ref => {
                    this.releaseImage(ref.element);
                });

                console.log(`Cleaned up ${toRemove.length} old images from memory`);
            }

            // Force cleanup of all tracked images
            cleanupAll() {
                this.imageReferences.forEach(ref => {
                    this.releaseImage(ref.element);
                });
                this.imageReferences.clear();
                console.log('Released all tracked images from memory');
            }

            // Start memory pressure monitoring
            startMonitoring() {
                if (this.isMonitoring) return;

                this.isMonitoring = true;
                this.cleanupInterval = window.animationController.scheduleInterval(() => {
                    // Check memory usage (approximate)
                    if (performance.memory && performance.memory.usedJSHeapSize > this.memoryPressureThreshold) {
                        console.log('Memory pressure detected, triggering cleanup');
                        this.cleanupOldImages();

                        // Force garbage collection if available
                        if (window.gc) {
                            window.gc();
                        }
                    }
                }, 30000, 'memory_monitor'); // Check every 30 seconds
            }

            // Stop monitoring
            stopMonitoring() {
                if (this.cleanupInterval) {
                    window.animationController.clearTimer(this.cleanupInterval);
                    this.cleanupInterval = null;
                }
                this.isMonitoring = false;
            }

            // Get memory usage info
            getMemoryInfo() {
                const info = {
                    trackedImages: this.imageReferences.size,
                    maxImages: this.maxImages
                };

                if (performance.memory) {
                    info.heapUsed = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                    info.heapTotal = Math.round(performance.memory.totalJSHeapSize / 1024 / 1024);
                    info.heapLimit = Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024);
                }

                return info;
            }
        }

        // Global memory manager instance
        window.memoryManager = new MemoryManager();

        // Performance Monitoring Dashboard
        class PerformanceMonitor {
            constructor() {
                this.metrics = {
                    frameRate: 0,
                    frameTimes: [],
                    maxFrameTime: 16.67, // 60fps target
                    memoryUsage: 0,
                    transitionCount: 0,
                    lastTransitionTime: 0
                };
                this.isMonitoring = false;
                this.monitoringInterval = null;
                this.frameStartTime = 0;
                this.debugMode = false;
            }

            // Start performance monitoring
            startMonitoring() {
                if (this.isMonitoring) return;

                this.isMonitoring = true;
                this.frameStartTime = performance.now();

                // Monitor frame rate using requestAnimationFrame
                const measureFrameRate = () => {
                    const now = performance.now();
                    const frameTime = now - this.frameStartTime;

                    this.metrics.frameTimes.push(frameTime);

                    // Keep only last 60 frame times (1 second at 60fps)
                    if (this.metrics.frameTimes.length > 60) {
                        this.metrics.frameTimes.shift();
                    }

                    // Calculate average frame rate
                    const avgFrameTime = this.metrics.frameTimes.reduce((a, b) => a + b, 0) / this.metrics.frameTimes.length;
                    this.metrics.frameRate = Math.round(1000 / avgFrameTime);

                    this.frameStartTime = now;

                    if (this.isMonitoring) {
                        requestAnimationFrame(measureFrameRate);
                    }
                };

                requestAnimationFrame(measureFrameRate);

                // Monitor memory and other metrics every 5 seconds
                this.monitoringInterval = window.animationController.scheduleInterval(() => {
                    this.updateMetrics();
                    if (this.debugMode) {
                        this.logMetrics();
                    }
                }, 5000, 'performance_monitor');
            }

            // Stop monitoring
            stopMonitoring() {
                this.isMonitoring = false;
                if (this.monitoringInterval) {
                    window.animationController.clearTimer(this.monitoringInterval);
                    this.monitoringInterval = null;
                }
            }

            // Update performance metrics
            updateMetrics() {
                // Memory usage
                if (performance.memory) {
                    this.metrics.memoryUsage = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                }

                // Memory manager stats
                const memInfo = window.memoryManager.getMemoryInfo();
                this.metrics.trackedImages = memInfo.trackedImages;
                this.metrics.heapUsed = memInfo.heapUsed;
                this.metrics.heapTotal = memInfo.heapTotal;
            }

            // Log transition timing
            logTransition(duration) {
                this.metrics.transitionCount++;
                this.metrics.lastTransitionTime = duration;
            }

            // Get current performance metrics
            getMetrics() {
                this.updateMetrics();
                return {
                    ...this.metrics,
                    timestamp: Date.now(),
                    averageFrameTime: this.metrics.frameTimes.length > 0 ?
                        Math.round(this.metrics.frameTimes.reduce((a, b) => a + b, 0) / this.metrics.frameTimes.length * 100) / 100 : 0
                };
            }

            // Log metrics to console
            logMetrics() {
                const metrics = this.getMetrics();
                console.log('📊 Performance Metrics:', {
                    FPS: metrics.frameRate,
                    'Avg Frame Time': metrics.averageFrameTime + 'ms',
                    'Memory (MB)': metrics.memoryUsage,
                    'Tracked Images': metrics.trackedImages,
                    'Transitions': metrics.transitionCount
                });
            }

            // Enable debug mode with detailed logging
            enableDebugMode() {
                this.debugMode = true;
                console.log('🔍 Performance debug mode enabled');
            }

            // Disable debug mode
            disableDebugMode() {
                this.debugMode = false;
                console.log('🔍 Performance debug mode disabled');
            }

            // Generate performance report
            generateReport() {
                const metrics = this.getMetrics();
                const report = {
                    timestamp: new Date().toISOString(),
                    performance: {
                        targetFPS: 60,
                        currentFPS: metrics.frameRate,
                        fpsEfficiency: Math.round((metrics.frameRate / 60) * 100) + '%',
                        averageFrameTime: metrics.averageFrameTime + 'ms',
                        targetFrameTime: this.maxFrameTime + 'ms'
                    },
                    memory: {
                        currentUsage: metrics.memoryUsage + 'MB',
                        trackedImages: metrics.trackedImages,
                        heapUsed: metrics.heapUsed + 'MB',
                        heapTotal: metrics.heapTotal + 'MB'
                    },
                    activity: {
                        totalTransitions: metrics.transitionCount,
                        lastTransitionTime: metrics.lastTransitionTime + 'ms'
                    }
                };

                console.log('📈 Performance Report:', report);
                return report;
            }
        }

        // Visual Preset Editor for drag-and-drop layout design
        window.PresetEditor = class PresetEditor {
            constructor() {
                this.isActive = false;
                this.selectedElement = null;
                this.isDragging = false;
                this.dragStartPos = null;
                this.elementStartPos = null;
                this.gridSize = 10;
                this.showGrid = true;
                this.snapToGrid = true;
                this.updateDebouncer = {};

                // Bind methods
                this.handleMouseDown = this.handleMouseDown.bind(this);
                this.handleMouseMove = this.handleMouseMove.bind(this);
                this.handleMouseUp = this.handleMouseUp.bind(this);
                this.handleElementClick = this.handleElementClick.bind(this);
            }

            // Enter editor mode
            enter() {
                if (this.isActive) return;
                this.isActive = true;
                console.log('Entering preset editor mode');

                // Disable activity detection to prevent slideshow from hiding
                this.savedActivityDetection = window.activityDetectionEnabled;
                window.activityDetectionEnabled = false;
                console.log('Activity detection disabled for editor mode');

                // Pause slideshow transitions but keep it visible
                if (window.isSlideshowActive) {
                    this.wasPlaying = true;
                    // Don't call pauseSlideshow() as it might hide the slideshow
                    // Just stop the transitions
                    if (window.slideshowInterval) {
                        clearInterval(window.slideshowInterval);
                        window.slideshowInterval = null;
                    }
                } else {
                    this.wasPlaying = false;
                    // Make sure slideshow is visible
                    startSlideshow();
                }

                // Show all UI elements
                this.showAllElements();

                // Make elements interactive
                this.makeElementsInteractive();

                // Add visual helpers
                if (this.showGrid) {
                    this.addGrid();
                }

                // Add editor class to body
                document.body.classList.add('editor-mode');

                // Show editor notification
                this.showNotification('Editor Mode Active - Drag elements to reposition');
            }

            // Exit editor mode
            exit() {
                if (!this.isActive) return;
                this.isActive = false;
                console.log('Exiting preset editor mode');

                // Restore activity detection
                window.activityDetectionEnabled = this.savedActivityDetection !== undefined ? this.savedActivityDetection : true;
                console.log('Activity detection restored');

                // Remove interactive state
                this.removeElementInteractivity();

                // Remove visual helpers
                this.removeGrid();
                this.removeNotification();

                // Remove editor class
                document.body.classList.remove('editor-mode');

                // Resume slideshow if it was playing
                if (this.wasPlaying) {
                    // Restart slideshow interval
                    if (!window.slideshowInterval && window.isSlideshowActive) {
                        nextPhoto();
                        window.slideshowInterval = setInterval(nextPhoto, config.interval * 1000);
                    }
                }
            }

            // Show all UI elements for editing
            showAllElements() {
                const elements = ['clock', 'date', 'source', 'counter', 'metadata'];
                elements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.style.display = 'block';
                        element.style.opacity = '1';
                    }
                });
            }

            // Make elements interactive
            makeElementsInteractive() {
                const elements = ['clock', 'date', 'source', 'counter', 'metadata'];
                elements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.classList.add('editor-element');
                        element.addEventListener('mousedown', this.handleMouseDown);
                        element.addEventListener('click', this.handleElementClick);
                        element.style.cursor = 'move';
                    }
                });

                // Add global mouse listeners
                document.addEventListener('mousemove', this.handleMouseMove);
                document.addEventListener('mouseup', this.handleMouseUp);
            }

            // Remove element interactivity
            removeElementInteractivity() {
                const elements = ['clock', 'date', 'source', 'counter', 'metadata'];
                elements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.classList.remove('editor-element', 'selected');
                        element.removeEventListener('mousedown', this.handleMouseDown);
                        element.removeEventListener('click', this.handleElementClick);
                        element.style.cursor = 'default';
                    }
                });

                // Remove global mouse listeners
                document.removeEventListener('mousemove', this.handleMouseMove);
                document.removeEventListener('mouseup', this.handleMouseUp);
            }

            // Handle element click for selection
            handleElementClick(e) {
                e.stopPropagation();
                if (this.isDragging) return;

                // Remove previous selection
                if (this.selectedElement) {
                    this.selectedElement.classList.remove('selected');
                }

                // Select new element
                this.selectedElement = e.currentTarget;
                this.selectedElement.classList.add('selected');
                console.log(`Selected element: ${this.selectedElement.id}`);
            }

            // Handle mouse down for drag start
            handleMouseDown(e) {
                e.preventDefault();
                e.stopPropagation();

                this.isDragging = true;
                this.selectedElement = e.currentTarget;
                this.selectedElement.classList.add('dragging');

                // Store initial positions
                this.dragStartPos = { x: e.clientX, y: e.clientY };
                this.elementStartPos = {
                    x: this.selectedElement.offsetLeft,
                    y: this.selectedElement.offsetTop
                };

                console.log(`Started dragging ${this.selectedElement.id}`);
            }

            // Handle mouse move for dragging
            handleMouseMove(e) {
                if (!this.isDragging || !this.selectedElement) return;

                // Calculate new position
                let newX = this.elementStartPos.x + (e.clientX - this.dragStartPos.x);
                let newY = this.elementStartPos.y + (e.clientY - this.dragStartPos.y);

                // Apply grid snapping if enabled
                if (this.snapToGrid) {
                    newX = Math.round(newX / this.gridSize) * this.gridSize;
                    newY = Math.round(newY / this.gridSize) * this.gridSize;
                }

                // Apply boundary constraints
                newX = Math.max(0, Math.min(newX, window.innerWidth - this.selectedElement.offsetWidth));
                newY = Math.max(0, Math.min(newY, window.innerHeight - this.selectedElement.offsetHeight));

                // Apply new position
                this.selectedElement.style.left = newX + 'px';
                this.selectedElement.style.top = newY + 'px';
                this.selectedElement.style.position = 'fixed';

                // Debounced MQTT update
                this.updatePositionDebounced(this.selectedElement.id, newX, newY);
            }

            // Handle mouse up for drag end
            handleMouseUp(e) {
                if (!this.isDragging || !this.selectedElement) return;

                this.isDragging = false;
                this.selectedElement.classList.remove('dragging');

                // Send final position to MQTT
                const finalX = parseInt(this.selectedElement.style.left);
                const finalY = parseInt(this.selectedElement.style.top);
                this.updatePositionFinal(this.selectedElement.id, finalX, finalY);

                console.log(`Finished dragging ${this.selectedElement.id} to (${finalX}, ${finalY})`);
            }

            // Debounced position update for smooth dragging
            updatePositionDebounced(elementId, x, y) {
                clearTimeout(this.updateDebouncer[elementId]);
                this.updateDebouncer[elementId] = setTimeout(() => {
                    // Send position update via IPC
                    window.electronAPI?.send('slideshow-config-update', {
                        [`${elementId}CustomX`]: x + 'px',
                        [`${elementId}CustomY`]: y + 'px',
                        [`${elementId}Position`]: 'custom'
                    });
                }, 100);
            }

            // Final position update when drag ends
            updatePositionFinal(elementId, x, y) {
                clearTimeout(this.updateDebouncer[elementId]);

                // Send final position via IPC
                window.electronAPI?.send('slideshow-config-update', {
                    [`${elementId}CustomX`]: x + 'px',
                    [`${elementId}CustomY`]: y + 'px',
                    [`${elementId}Position`]: 'custom'
                });

                // Update config object
                if (window.config) {
                    window.config[`${elementId}CustomX`] = x + 'px';
                    window.config[`${elementId}CustomY`] = y + 'px';
                    window.config[`${elementId}Position`] = 'custom';
                }
            }

            // Add grid overlay
            addGrid() {
                const grid = document.createElement('div');
                grid.id = 'editor-grid';
                grid.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background-size: ${this.gridSize}px ${this.gridSize}px;
                    background-image:
                        linear-gradient(rgba(255,255,255,0.2) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(255,255,255,0.2) 1px, transparent 1px);
                    pointer-events: none;
                    z-index: 9998;
                `;

                // Add major grid lines every 50px
                const majorGrid = document.createElement('div');
                majorGrid.id = 'editor-major-grid';
                majorGrid.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background-size: 50px 50px;
                    background-image:
                        linear-gradient(rgba(74, 144, 226, 0.3) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(74, 144, 226, 0.3) 1px, transparent 1px);
                    pointer-events: none;
                    z-index: 9997;
                `;

                document.body.appendChild(majorGrid);
                document.body.appendChild(grid);
            }

            // Remove grid overlay
            removeGrid() {
                const grid = document.getElementById('editor-grid');
                const majorGrid = document.getElementById('editor-major-grid');
                if (grid) grid.remove();
                if (majorGrid) majorGrid.remove();
            }

            // Show editor notification
            showNotification(message) {
                const notification = document.createElement('div');
                notification.id = 'editor-notification';
                notification.textContent = message;
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(74, 144, 226, 0.9);
                    color: white;
                    padding: 12px 24px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 600;
                    z-index: 10001;
                    animation: slideIn 0.3s ease-out;
                `;
                document.body.appendChild(notification);
            }

            // Remove notification
            removeNotification() {
                const notification = document.getElementById('editor-notification');
                if (notification) notification.remove();
            }

            // Toggle editor mode
            toggle() {
                if (this.isActive) {
                    this.exit();
                } else {
                    this.enter();
                }
            }
        }

        // Add editor styles
        const editorStyles = document.createElement('style');
        editorStyles.textContent = `
            /* Editor Mode Styles */
            .editor-mode {
                cursor: default !important;
            }

            .editor-element {
                transition: box-shadow 0.2s, transform 0.2s;
            }

            .editor-element:hover {
                box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.8);
                transform: scale(1.02);
            }

            .editor-element.selected {
                box-shadow: 0 0 0 2px rgba(46, 204, 113, 1);
            }

            .editor-element.dragging {
                opacity: 0.8;
                transform: scale(1.05);
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                z-index: 10000 !important;
                cursor: move !important;
            }

            @keyframes slideIn {
                from {
                    opacity: 0;
                    transform: translateX(-50%) translateY(-10px);
                }
                to {
                    opacity: 1;
                    transform: translateX(-50%) translateY(0);
                }
            }
        `;
        document.head.appendChild(editorStyles);

        // Global preset editor instance
        window.presetEditor = new window.PresetEditor();

        // Create debug grid immediately when page loads
        function createDebugGrid() {
            // Remove any existing grid
            const existingGrid = document.getElementById('debug-grid');
            if (existingGrid) existingGrid.remove();

            // Create new grid
            const grid = document.createElement('div');
            grid.id = 'debug-grid';
            grid.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background-size: 50px 50px;
                background-image:
                    linear-gradient(rgba(255,0,0,0.8) 2px, transparent 2px),
                    linear-gradient(90deg, rgba(255,0,0,0.8) 2px, transparent 2px);
                pointer-events: none;
                z-index: 9998;
                display: none;
            `;
            document.body.appendChild(grid);
            console.log('Debug grid created and added to body');
            return grid;
        }

        // Create the grid immediately
        const debugGrid = createDebugGrid();

        // Function to toggle grid visibility
        window.toggleDebugGrid = function(show) {
            const grid = document.getElementById('debug-grid');
            if (grid) {
                grid.style.display = show ? 'block' : 'none';
                console.log('Debug grid toggled:', show ? 'visible' : 'hidden');
            }
        };

        // Global performance monitor instance
        window.performanceMonitor = new PerformanceMonitor();

        // Global animation controller instance
        window.animationController = new AnimationController();

        // Replace clock interval with animation controller
        if (typeof clockInterval !== 'undefined' && clockInterval) {
            clearInterval(clockInterval);
        }

        // Use animation controller for clock updates
        window.animationController.scheduleInterval(updateClock, 1000, 'clock_update');

        // Start memory monitoring
        window.memoryManager.startMonitoring();

        // Start performance monitoring
        window.performanceMonitor.startMonitoring();

        console.log('Slideshow HTML loaded with Animation Controller, Memory Manager, and Performance Monitor ready');

        // Create editor grid immediately as global element
        // Simple visible grid overlay for editor mode
        let editorGridOverlay = null;

        window.showEditorGrid = function(show) {
            if (show && !editorGridOverlay) {
                // Create bright visible grid
                editorGridOverlay = document.createElement('div');
                editorGridOverlay.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background-size: 20px 20px;
                    background-image:
                        linear-gradient(rgba(0,255,0,0.9) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(0,255,0,0.9) 1px, transparent 1px);
                    pointer-events: none;
                    z-index: 5;
                `;
                document.body.appendChild(editorGridOverlay);
                console.log('Bright green editor grid created and shown');
            } else if (!show && editorGridOverlay) {
                // Remove grid overlay
                if (editorGridOverlay.parentNode) {
                    document.body.removeChild(editorGridOverlay);
                }
                editorGridOverlay = null;
                console.log('Editor grid removed');
            }
        };

        console.log('Simple editor grid system ready');

        // TEST: Create always-visible grid to verify z-index and visibility
        const testGrid = document.createElement('div');
        testGrid.id = 'test-grid';
        testGrid.style.cssText = `
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-size: 40px 40px;
            background-image:
                linear-gradient(rgba(255,0,0,0.7) 2px, transparent 2px),
                linear-gradient(90deg, rgba(255,0,0,0.7) 2px, transparent 2px);
            pointer-events: none;
            z-index: 99999;
        `;
        document.body.appendChild(testGrid);
        console.log('TEST: Red grid overlay created with z-index 99999');
    </script>
</body>
</html>