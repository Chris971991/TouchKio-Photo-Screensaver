<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TouchKio Slideshow</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            cursor: none;
            user-select: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .slideshow-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
            background: transparent;
            transition: background-color 0.3s ease-in-out;
            /* GPU acceleration */
            contain: strict;
            isolation: isolate;
            will-change: background-color;
            transform: translateZ(0);
        }

        .slideshow-container.transitioning {
            background: rgba(0, 0, 0, 0.95); /* Semi-transparent black only during photo transitions */
        }

        .photo-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            /* GPU acceleration */
            will-change: transform, opacity;
            transform: translateZ(0);
            contain: layout style paint;
        }

        .photo-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: blur(20px) brightness(0.3);
            transform: scale(1.1);
            opacity: 0;
            transition: opacity 2s ease-in-out;
            /* GPU acceleration */
            will-change: opacity, filter, transform;
            backface-visibility: hidden;
            transform-style: preserve-3d;
        }

        .photo {
            position: absolute;
            opacity: 0;
            transform: scale(1);
            filter: blur(0px);
            transition: all 2s ease-in-out;
            z-index: 1;
            /* GPU acceleration */
            will-change: transform, opacity, filter;
            backface-visibility: hidden;
            transform-style: preserve-3d;
        }

        .photo.fit-contain {
            /* Smart contain: fill viewport height for square/landscape, width for portrait */
            width: auto;
            height: 100vh;
            max-width: 100vw;
            object-fit: contain;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .photo.fit-contain-original {
            /* Original contain behavior */
            max-width: 100vw;
            max-height: 100vh;
            width: auto;
            height: auto;
            object-fit: contain;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .photo.fit-cover {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .photo.fit-fill {
            width: 100%;
            height: 100%;
            object-fit: fill;
        }

        /* Removed orientation-specific fit modes - smart contain handles all cases */

        .photo.visible {
            opacity: 1;
        }

        .photo-background.visible {
            opacity: 1;
        }

        .photo.loading {
            opacity: 0.3;
        }

        /* Fade transition */
        .transition-fade .photo {
            transition: opacity 2s ease-in-out;
        }

        /* Slide transition */
        .transition-slide .photo {
            transform: translateX(100%);
            transition: transform 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-slide .photo.visible {
            transform: translateX(0);
        }

        /* Zoom transition */
        .transition-zoom .photo {
            transform: scale(0.8);
            transition: transform 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-zoom .photo.visible {
            transform: scale(1);
        }

        /* Blur transition */
        .transition-blur .photo {
            filter: blur(10px);
            transition: filter 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-blur .photo.visible {
            filter: blur(0px);
        }

        /* Rotate transition */
        .transition-rotate .photo {
            transform: rotate(-10deg) scale(0.9);
            transition: transform 2s ease-in-out, opacity 2s ease-in-out;
        }

        .transition-rotate .photo.visible {
            transform: rotate(0deg) scale(1);
        }

        .overlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0px;
            line-height: 0.9;
            z-index: 10;
        }

        .overlay.pos-center {
            align-items: center;
        }

        .overlay.pos-top-left,
        .overlay.pos-bottom-left {
            align-items: flex-start;
        }

        .overlay.background-dark {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
        }

        .overlay.background-light {
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .overlay.background-none {
            background: none;
            backdrop-filter: none !important;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* Position classes */
        .pos-top-left { top: 20px; left: 20px; right: auto; bottom: auto; }
        .pos-top-right { top: 20px; right: 20px; left: auto; bottom: auto; }
        .pos-bottom-left { bottom: 20px; left: 20px; right: auto; top: auto; }
        .pos-bottom-right { bottom: 20px; right: 20px; left: auto; top: auto; }
        .pos-center {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            right: auto;
            bottom: auto;
        }


        .date.size-tiny { font-size: 0.6rem !important; }
        .date.size-small { font-size: 0.8rem !important; }
        .date.size-medium { font-size: 1rem !important; }
        .date.size-large { font-size: 1.2rem !important; }
        .date.size-xlarge { font-size: 1.6rem !important; }
        .date.size-xxlarge { font-size: 2.2rem !important; }
        .date.size-massive { font-size: 3rem !important; }
        .date.size-giant { font-size: 4rem !important; }

        /* Size classes for indicators */
        .size-small {
            padding: 8px 12px;
            font-size: 0.7rem;
        }
        .size-medium {
            padding: 10px 15px;
            font-size: 0.8rem;
        }
        .size-large {
            padding: 12px 18px;
            font-size: 0.9rem;
        }

        .clock {
            position: absolute;
            font-weight: 300;
            letter-spacing: 2px;
            line-height: 1;
            margin: 0;
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        .date {
            position: absolute;
            opacity: 0.8;
            line-height: 1;
            margin: 0;
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        .source-indicator {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
            /* NO default position - will be set by pos- classes */
        }

        .source-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        .source-icon.google {
            background: #4285f4;
        }

        .source-icon.local {
            background: #34a853;
        }

        .photo-counter {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
            /* NO default position - will be set by pos- classes */
        }

        /* Photo counter positioning - uses general .pos- classes */

        /* Source indicator size classes */
        .source-indicator.size-small {
            font-size: 0.7rem !important;
            padding: 8px 12px !important;
        }
        .source-indicator.size-medium {
            font-size: 0.9rem !important;
            padding: 10px 15px !important;
        }
        .source-indicator.size-large {
            font-size: 1.1rem !important;
            padding: 12px 18px !important;
        }

        /* Photo counter size classes */
        .photo-counter.size-small {
            font-size: 0.7rem !important;
            padding: 8px 12px !important;
        }
        .photo-counter.size-medium {
            font-size: 0.9rem !important;
            padding: 10px 15px !important;
        }
        .photo-counter.size-large {
            font-size: 1.1rem !important;
            padding: 12px 18px !important;
        }

        /* Source indicator background colors */
        .source-indicator.background-dark { background: rgba(0, 0, 0, 0.7) !important; color: white; }
        .source-indicator.background-light { background: rgba(255, 255, 255, 0.8) !important; color: #333; }
        .source-indicator.background-blue { background: rgba(52, 152, 219, 0.7) !important; color: white; }
        .source-indicator.background-green { background: rgba(46, 204, 113, 0.7) !important; color: white; }
        .source-indicator.background-red { background: rgba(231, 76, 60, 0.7) !important; color: white; }
        .source-indicator.background-purple { background: rgba(155, 89, 182, 0.7) !important; color: white; }
        .source-indicator.background-none { background: transparent !important; backdrop-filter: none !important; }

        /* Photo counter background colors */
        .photo-counter.background-dark { background: rgba(0, 0, 0, 0.7) !important; color: white; }
        .photo-counter.background-light { background: rgba(255, 255, 255, 0.8) !important; color: #333; }
        .photo-counter.background-blue { background: rgba(52, 152, 219, 0.7) !important; color: white; }
        .photo-counter.background-green { background: rgba(46, 204, 113, 0.7) !important; color: white; }
        .photo-counter.background-red { background: rgba(231, 76, 60, 0.7) !important; color: white; }
        .photo-counter.background-purple { background: rgba(155, 89, 182, 0.7) !important; color: white; }
        .photo-counter.background-none { background: transparent !important; backdrop-filter: none !important; }

        /* Background classes for clock and date */
        .clock.background-dark, .date.background-dark { background: rgba(0, 0, 0, 0.7) !important; color: white; }
        .clock.background-light, .date.background-light { background: rgba(255, 255, 255, 0.8) !important; color: #333; }
        .clock.background-blue, .date.background-blue { background: rgba(52, 152, 219, 0.7) !important; color: white; }
        .clock.background-green, .date.background-green { background: rgba(46, 204, 113, 0.7) !important; color: white; }
        .clock.background-red, .date.background-red { background: rgba(231, 76, 60, 0.7) !important; color: white; }
        .clock.background-purple, .date.background-purple { background: rgba(155, 89, 182, 0.7) !important; color: white; }
        .clock.background-none, .date.background-none { background: transparent !important; backdrop-filter: none !important; }

        /* Font size classes for all elements - high specificity to override size classes */
        .clock.font-size-tiny, .date.font-size-tiny { font-size: 0.6rem !important; }
        .clock.font-size-small, .date.font-size-small { font-size: 0.8rem !important; }
        .clock.font-size-medium, .date.font-size-medium { font-size: 1.0rem !important; }
        .clock.font-size-large, .date.font-size-large { font-size: 1.2rem !important; }
        .clock.font-size-xlarge, .date.font-size-xlarge { font-size: 1.4rem !important; }
        .clock.font-size-xxlarge, .date.font-size-xxlarge { font-size: 1.6rem !important; }

        .source-indicator.font-size-tiny { font-size: 0.6rem !important; }
        .source-indicator.font-size-small { font-size: 0.8rem !important; }
        .source-indicator.font-size-medium { font-size: 1.0rem !important; }
        .source-indicator.font-size-large { font-size: 1.2rem !important; }
        .source-indicator.font-size-xlarge { font-size: 1.4rem !important; }
        .source-indicator.font-size-xxlarge { font-size: 1.6rem !important; }

        .photo-counter.font-size-tiny { font-size: 0.6rem !important; }
        .photo-counter.font-size-small { font-size: 0.8rem !important; }
        .photo-counter.font-size-medium { font-size: 1.0rem !important; }
        .photo-counter.font-size-large { font-size: 1.2rem !important; }
        .photo-counter.font-size-xlarge { font-size: 1.4rem !important; }
        .photo-counter.font-size-xxlarge { font-size: 1.6rem !important; }

        .metadata-overlay {
            position: absolute;
            bottom: 20px;
            right: 50%;
            transform: translateX(50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.7rem;
            backdrop-filter: blur(10px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
            text-align: center;
            max-width: 80%;
            display: none;
            transition: opacity 1s ease-in-out;
            opacity: 0;
        }

        .metadata-overlay.background-dark {
            background: rgba(0, 0, 0, 0.7);
        }

        .metadata-overlay.background-light {
            background: rgba(255, 255, 255, 0.3);
            color: #333;
        }

        .metadata-overlay.background-blue {
            background: rgba(52, 152, 219, 0.7);
            color: white;
        }

        .metadata-overlay.background-green {
            background: rgba(52, 168, 83, 0.7);
            color: white;
        }

        .metadata-overlay.background-red {
            background: rgba(231, 76, 60, 0.7);
            color: white;
        }

        .metadata-overlay.background-purple {
            background: rgba(155, 89, 182, 0.7);
            color: white;
        }

        .metadata-overlay.background-none {
            background: none !important;
            backdrop-filter: none !important;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .metadata-line {
            margin: 2px 0;
            line-height: 1.2;
        }

        .metadata-filename {
            font-weight: bold;
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .metadata-date {
            color: #ccc;
            font-size: 0.8em;
        }

        .metadata-camera {
            color: #aaa;
            font-size: 0.75em;
        }

        .metadata-exposure {
            color: #888;
            font-size: 0.7em;
            font-family: monospace;
        }

        .metadata-location {
            color: #999;
            font-size: 0.7em;
        }

        /* Metadata overlay positioning */
        .metadata-overlay.pos-top-left { top: 20px; left: 20px; right: auto; bottom: auto; transform: none; }
        .metadata-overlay.pos-top-center { top: 20px; left: 50%; right: auto; bottom: auto; transform: translateX(-50%); }
        .metadata-overlay.pos-top-right { top: 20px; right: 20px; left: auto; bottom: auto; transform: none; }
        .metadata-overlay.pos-bottom-left { bottom: 20px; left: 20px; right: auto; top: auto; transform: none; }
        .metadata-overlay.pos-bottom-center {
            bottom: 20px;
            left: 50%;
            right: auto;
            top: auto;
            transform: translateX(-50%);
        }
        .metadata-overlay.pos-bottom-right { bottom: 20px; right: 20px; left: auto; top: auto; transform: none; }
        .metadata-overlay.pos-left {
            top: 50%;
            left: 20px;
            right: auto;
            bottom: auto;
            transform: translateY(-50%);
        }
        .metadata-overlay.pos-center {
            top: 50%;
            left: 50%;
            right: auto;
            bottom: auto;
            transform: translate(-50%, -50%);
        }
        .metadata-overlay.pos-right {
            top: 50%;
            right: 20px;
            left: auto;
            bottom: auto;
            transform: translateY(-50%);
        }

        /* Font size classes for metadata */
        .metadata-overlay.font-tiny { font-size: 0.5rem !important; }
        .metadata-overlay.font-small { font-size: 0.7rem !important; }
        .metadata-overlay.font-medium { font-size: 0.9rem !important; }
        .metadata-overlay.font-large { font-size: 1.1rem !important; }
        .metadata-overlay.font-xlarge { font-size: 1.4rem !important; }
        .metadata-overlay.font-xxlarge { font-size: 1.8rem !important; }

        /* Smooth text content transitions - overlay stays in place */
        .metadata-overlay.visible {
            opacity: 1;
        }

        .metadata-overlay.transitioning {
            opacity: 0.3;
        }

        /* Individual metadata line transitions */
        .metadata-line {
            transition: opacity 1s ease-in-out, filter 1s ease-in-out;
        }

        .metadata-line.fade-out {
            opacity: 0;
        }

        .metadata-line.blur-out {
            opacity: 0;
            filter: blur(3px);
        }

        .metadata-line.slide-up-out {
            opacity: 0;
            transform: translateY(-20px);
        }

        .metadata-line.slide-down-out {
            opacity: 0;
            transform: translateY(20px);
        }

        .metadata-line.glow-out {
            opacity: 0;
            text-shadow: 0 0 15px currentColor;
        }

        .metadata-line.typewriter-out {
            opacity: 0;
            letter-spacing: 0.2em;
        }

        /* Enhanced transitions for transform effects */
        .metadata-line {
            transition: opacity 1s ease-in-out, filter 1s ease-in-out, transform 1s ease-in-out, text-shadow 1s ease-in-out, letter-spacing 1s ease-in-out;
        }

        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Elegant animation keyframes - fade with background control */
        @keyframes elegantIn {
            0% {
                opacity: 0;
                background-color: transparent;
            }
            100% {
                opacity: 1;
                background-color: transparent;
            }
        }

        @keyframes elegantOut {
            0% {
                opacity: 1;
                background-color: black;
            }
            1% {
                opacity: 1;
                background-color: transparent;
            }
            100% {
                opacity: 0;
                background-color: transparent;
            }
        }

        /* Animation classes - timing will be set dynamically */
        .animate-elegant-in {
            animation: elegantIn var(--animation-duration, 0.4s) ease-out forwards;
        }

        .animate-elegant-out {
            animation: elegantOut var(--animation-duration, 0.4s) ease-out forwards;
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.9);
            padding: 20px 30px;
            border-radius: 10px;
            font-size: 1.2rem;
            text-align: center;
            display: none;
        }

        .no-photos {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0.7;
        }

        .no-photos h2 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .no-photos p {
            font-size: 1.2rem;
        }

        .preload-container {
            position: absolute;
            top: -9999px;
            left: -9999px;
            opacity: 0;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .clock {
                font-size: 2rem;
            }

            .overlay {
                bottom: 10px;
                right: 10px;
                padding: 10px 15px;
            }

            .source-indicator,
            .photo-counter {
                padding: 8px 12px;
                font-size: 0.8rem;
                /* Removed fixed positioning - pos- classes will handle this */
            }
        }

        /* Change Warning Popup */
        #change-warning-popup {
            position: fixed;
            bottom: -200px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ff6b35;
            border-radius: 15px;
            padding: 0;
            z-index: 10000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            transition: bottom 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            max-width: 500px;
            width: 90%;
            cursor: auto;
        }

        #change-warning-popup.show {
            bottom: 30px;
        }

        .warning-content {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 20px;
        }

        .warning-icon {
            font-size: 2.5rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .warning-text h3 {
            color: #ff6b35;
            margin: 0 0 8px 0;
            font-size: 1.2rem;
        }

        .warning-text p {
            color: #fff;
            margin: 0;
            font-size: 1rem;
            opacity: 0.9;
        }

        .warning-buttons {
            display: flex;
            gap: 10px;
            flex-direction: column;
            min-width: 120px;
        }

        .warning-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .warning-btn.save {
            background: #46cc71;
            color: white;
        }

        .warning-btn.save:hover {
            background: #3bb863;
            transform: translateY(-2px);
        }

        .warning-btn.dismiss {
            background: transparent;
            color: #ccc;
            border: 1px solid #555;
        }

        .warning-btn.dismiss:hover {
            background: #333;
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="slideshow-container">
        <!-- EDITOR GRID: Inside slideshow container for correct stacking context -->
        <div id="editor-grid-overlay" style="
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-size: 20px 20px;
            background-image:
                linear-gradient(rgba(255,255,255,0.3) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.3) 1px, transparent 1px);
            pointer-events: none;
            z-index: 5;
            display: none;
        "></div>
        <div class="photo-container">
            <img id="bg1" class="photo-background" alt="Background 1">
            <img id="bg2" class="photo-background" alt="Background 2">
            <img id="photo1" class="photo" alt="Slideshow Photo 1">
            <img id="photo2" class="photo" alt="Slideshow Photo 2">
            <div class="preload-container">
                <img id="preloadPhoto" alt="Preload Photo">
            </div>
        </div>

        <div class="source-indicator pos-top-left size-medium" id="source">
            <div class="source-icon" id="sourceIcon"></div>
            <span id="sourceText">Local Photos</span>
        </div>

        <div class="photo-counter pos-bottom-left size-medium" id="counter">
            <span id="photoCounter">0 / 0</span>
        </div>

        <div class="metadata-overlay" id="metadataOverlay">
            <div class="metadata-line metadata-filename" id="metadataFilename"></div>
            <div class="metadata-line metadata-date" id="metadataDate"></div>
            <div class="metadata-line metadata-camera" id="metadataCamera"></div>
            <div class="metadata-line metadata-exposure" id="metadataExposure"></div>
            <div class="metadata-line metadata-location" id="metadataLocation"></div>
        </div>

        <div class="clock pos-bottom-right size-large background-dark" id="clock">00:00</div>
        <div class="date pos-bottom-left size-medium background-dark" id="date">Loading...</div>

        <div class="loading-indicator" id="loadingIndicator">
            <div class="spinner"></div>
        </div>

        <div class="error-message" id="errorMessage">
            Failed to load photo
        </div>

        <div class="no-photos" id="noPhotos" style="display: none;">
            <h2>No Photos Available</h2>
            <p>Add photos to your Pictures folder or configure Google Photos</p>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');

        let config = {};
        let photos = [];
        let currentIndex = 0;
        let clockInterval = null;
        let currentPhotoElement = 1; // Track which photo element is currently visible

        const elements = {
            bg1: document.getElementById('bg1'),
            bg2: document.getElementById('bg2'),
            photo1: document.getElementById('photo1'),
            photo2: document.getElementById('photo2'),
            preloadPhoto: document.getElementById('preloadPhoto'),
            sourceIcon: document.getElementById('sourceIcon'),
            sourceText: document.getElementById('sourceText'),
            photoCounter: document.getElementById('photoCounter'),
            metadataOverlay: document.getElementById('metadataOverlay'),
            metadataFilename: document.getElementById('metadataFilename'),
            metadataDate: document.getElementById('metadataDate'),
            metadataCamera: document.getElementById('metadataCamera'),
            metadataExposure: document.getElementById('metadataExposure'),
            metadataLocation: document.getElementById('metadataLocation'),
            clock: document.getElementById('clock'),
            date: document.getElementById('date'),
            loadingIndicator: document.getElementById('loadingIndicator'),
            errorMessage: document.getElementById('errorMessage'),
            noPhotos: document.getElementById('noPhotos')
        };

        function initializeClock() {
            if (clockInterval) {
                clearInterval(clockInterval);
            }

            function updateClock() {
                const now = new Date();
                const use12Hour = config.clockFormat === '12hour';

                if (use12Hour) {
                    // Custom 12-hour formatting to control AM/PM case and size
                    const hour12 = now.getHours() % 12 || 12;
                    const minute = now.getMinutes().toString().padStart(2, '0');
                    const ampm = now.getHours() >= 12 ? 'PM' : 'AM';

                    // Apply AM/PM case preference
                    const ampmFormatted = config.clockAmPmCase === 'lowercase' ? ampm.toLowerCase() : ampm;

                    // Create time with custom AM/PM styling
                    const timeBase = `${hour12}:${minute}`;

                    // Generate spacing (number of spaces)
                    const spacing = config.clockAmPmSpacing || '1';
                    const spaceChars = '\u00A0'.repeat(parseInt(spacing)); // Use non-breaking spaces

                    if (config.clockAmPmSize && config.clockAmPmSize !== '80') {
                        // Use HTML with custom AM/PM size as percentage of clock font
                        const ampmSize = (config.clockAmPmSize / 100) + 'em';
                        elements.clock.innerHTML = `${timeBase}${spaceChars}<span style="font-size: ${ampmSize};">${ampmFormatted}</span>`;
                    } else {
                        elements.clock.textContent = `${timeBase}${spaceChars}${ampmFormatted}`;
                    }
                } else {
                    // 24-hour format
                    const timeString = now.toLocaleTimeString([], {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    });
                    elements.clock.textContent = timeString;
                }

                const dateString = now.toLocaleDateString([], {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });

                elements.date.textContent = dateString;
            }

            updateClock();
            // Use animation controller instead of setInterval
            if (window.animationController) {
                window.animationController.scheduleInterval(updateClock, 1000, 'clock_update');
            }
        }

        function updateSourceIndicator(photo) {
            if (photo.type === 'google') {
                elements.sourceIcon.className = 'source-icon google';
                elements.sourceText.textContent = 'Google Photos';
            } else {
                elements.sourceIcon.className = 'source-icon local';
                elements.sourceText.textContent = 'Local Photos';
            }
        }

        function updatePhotoCounter(current, total) {
            elements.photoCounter.textContent = `${current + 1} / ${total}`;
        }

        function updateMetadataDisplay(photo) {
            // Use smooth content transition for photo changes
            transitionMetadataContent(photo);
        }

        function showMetadataOverlay() {
            updateMetadataStyles();
            elements.metadataOverlay.style.display = 'block';
            // Force reflow before adding visible class
            elements.metadataOverlay.offsetHeight;
            elements.metadataOverlay.classList.add('visible');
        }

        function hideMetadataOverlay() {
            elements.metadataOverlay.classList.remove('visible');
            const transitionDuration = config.transitionDuration || 2000;
            setTimeout(() => {
                elements.metadataOverlay.style.display = 'none';
            }, transitionDuration / 2); // Match half transition duration
        }

        function transitionMetadataContent(newPhoto) {
            if (!config.showMetadata || !newPhoto.metadata) {
                hideMetadataOverlay();
                return;
            }

            const transitionType = config.metadataTransitionType || 'fade';
            const transitionDuration = config.transitionDuration || 2000; // Get slideshow transition duration
            const halfDuration = transitionDuration / 2;
            const metadataLines = elements.metadataOverlay.querySelectorAll('.metadata-line');

            // Update CSS transition duration to match slideshow
            metadataLines.forEach(line => {
                line.style.transition = `opacity ${halfDuration}ms ease-in-out, filter ${halfDuration}ms ease-in-out, transform ${halfDuration}ms ease-in-out, text-shadow ${halfDuration}ms ease-in-out, letter-spacing ${halfDuration}ms ease-in-out`;
            });

            // Start transition - apply appropriate out effect
            const outClass = `${transitionType}-out`;
            metadataLines.forEach(line => line.classList.add(outClass));

            // After fade out, update content and fade in
            setTimeout(() => {
                updateMetadataContent(newPhoto);

                // Fade in new content
                setTimeout(() => {
                    metadataLines.forEach(line => {
                        line.classList.remove('fade-out', 'blur-out', 'slide-up-out', 'slide-down-out', 'glow-out', 'typewriter-out');
                    });
                }, 50);
            }, halfDuration);
        }

        function updateMetadataContent(photo) {
            const metadata = photo.metadata;
            let hasContent = false;

            // Clear all fields first
            elements.metadataFilename.textContent = '';
            elements.metadataDate.textContent = '';
            elements.metadataCamera.textContent = '';
            elements.metadataExposure.textContent = '';
            elements.metadataLocation.textContent = '';

            // Show/hide filename
            if (config.showFilename && metadata.filename) {
                elements.metadataFilename.textContent = metadata.filename;
                elements.metadataFilename.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataFilename.style.display = 'none';
            }

            // Show/hide date taken
            if (config.showDateTaken && metadata.dateFormatted) {
                elements.metadataDate.textContent = metadata.dateFormatted;
                elements.metadataDate.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataDate.style.display = 'none';
            }

            // Show/hide camera info
            if (config.showCameraInfo && metadata.camera) {
                let cameraText = metadata.camera;
                if (metadata.lens) {
                    cameraText += ` â€¢ ${metadata.lens}`;
                }
                elements.metadataCamera.textContent = cameraText;
                elements.metadataCamera.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataCamera.style.display = 'none';
            }

            // Show/hide exposure settings
            if (config.showCameraInfo && metadata.exposure) {
                elements.metadataExposure.textContent = metadata.exposure;
                elements.metadataExposure.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataExposure.style.display = 'none';
            }

            // Show/hide location (GPS coordinates)
            if (config.showLocation && metadata.location) {
                elements.metadataLocation.textContent = `ðŸ“ ${metadata.location.formatted}`;
                elements.metadataLocation.style.display = 'block';
                hasContent = true;
            } else {
                elements.metadataLocation.style.display = 'none';
            }

            // Show/hide entire overlay based on content
            if (hasContent) {
                if (elements.metadataOverlay.style.display === 'none') {
                    showMetadataOverlay();
                }
            } else {
                hideMetadataOverlay();
            }
        }

        function updateMetadataStyles() {
            const overlay = elements.metadataOverlay;

            // Preserve the visible state
            const wasVisible = overlay.classList.contains('visible');

            // Clear existing classes
            overlay.className = 'metadata-overlay';

            // Check if custom coordinates are provided
            const hasCustomX = config.metadataCustomX && config.metadataCustomX.trim() !== '';
            const hasCustomY = config.metadataCustomY && config.metadataCustomY.trim() !== '';

            if (hasCustomX || hasCustomY) {
                // Use custom positioning - apply directly with proper cleanup
                // CRITICAL: Must set position to absolute and clear ALL directional properties
                overlay.style.position = 'absolute';
                overlay.style.top = 'auto';
                overlay.style.right = 'auto';
                overlay.style.bottom = 'auto';  // CRITICAL: Must clear bottom
                overlay.style.left = 'auto';
                overlay.style.transform = 'none';  // CRITICAL: Must clear transform

                // Apply custom positions
                if (hasCustomX) {
                    overlay.style.left = config.metadataCustomX;
                }
                if (hasCustomY) {
                    overlay.style.top = config.metadataCustomY;
                }
            } else {
                // Use preset position with CSS classes
                overlay.classList.add(`pos-${config.metadataPosition || 'bottom-center'}`);
                // Clear ALL inline positioning to let CSS classes work properly
                overlay.style.position = '';
                overlay.style.top = '';
                overlay.style.right = '';
                overlay.style.bottom = '';
                overlay.style.left = '';
                overlay.style.transform = '';
            }

            // Apply background
            overlay.classList.add(`background-${config.metadataBackground || 'dark'}`);

            // Apply custom font size if specified
            if (config.metadataCustomFontSize && config.metadataCustomFontSize.trim() !== '') {
                overlay.style.fontSize = config.metadataCustomFontSize;
            } else {
                overlay.style.fontSize = ''; // Clear custom font size
            }

            // Restore visible state if it was visible
            // In editor mode, respect the showMetadata setting
            if (wasVisible && config.showMetadata !== false) {
                overlay.classList.add('visible');
                overlay.style.display = 'block';
                overlay.style.opacity = '1';
            } else if (config.showMetadata === false) {
                // If metadata is disabled, hide it even in editor mode
                overlay.style.display = 'none';
            }

            // Apply custom opacity if set
            if (config.metadataBackgroundOpacity !== undefined) {
                const opacity = config.metadataBackgroundOpacity / 100;
                if (config.metadataBackground === 'dark') {
                    overlay.style.backgroundColor = `rgba(0, 0, 0, ${opacity})`;
                } else if (config.metadataBackground === 'light') {
                    overlay.style.backgroundColor = `rgba(255, 255, 255, ${opacity * 0.4})`;
                } else if (config.metadataBackground === 'blue') {
                    overlay.style.backgroundColor = `rgba(52, 152, 219, ${opacity})`;
                } else if (config.metadataBackground === 'green') {
                    overlay.style.backgroundColor = `rgba(52, 168, 83, ${opacity})`;
                } else if (config.metadataBackground === 'red') {
                    overlay.style.backgroundColor = `rgba(231, 76, 60, ${opacity})`;
                } else if (config.metadataBackground === 'purple') {
                    overlay.style.backgroundColor = `rgba(155, 89, 182, ${opacity})`;
                }
            }

            // Apply custom color if specified
            if (config.metadataColor) {
                overlay.style.color = config.metadataColor;
            }

            // Apply advanced styling options
            if (config.metadataBorderRadius && config.metadataBorderRadius.trim() !== '') {
                overlay.style.borderRadius = config.metadataBorderRadius;
            } else {
                overlay.style.borderRadius = ''; // Clear custom border radius
            }

            if (config.metadataPadding && config.metadataPadding.trim() !== '') {
                overlay.style.padding = config.metadataPadding;
            } else {
                overlay.style.padding = ''; // Clear custom padding
            }

            if (config.metadataShadow && config.metadataShadow.trim() !== '') {
                overlay.style.boxShadow = config.metadataShadow;
            } else {
                overlay.style.boxShadow = ''; // Clear custom shadow
            }
        }

        function showLoading() {
            elements.loadingIndicator.style.display = 'block';
            elements.errorMessage.style.display = 'none';
        }

        function hideLoading() {
            elements.loadingIndicator.style.display = 'none';
        }

        function showError(message = 'Failed to load photo') {
            elements.errorMessage.textContent = message;
            elements.errorMessage.style.display = 'block';
            elements.loadingIndicator.style.display = 'none';
        }

        function hideError() {
            elements.errorMessage.style.display = 'none';
        }

        function getPhotoUrl(photo, index) {
            if (photo.type === 'google') {
                return `http://localhost:${config.port || 8081}/google-photo/${encodeURIComponent(photo.url)}`;
            } else {
                return `http://localhost:${config.port || 8081}/photo/${index !== undefined ? index : photos.indexOf(photo)}`;
            }
        }

        function preloadNextPhoto(index) {
            if (photos.length === 0) return;

            const nextIndex = (index + 1) % photos.length;
            const nextPhoto = photos[nextIndex];

            if (nextPhoto) {
                elements.preloadPhoto.src = getPhotoUrl(nextPhoto, nextIndex);
            }
        }

        function showPhoto(photoData) {
            if (!photoData || !photoData.photo) {
                showError('No photo data received');
                return;
            }

            const { index, photo } = photoData;
            currentIndex = index;

            if (photos.length === 0) {
                elements.noPhotos.style.display = 'block';
                return;
            } else {
                elements.noPhotos.style.display = 'none';
            }

            hideError();

            updateSourceIndicator(photo);
            updatePhotoCounter(index, photos.length);
            updateMetadataDisplay(photo);

            const photoUrl = getPhotoUrl(photo, index);

            // Determine which photo element to use next
            const nextPhotoElement = currentPhotoElement === 1 ? 2 : 1;
            const currentPhoto = elements[`photo${currentPhotoElement}`];
            const nextPhoto = elements[`photo${nextPhotoElement}`];
            const currentBg = elements[`bg${currentPhotoElement}`];
            const nextBg = elements[`bg${nextPhotoElement}`];

            const newPhoto = new Image();

            // Track the preload image for memory management
            window.memoryManager.trackImage(newPhoto, `preload_${Date.now()}`);

            newPhoto.onload = () => {
                // Set the source on both the foreground and background elements
                nextPhoto.src = photoUrl;
                nextBg.src = photoUrl;

                // Track the actual display images for memory management
                window.memoryManager.trackImage(nextPhoto, `display_photo_${nextPhotoElement}`);
                window.memoryManager.trackImage(nextBg, `display_bg_${nextPhotoElement}`);

                // Add transitioning background during photo change
                const container = document.querySelector('.slideshow-container');
                container.classList.add('transitioning');

                // Start transition: fade in new photo while keeping current at full opacity
                setTimeout(() => {
                    nextPhoto.classList.add('visible');
                    nextBg.classList.add('visible');
                    // Don't fade out current photo yet - wait for transition to complete
                }, 50); // Small delay to ensure src is set

                // Get actual transition duration from config
                const transitionDuration = config.transitionDuration || 2000;

                // Track transition performance
                window.performanceMonitor.logTransition(transitionDuration);

                // Only fade out old photo after new photo is fully visible
                setTimeout(() => {
                    currentPhoto.classList.remove('visible');
                    currentBg.classList.remove('visible');
                }, transitionDuration / 2 + 50); // Halfway through transition + delay

                // Release old images from memory AFTER fade out transition completes
                setTimeout(() => {
                    window.memoryManager.releaseImage(currentPhoto);
                    window.memoryManager.releaseImage(currentBg);
                }, transitionDuration + 200); // Wait until fade out is completely done

                // Remove transitioning background after transition completes
                setTimeout(() => {
                    container.classList.remove('transitioning');
                }, transitionDuration + 100); // After full transition completes

                // Update which element is current after transition completes
                setTimeout(() => {
                    currentPhotoElement = nextPhotoElement;
                }, transitionDuration); // Match actual transition duration

                preloadNextPhoto(index);
            };

            newPhoto.onerror = () => {
                console.error('Failed to load photo:', photoUrl);
                showError(`Failed to load: ${photo.title || 'Unknown photo'}`);

                setTimeout(() => {
                    hideError();
                }, 3000);
            };

            newPhoto.src = photoUrl;
        }

        // Context Menu System for Editor Mode
        function makeContextMenuEnabled(element, elementId) {
            // Add visual feedback for interactive elements
            element.style.cursor = 'move';
            element.style.transition = 'box-shadow 0.2s ease';

            // Add hover effect in editor mode
            element.addEventListener('mouseenter', () => {
                if (config.editorMode) {
                    element.style.boxShadow = '0 0 0 2px rgba(74, 144, 226, 0.6)';
                }
            });

            element.addEventListener('mouseleave', () => {
                if (config.editorMode && !element.classList.contains('dragging')) {
                    element.style.boxShadow = '';
                }
            });

            // Drag functionality
            let isDragging = false;
            let startX, startY, startLeft, startTop;

            element.addEventListener('mousedown', (e) => {
                if (!config.editorMode) return;

                // Only start drag on left click, not right click
                if (e.button !== 0) return;

                e.preventDefault();
                isDragging = true;
                element.classList.add('dragging');

                const rect = element.getBoundingClientRect();
                startX = e.clientX;
                startY = e.clientY;
                startLeft = rect.left;
                startTop = rect.top;

                // CRITICAL FIX: Clear ALL positioning from CSS defaults before drag starts
                // This is especially important for metadata which has bottom/right/transform in CSS
                element.style.position = 'fixed';
                element.style.left = startLeft + 'px';
                element.style.top = startTop + 'px';
                element.style.right = 'auto';
                element.style.bottom = 'auto';
                element.style.transform = 'none';

                element.style.zIndex = '10000';
                element.style.opacity = '0.8';

                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            });

            function handleMouseMove(e) {
                if (!isDragging) return;

                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                const newLeft = startLeft + deltaX;
                const newTop = startTop + deltaY;

                // Set position directly for immediate feedback
                // Keep clearing bottom/right/transform during drag to prevent CSS interference
                element.style.position = 'fixed';
                element.style.left = newLeft + 'px';
                element.style.top = newTop + 'px';
                element.style.right = 'auto';
                element.style.bottom = 'auto';
                element.style.transform = 'none';
            }

            function handleMouseUp(e) {
                if (!isDragging) return;

                isDragging = false;
                element.classList.remove('dragging');
                element.style.zIndex = '';
                element.style.boxShadow = '';

                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);

                // Save the new position relative to slideshow container
                const elementRect = element.getBoundingClientRect();
                const container = document.querySelector('.slideshow-container');
                const containerRect = container ? container.getBoundingClientRect() : { left: 0, top: 0 };
                const x = Math.round(elementRect.left - containerRect.left);
                const y = Math.round(elementRect.top - containerRect.top);

                // Reset position to absolute after drag (especially important for metadata)
                element.style.position = 'absolute';
                element.style.left = x + 'px';
                element.style.top = y + 'px';
                // Clear any bottom/right/transform that might interfere
                element.style.bottom = 'auto';
                element.style.right = 'auto';
                element.style.transform = 'none';

                // CRITICAL FIX: For metadata, ensure it stays visible
                // Metadata has opacity: 0 in CSS by default, so we need to keep it visible
                if (elementId === 'metadataOverlay') {
                    element.style.display = 'block';
                    element.style.opacity = '1';
                } else {
                    element.style.opacity = '';  // For other elements, clear opacity
                }

                // Update config and save
                // CRITICAL FIX: For metadataOverlay, use shorter property names to match config
                let propNameX, propNameY, propNamePos;
                if (elementId === 'metadataOverlay') {
                    propNameX = 'metadataCustomX';
                    propNameY = 'metadataCustomY';
                    propNamePos = 'metadataPosition';
                } else {
                    propNameX = `${elementId}CustomX`;
                    propNameY = `${elementId}CustomY`;
                    propNamePos = `${elementId}Position`;
                }

                console.log(`ðŸ” DEBUG: Adding pending changes for ${elementId}:`);
                console.log(`  Property names: X='${propNameX}', Y='${propNameY}', Pos='${propNamePos}'`);
                console.log(`  Values: X='${x}px', Y='${y}px', Pos='custom'`);

                addPendingChange(elementId, propNameX, x + 'px');
                addPendingChange(elementId, propNameY, y + 'px');
                addPendingChange(elementId, propNamePos, 'custom');

                console.log(`ðŸŽ¯ DRAG COMPLETE: Dragged ${elementId} to (${x}, ${y})`);
                console.log(`ðŸŽ¯ PENDING CHANGES ADDED:`, pendingChanges);
            }

            // Right-click context menu
            element.addEventListener('contextmenu', (e) => {
                if (!config.editorMode) return;
                e.preventDefault();
                showContextMenu(elementId, e.clientX, e.clientY);
            });

            // Touch and hold for mobile (500ms)
            let touchHoldTimer;
            element.addEventListener('touchstart', (e) => {
                if (!config.editorMode) return;

                touchHoldTimer = setTimeout(() => {
                    const touch = e.touches[0];
                    showContextMenu(elementId, touch.clientX, touch.clientY);
                    // Add haptic feedback if available
                    if (navigator.vibrate) navigator.vibrate(50);
                }, 500);
            });

            element.addEventListener('touchend', () => {
                clearTimeout(touchHoldTimer);
            });

            element.addEventListener('touchmove', () => {
                clearTimeout(touchHoldTimer);
            });

            // Hover effect for editor mode
            element.addEventListener('mouseenter', () => {
                if (config.editorMode) {
                    element.style.boxShadow = '0 4px 12px rgba(74, 144, 226, 0.3)';
                }
            });

            element.addEventListener('mouseleave', () => {
                if (config.editorMode) {
                    element.style.boxShadow = '';
                }
            });
        }

        // Context Menu Display System
        function showContextMenu(elementId, x, y) {
            // Remove any existing context menu
            const existingMenu = document.getElementById('context-menu');
            if (existingMenu) existingMenu.remove();

            // Create context menu
            const menu = document.createElement('div');
            menu.id = 'context-menu';
            menu.style.cssText = `
                position: fixed;
                left: ${x}px;
                top: ${y}px;
                background: rgba(32, 34, 37, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                padding: 8px 0;
                min-width: 200px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
                z-index: 10001;
                color: white;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                font-size: 14px;
            `;

            // Determine if element is currently visible
            const isVisible = getElementVisibility(elementId);

            // Create menu items
            const menuItems = [
                {
                    icon: isVisible ? 'ðŸ‘ï¸' : 'ðŸ‘ï¸â€ðŸ—¨ï¸',
                    label: isVisible ? 'Hide Element' : 'Show Element',
                    action: () => toggleElementVisibility(elementId)
                },
                { icon: 'ðŸ“', label: 'Position', action: () => showPositionMenu(elementId) },
                { icon: 'ðŸ“', label: 'Font Size', action: () => showSizeMenu(elementId) },
                { icon: 'ðŸŽ¨', label: 'Colors', action: () => showColorMenu(elementId) },
                { icon: 'ðŸ‘ï¸', label: 'Opacity', action: () => showOpacityMenu(elementId) },
                { icon: 'ðŸŽ­', label: 'Background', action: () => showBackgroundMenu(elementId) }
            ];

            // Add clock-specific format option
            if (elementId === 'clock') {
                menuItems.splice(2, 0, { icon: 'ðŸ•', label: 'Time Format', action: () => showTimeFormatMenu(elementId) });
            }

            // Add date-specific format option
            if (elementId === 'date') {
                menuItems.splice(2, 0, { icon: 'ðŸ“…', label: 'Date Format', action: () => showDateFormatMenu(elementId) });
            }

            menuItems.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.style.cssText = `
                    padding: 10px 16px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    transition: background-color 0.2s ease;
                `;

                menuItem.innerHTML = `
                    <span style="font-size: 16px;">${item.icon}</span>
                    <span>${item.label}</span>
                `;

                menuItem.addEventListener('mouseenter', () => {
                    menuItem.style.backgroundColor = 'rgba(74, 144, 226, 0.2)';
                });

                menuItem.addEventListener('mouseleave', () => {
                    menuItem.style.backgroundColor = 'transparent';
                });

                menuItem.addEventListener('click', () => {
                    menu.remove();
                    item.action();
                });

                menu.appendChild(menuItem);
            });

            // Position menu on screen
            document.body.appendChild(menu);

            // Adjust position if menu goes off screen
            const rect = menu.getBoundingClientRect();
            if (rect.right > window.innerWidth) {
                menu.style.left = (x - rect.width) + 'px';
            }
            if (rect.bottom > window.innerHeight) {
                menu.style.top = (y - rect.height) + 'px';
            }

            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closeMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                    }
                });
            }, 100);

            console.log(`Showing context menu for ${elementId} at (${x}, ${y})`);
        }

        // Position Menu
        function showPositionMenu(elementId) {
            console.log(`Show position menu for ${elementId}`);

            // Remove any existing context menu
            const existingMenu = document.getElementById('position-menu');
            if (existingMenu) existingMenu.remove();

            // Create position menu
            const menu = document.createElement('div');
            menu.id = 'position-menu';
            menu.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: rgba(32, 34, 37, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 20px;
                width: 320px;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                z-index: 10002;
                color: white;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            `;

            menu.innerHTML = `
                <div style="margin-bottom: 16px; font-weight: 600; color: #4A90E2;">ðŸ“ Position - ${elementId}</div>

                <!-- Corner Presets -->
                <div style="margin-bottom: 16px;">
                    <div style="margin-bottom: 8px; font-size: 13px; color: #ccc;">Quick Positions:</div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                        <button class="position-btn" data-position="top-left">Top Left</button>
                        <button class="position-btn" data-position="top-center">Top Center</button>
                        <button class="position-btn" data-position="top-right">Top Right</button>
                        <button class="position-btn" data-position="center-left">Left</button>
                        <button class="position-btn" data-position="center">Center</button>
                        <button class="position-btn" data-position="center-right">Right</button>
                        <button class="position-btn" data-position="bottom-left">Bottom Left</button>
                        <button class="position-btn" data-position="bottom-center">Bottom Center</button>
                        <button class="position-btn" data-position="bottom-right">Bottom Right</button>
                    </div>
                </div>

                <!-- Custom Coordinates -->
                <div style="margin-bottom: 16px;">
                    <div style="margin-bottom: 8px; font-size: 13px; color: #ccc;">Custom Position:</div>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <div style="flex: 1;">
                            <label style="display: block; font-size: 12px; margin-bottom: 4px;">X Position</label>
                            <input type="text" id="custom-x-input" placeholder="e.g. 20px or 5%"
                                   style="width: 100%; padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: white; font-size: 14px;">
                        </div>
                        <div style="flex: 1;">
                            <label style="display: block; font-size: 12px; margin-bottom: 4px;">Y Position</label>
                            <input type="text" id="custom-y-input" placeholder="e.g. 30px or 10%"
                                   style="width: 100%; padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: white; font-size: 14px;">
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; gap: 8px; justify-content: flex-end;">
                    <button id="position-cancel-btn" style="padding: 8px 16px; background: transparent; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; color: white; cursor: pointer;">Cancel</button>
                    <button id="position-apply-btn" style="padding: 8px 16px; background: #4A90E2; border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600;">Apply</button>
                </div>
            `;

            // Add button styles
            const style = document.createElement('style');
            style.textContent = `
                .position-btn {
                    padding: 8px 4px;
                    background: rgba(255,255,255,0.1);
                    border: 1px solid rgba(255,255,255,0.2);
                    border-radius: 4px;
                    color: white;
                    cursor: pointer;
                    font-size: 11px;
                    transition: all 0.2s ease;
                }
                .position-btn:hover {
                    background: rgba(74, 144, 226, 0.3);
                    border-color: rgba(74, 144, 226, 0.6);
                }
                .position-btn.active {
                    background: rgba(74, 144, 226, 0.5);
                    border-color: #4A90E2;
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(menu);

            // Get current position to highlight active preset
            const currentPos = getCurrentElementPosition(elementId);
            highlightCurrentPosition(currentPos);

            // Handle preset button clicks
            menu.querySelectorAll('.position-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Remove active class from all buttons
                    menu.querySelectorAll('.position-btn').forEach(b => b.classList.remove('active'));
                    // Add active class to clicked button
                    btn.classList.add('active');
                    // Clear custom inputs when preset is selected
                    document.getElementById('custom-x-input').value = '';
                    document.getElementById('custom-y-input').value = '';
                });
            });

            // Handle apply button
            document.getElementById('position-apply-btn').addEventListener('click', () => {
                const activePreset = menu.querySelector('.position-btn.active');
                const customX = document.getElementById('custom-x-input').value.trim();
                const customY = document.getElementById('custom-y-input').value.trim();

                if (activePreset) {
                    // Apply preset position
                    const position = activePreset.dataset.position;
                    // Use correct property names for metadata
                    if (elementId === 'metadataOverlay') {
                        addPendingChange(elementId, 'metadataPosition', position);
                        // Clear custom coordinates when using preset
                        addPendingChange(elementId, 'metadataCustomX', '');
                        addPendingChange(elementId, 'metadataCustomY', '');
                    } else {
                        addPendingChange(elementId, `${elementId}Position`, position);
                        // Clear custom coordinates when using preset
                        addPendingChange(elementId, `${elementId}CustomX`, '');
                        addPendingChange(elementId, `${elementId}CustomY`, '');
                    }
                } else if (customX || customY) {
                    // Apply custom coordinates
                    if (elementId === 'metadataOverlay') {
                        addPendingChange(elementId, 'metadataPosition', 'custom');
                        if (customX) addPendingChange(elementId, 'metadataCustomX', customX);
                        if (customY) addPendingChange(elementId, 'metadataCustomY', customY);
                    } else {
                        addPendingChange(elementId, `${elementId}Position`, 'custom');
                        if (customX) addPendingChange(elementId, `${elementId}CustomX`, customX);
                        if (customY) addPendingChange(elementId, `${elementId}CustomY`, customY);
                    }
                }

                menu.remove();
            });

            // Handle cancel button
            document.getElementById('position-cancel-btn').addEventListener('click', () => {
                menu.remove();
            });

            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closePositionMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closePositionMenu);
                    }
                });
            }, 100);
        }

        // Size Menu
        function showSizeMenu(elementId) {
            console.log(`Show size menu for ${elementId}`);

            // Remove any existing menu
            const existingMenu = document.getElementById('size-menu');
            if (existingMenu) existingMenu.remove();

            // Create size menu
            const menu = document.createElement('div');
            menu.id = 'size-menu';
            menu.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: rgba(32, 34, 37, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 20px;
                min-width: 300px;
                max-width: 90vw;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                z-index: 10002;
                color: white;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            `;

            // Get current font size
            const currentSize = getCurrentElementFontSize(elementId);

            menu.innerHTML = `
                <div style="margin-bottom: 16px; font-weight: 600; color: #4A90E2;">ðŸ“ Font Size - ${elementId}</div>

                <!-- Size Presets -->
                <div style="margin-bottom: 16px;">
                    <div style="margin-bottom: 8px; font-size: 13px; color: #ccc;">Quick Sizes:</div>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        <button class="size-btn" data-size="12">12px</button>
                        <button class="size-btn" data-size="14">14px</button>
                        <button class="size-btn" data-size="16">16px</button>
                        <button class="size-btn" data-size="18">18px</button>
                        <button class="size-btn" data-size="20">20px</button>
                        <button class="size-btn" data-size="24">24px</button>
                        <button class="size-btn" data-size="28">28px</button>
                        <button class="size-btn" data-size="32">32px</button>
                        <button class="size-btn" data-size="48">48px</button>
                    </div>
                </div>

                <!-- Custom Size Slider -->
                <div style="margin-bottom: 16px;">
                    <div style="margin-bottom: 8px; font-size: 13px; color: #ccc;">Custom Size:</div>
                    <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 8px;">
                        <span style="font-size: 12px; color: #888;">8px</span>
                        <input type="range" id="size-slider" min="8" max="300" value="${currentSize}"
                               style="flex: 1; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; outline: none;">
                        <span style="font-size: 12px; color: #888;">300px</span>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <span style="font-size: 12px; color: #ccc;">Type ANY size:</span>
                        <input type="number" id="custom-size-input" min="1" value="${currentSize}" placeholder="No limits!"
                               style="width: 80px; padding: 4px 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: white; font-size: 12px;">
                        <span style="font-size: 12px; color: #888;">px</span>
                        <span id="size-display" style="color: #4A90E2; font-weight: 600; margin-left: auto;">${currentSize}px</span>
                    </div>
                </div>

                <!-- Preview Text -->
                <div style="margin-bottom: 16px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 6px; text-align: center; overflow: hidden; max-height: 200px;">
                    <div id="size-preview" style="font-size: ${currentSize}px; color: white; transition: font-size 0.2s ease; word-break: break-word;">Abc</div>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; gap: 8px; justify-content: flex-end;">
                    <button id="size-cancel-btn" style="padding: 8px 16px; background: transparent; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; color: white; cursor: pointer;">Cancel</button>
                    <button id="size-apply-btn" style="padding: 8px 16px; background: #4A90E2; border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600;">Apply</button>
                </div>
            `;

            // Add button styles for size buttons
            const style = document.createElement('style');
            style.textContent = `
                .size-btn {
                    padding: 6px 8px;
                    background: rgba(255,255,255,0.1);
                    border: 1px solid rgba(255,255,255,0.2);
                    border-radius: 4px;
                    color: white;
                    cursor: pointer;
                    font-size: 12px;
                    transition: all 0.2s ease;
                }
                .size-btn:hover {
                    background: rgba(74, 144, 226, 0.3);
                    border-color: rgba(74, 144, 226, 0.6);
                }
                .size-btn.active {
                    background: rgba(74, 144, 226, 0.5);
                    border-color: #4A90E2;
                }
                #size-slider::-webkit-slider-thumb {
                    appearance: none;
                    width: 16px;
                    height: 16px;
                    border-radius: 50%;
                    background: #4A90E2;
                    cursor: pointer;
                }
                #size-slider::-moz-range-thumb {
                    width: 16px;
                    height: 16px;
                    border-radius: 50%;
                    background: #4A90E2;
                    cursor: pointer;
                    border: none;
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(menu);

            let selectedSize = currentSize;

            // Highlight current size if it matches a preset
            menu.querySelectorAll('.size-btn').forEach(btn => {
                if (parseInt(btn.dataset.size) === currentSize) {
                    btn.classList.add('active');
                }
            });

            // Handle preset button clicks
            menu.querySelectorAll('.size-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    selectedSize = parseInt(btn.dataset.size);

                    // Update UI
                    menu.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    document.getElementById('size-slider').value = selectedSize;
                    document.getElementById('size-display').textContent = selectedSize + 'px';
                    document.getElementById('size-preview').style.fontSize = selectedSize + 'px';
                });
            });

            // Handle slider input
            const slider = document.getElementById('size-slider');
            slider.addEventListener('input', (e) => {
                selectedSize = parseInt(e.target.value);

                // Clear preset button selection
                menu.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));

                // Update all displays
                document.getElementById('size-display').textContent = selectedSize + 'px';
                document.getElementById('size-preview').style.fontSize = selectedSize + 'px';
                document.getElementById('custom-size-input').value = selectedSize;
            });

            // Handle custom size input
            const customInput = document.getElementById('custom-size-input');
            customInput.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                if (value >= 1) { // No upper limit - go nuts!
                    selectedSize = value;

                    // Clear preset button selection
                    menu.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));

                    // Update slider and displays
                    document.getElementById('size-slider').value = Math.min(selectedSize, 300); // Slider max is 300
                    document.getElementById('size-display').textContent = selectedSize + 'px';
                    document.getElementById('size-preview').style.fontSize = selectedSize + 'px';
                }
            });

            // Handle apply button
            document.getElementById('size-apply-btn').addEventListener('click', () => {
                addPendingChange(elementId, `${elementId}CustomFontSize`, selectedSize + 'px');
                menu.remove();
            });

            // Handle cancel button
            document.getElementById('size-cancel-btn').addEventListener('click', () => {
                menu.remove();
            });

            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closeSizeMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeSizeMenu);
                    }
                });
            }, 100);
        }

        // Get element visibility state
        function getElementVisibility(elementId) {
            // Map element IDs to their visibility config properties
            const visibilityMap = {
                'clock': config.showClock !== false,
                'date': config.showDate !== false,
                'source': config.showSourceIndicator !== false,
                'counter': config.showPhotoCounter !== false,
                'metadataOverlay': config.showMetadata !== false
            };
            return visibilityMap[elementId] !== false;
        }

        // Toggle element visibility
        function toggleElementVisibility(elementId) {
            const isVisible = getElementVisibility(elementId);
            const newVisibility = !isVisible;

            // Map element IDs to their show config properties
            const propertyMap = {
                'clock': 'showClock',
                'date': 'showDate',
                'source': 'showSourceIndicator',
                'counter': 'showPhotoCounter',
                'metadataOverlay': 'showMetadata'
            };

            const property = propertyMap[elementId];
            if (property) {
                // Add to pending changes
                addPendingChange(elementId, property, newVisibility);

                // Apply immediately for preview
                const element = document.getElementById(elementId);
                if (element) {
                    if (newVisibility) {
                        // Show the element
                        element.style.display = (elementId === 'counter' || elementId === 'source' ? 'flex' : 'block');
                        element.style.opacity = '';
                        element.classList.remove('editor-hidden');
                    } else {
                        // In editor mode, keep hidden elements visible but semi-transparent
                        if (config.editorMode) {
                            element.style.opacity = '0.3';
                            element.classList.add('editor-hidden');
                            // Keep display property so element is still interactable
                        } else {
                            element.style.display = 'none';
                        }
                    }
                }

                // Close context menu
                const menu = document.getElementById('context-menu');
                if (menu) menu.remove();

                // Show feedback
                console.log(`${elementId} visibility changed to: ${newVisibility ? 'visible' : 'hidden'}`);
            }
        }

        // Global Element Menu for empty space
        function showGlobalElementMenu(x, y) {
            // Remove any existing menu
            const existingMenu = document.getElementById('context-menu');
            if (existingMenu) existingMenu.remove();

            // Create context menu
            const menu = document.createElement('div');
            menu.id = 'context-menu';
            menu.style.cssText = `
                position: fixed;
                left: ${x}px;
                top: ${y}px;
                background: rgba(32, 34, 37, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                padding: 8px 0;
                min-width: 250px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
                z-index: 10001;
                color: white;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                font-size: 14px;
            `;

            // Add header
            const header = document.createElement('div');
            header.style.cssText = `
                padding: 8px 16px;
                font-weight: 600;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                margin-bottom: 4px;
            `;
            header.textContent = 'ðŸŽ¨ Manage Elements';
            menu.appendChild(header);

            // Define all elements
            const elementList = [
                { id: 'clock', name: 'ðŸ• Clock', property: 'showClock' },
                { id: 'date', name: 'ðŸ“… Date', property: 'showDate' },
                { id: 'counter', name: 'ðŸ”¢ Photo Counter', property: 'showPhotoCounter' },
                { id: 'source', name: 'ðŸ“ Source Indicator', property: 'showSourceIndicator' },
                { id: 'metadataOverlay', name: 'ðŸ“· Metadata', property: 'showMetadata' }
            ];

            // Create toggle for each element
            elementList.forEach(elem => {
                const isVisible = getElementVisibility(elem.id);
                const menuItem = document.createElement('div');
                menuItem.style.cssText = `
                    padding: 10px 16px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    transition: background-color 0.2s ease;
                `;

                menuItem.innerHTML = `
                    <span>${elem.name}</span>
                    <span style="
                        background: ${isVisible ? 'rgba(46, 204, 113, 0.9)' : 'rgba(231, 76, 60, 0.9)'};
                        color: white;
                        padding: 2px 8px;
                        border-radius: 12px;
                        font-size: 12px;
                        font-weight: 500;
                    ">${isVisible ? 'Visible' : 'Hidden'}</span>
                `;

                menuItem.addEventListener('mouseenter', () => {
                    menuItem.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                });

                menuItem.addEventListener('mouseleave', () => {
                    menuItem.style.backgroundColor = 'transparent';
                });

                menuItem.addEventListener('click', () => {
                    toggleElementVisibility(elem.id);
                    menu.remove();
                    // Reopen menu to show updated states
                    setTimeout(() => showGlobalElementMenu(x, y), 100);
                });

                menu.appendChild(menuItem);
            });

            document.body.appendChild(menu);

            // Close menu when clicking outside
            setTimeout(() => {
                function closeMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                    }
                }
                document.addEventListener('click', closeMenu);
            }, 100);
        }

        // Time Format Menu (Clock only)
        function showTimeFormatMenu(elementId) {
            console.log(`Show time format menu for ${elementId}`);

            // Remove any existing menu
            const existingMenu = document.getElementById('time-format-menu');
            if (existingMenu) existingMenu.remove();

            // Get current format
            const currentFormat = config.clockFormat || '24hour';
            const currentAmPmCase = config.clockAmPmCase || 'uppercase';
            const currentAmPmSize = config.clockAmPmSize || '80';
            const currentAmPmSpacing = config.clockAmPmSpacing || '1';
            const currentClockAlignment = config.clockAlignment || 'left';

            // Create time format menu
            const menu = document.createElement('div');
            menu.id = 'time-format-menu';
            menu.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: rgba(32, 34, 37, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 20px;
                min-width: 300px;
                max-width: 90vw;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                z-index: 10002;
                color: white;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            `;

            menu.innerHTML = `
                <h3 style="margin: 0 0 15px 0; font-size: 18px; font-weight: 600;">ðŸ• Time Format</h3>

                <div style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px;">
                    <label style="display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 6px; cursor: pointer; transition: background-color 0.2s ease;" class="format-option" data-format="12hour">
                        <input type="radio" name="timeFormat" value="12hour" ${currentFormat === '12hour' ? 'checked' : ''} style="margin: 0;">
                        <div style="flex: 1;">
                            <div style="font-weight: 500;">12-Hour Format</div>
                            <div style="font-size: 12px; color: rgba(255,255,255,0.7);">Example: 2:30 PM</div>
                        </div>
                    </label>

                    <label style="display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 6px; cursor: pointer; transition: background-color 0.2s ease;" class="format-option" data-format="24hour">
                        <input type="radio" name="timeFormat" value="24hour" ${currentFormat === '24hour' ? 'checked' : ''} style="margin: 0;">
                        <div style="flex: 1;">
                            <div style="font-weight: 500;">24-Hour Format</div>
                            <div style="font-size: 12px; color: rgba(255,255,255,0.7);">Example: 14:30</div>
                        </div>
                    </label>
                </div>

                <div id="ampm-options" style="margin-bottom: 20px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); display: ${currentFormat === '12hour' ? 'block' : 'none'};">
                    <h4 style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: rgba(255,255,255,0.8);">ðŸ…°ï¸ AM/PM Options</h4>

                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <div>
                            <label style="display: block; font-size: 12px; color: rgba(255,255,255,0.7); margin-bottom: 5px;">Case Style:</label>
                            <select id="ampm-case" style="width: 100%; padding: 6px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: white; font-size: 14px;">
                                <option value="uppercase" ${(config.clockAmPmCase || 'uppercase') === 'uppercase' ? 'selected' : ''}>UPPERCASE (AM/PM)</option>
                                <option value="lowercase" ${(config.clockAmPmCase || 'uppercase') === 'lowercase' ? 'selected' : ''}>lowercase (am/pm)</option>
                            </select>
                        </div>

                        <div>
                            <label style="display: block; font-size: 12px; color: rgba(255,255,255,0.7); margin-bottom: 5px;">Size (% of clock):</label>
                            <input type="number" id="ampm-size" value="${config.clockAmPmSize || '80'}" min="30" max="150" step="5" style="width: 100%; padding: 6px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: white; font-size: 14px;">
                        </div>

                        <div>
                            <label style="display: block; font-size: 12px; color: rgba(255,255,255,0.7); margin-bottom: 5px;">Spacing (characters):</label>
                            <input type="number" id="ampm-spacing" value="${config.clockAmPmSpacing || '1'}" min="0" max="3" step="0.1" style="width: 100%; padding: 6px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: white; font-size: 14px;">
                        </div>
                    </div>
                </div>

                <div style="margin-bottom: 20px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <h4 style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: rgba(255,255,255,0.8);">âš–ï¸ Text Alignment</h4>

                    <div>
                        <label style="display: block; font-size: 12px; color: rgba(255,255,255,0.7); margin-bottom: 5px;">Alignment:</label>
                        <select id="clock-alignment" style="width: 100%; padding: 6px; background: rgba(255,255,255,0.9); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: black; font-size: 14px;">
                            <option value="left" style="color: black;" ${(config.clockAlignment || 'left') === 'left' ? 'selected' : ''}>Left Align</option>
                            <option value="center" style="color: black;" ${(config.clockAlignment || 'left') === 'center' ? 'selected' : ''}>Center Align</option>
                            <option value="right" style="color: black;" ${(config.clockAlignment || 'left') === 'right' ? 'selected' : ''}>Right Align</option>
                        </select>
                    </div>
                </div>

                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="format-cancel-btn" style="padding: 8px 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: white; cursor: pointer; font-size: 14px;">Cancel</button>
                    <button id="format-apply-btn" style="padding: 8px 16px; background: #4A90E2; border: 1px solid #4A90E2; border-radius: 4px; color: white; cursor: pointer; font-size: 14px; font-weight: 500;">Apply</button>
                </div>
            `;

            // Add hover effects
            const style = document.createElement('style');
            style.textContent = `
                .format-option:hover {
                    background: rgba(255,255,255,0.05);
                }
                .format-option input:checked + div {
                    color: #4A90E2;
                }
                #format-apply-btn:hover, #format-cancel-btn:hover {
                    opacity: 0.8;
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(menu);

            let selectedFormat = currentFormat;
            let selectedAmPmCase = currentAmPmCase;
            let selectedAmPmSize = currentAmPmSize;
            let selectedAmPmSpacing = currentAmPmSpacing;
            let selectedClockAlignment = currentClockAlignment;

            // Handle format selection
            menu.querySelectorAll('input[name="timeFormat"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    selectedFormat = e.target.value;
                    // Show/hide AM/PM options based on format
                    const amPmOptions = document.getElementById('amPmOptions');
                    if (selectedFormat === '12hour') {
                        amPmOptions.style.display = 'block';
                    } else {
                        amPmOptions.style.display = 'none';
                    }
                });
            });

            // Handle AM/PM case selection
            const amPmCaseSelect = document.getElementById('ampm-case');
            if (amPmCaseSelect) {
                amPmCaseSelect.addEventListener('change', (e) => {
                    selectedAmPmCase = e.target.value;
                });
            }

            // Handle AM/PM size input
            const amPmSizeInput = document.getElementById('ampm-size');
            if (amPmSizeInput) {
                amPmSizeInput.addEventListener('input', (e) => {
                    selectedAmPmSize = e.target.value;
                });
            }

            // Handle AM/PM spacing input
            const amPmSpacingInput = document.getElementById('ampm-spacing');
            if (amPmSpacingInput) {
                amPmSpacingInput.addEventListener('input', (e) => {
                    selectedAmPmSpacing = e.target.value;
                });
            }

            // Handle clock alignment selection
            const clockAlignmentSelect = document.getElementById('clock-alignment');
            if (clockAlignmentSelect) {
                clockAlignmentSelect.addEventListener('change', (e) => {
                    selectedClockAlignment = e.target.value;
                });
            }

            // Handle apply button
            document.getElementById('format-apply-btn').addEventListener('click', () => {
                addPendingChange(elementId, 'clockFormat', selectedFormat);
                addPendingChange(elementId, 'clockAlignment', selectedClockAlignment);
                if (selectedFormat === '12hour') {
                    addPendingChange(elementId, 'clockAmPmCase', selectedAmPmCase);
                    addPendingChange(elementId, 'clockAmPmSize', selectedAmPmSize);
                    addPendingChange(elementId, 'clockAmPmSpacing', selectedAmPmSpacing);
                }
                menu.remove();
                style.remove();
            });

            // Handle cancel button
            document.getElementById('format-cancel-btn').addEventListener('click', () => {
                menu.remove();
                style.remove();
            });

            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closeFormatMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        style.remove();
                        document.removeEventListener('click', closeFormatMenu);
                    }
                });
            }, 100);
        }

        // Date Format Menu
        function showDateFormatMenu(elementId) {
            console.log(`Show date format menu for ${elementId}`);

            // Remove any existing menu
            const existingMenu = document.getElementById('date-format-menu');
            if (existingMenu) existingMenu.remove();

            // Get current alignment
            const currentDateAlignment = config.dateAlignment || 'left';

            // Create date format menu
            const menu = document.createElement('div');
            menu.id = 'date-format-menu';
            menu.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: rgba(32, 34, 37, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 20px;
                min-width: 300px;
                max-width: 90vw;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                z-index: 10002;
                color: white;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            `;

            menu.innerHTML = `
                <h3 style="margin: 0 0 15px 0; font-size: 18px; font-weight: 600;">ðŸ“… Date Format</h3>

                <div style="margin-bottom: 20px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <h4 style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: rgba(255,255,255,0.8);">âš–ï¸ Text Alignment</h4>
                    <p style="margin: 0 0 15px 0; font-size: 12px; color: rgba(255,255,255,0.6);">Choose alignment to prevent date from shifting when content length changes.</p>

                    <div>
                        <label style="display: block; font-size: 12px; color: rgba(255,255,255,0.7); margin-bottom: 5px;">Alignment:</label>
                        <select id="date-alignment" style="width: 100%; padding: 6px; background: rgba(255,255,255,0.9); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: black; font-size: 14px;">
                            <option value="left" style="color: black;" ${(config.dateAlignment || 'left') === 'left' ? 'selected' : ''}>Left Align</option>
                            <option value="center" style="color: black;" ${(config.dateAlignment || 'left') === 'center' ? 'selected' : ''}>Center Align</option>
                            <option value="right" style="color: black;" ${(config.dateAlignment || 'left') === 'right' ? 'selected' : ''}>Right Align</option>
                        </select>
                    </div>
                </div>

                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="date-format-cancel-btn" style="padding: 8px 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: white; cursor: pointer; font-size: 14px;">Cancel</button>
                    <button id="date-format-apply-btn" style="padding: 8px 16px; background: #4A90E2; border: 1px solid #4A90E2; border-radius: 4px; color: white; cursor: pointer; font-size: 14px; font-weight: 500;">Apply</button>
                </div>
            `;

            // Add hover effects
            const style = document.createElement('style');
            style.textContent = `
                #date-format-apply-btn:hover, #date-format-cancel-btn:hover {
                    opacity: 0.8;
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(menu);

            let selectedDateAlignment = currentDateAlignment;

            // Handle date alignment selection
            const dateAlignmentSelect = document.getElementById('date-alignment');
            if (dateAlignmentSelect) {
                dateAlignmentSelect.addEventListener('change', (e) => {
                    selectedDateAlignment = e.target.value;
                });
            }

            // Handle apply button
            document.getElementById('date-format-apply-btn').addEventListener('click', () => {
                addPendingChange(elementId, 'dateAlignment', selectedDateAlignment);
                menu.remove();
                style.remove();
            });

            // Handle cancel button
            document.getElementById('date-format-cancel-btn').addEventListener('click', () => {
                menu.remove();
                style.remove();
            });

            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closeDateFormatMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        style.remove();
                        document.removeEventListener('click', closeDateFormatMenu);
                    }
                });
            }, 100);
        }

        // Color Menu
        function showColorMenu(elementId) {
            console.log(`Show color menu for ${elementId}`);

            // Remove any existing menu
            const existingMenu = document.getElementById('color-menu');
            if (existingMenu) existingMenu.remove();

            // Create color menu
            const menu = document.createElement('div');
            menu.id = 'color-menu';
            menu.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: rgba(32, 34, 37, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 20px;
                width: 320px;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                z-index: 10002;
                color: white;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            `;

            // Get current colors
            const currentTextColor = getCurrentElementTextColor(elementId);
            const currentBgColor = getCurrentElementBgColor(elementId);

            menu.innerHTML = `
                <div style="margin-bottom: 16px; font-weight: 600; color: #4A90E2;">ðŸŽ¨ Colors - ${elementId}</div>

                <!-- Text Color -->
                <div style="margin-bottom: 16px;">
                    <div style="margin-bottom: 8px; font-size: 13px; color: #ccc;">Text Color:</div>
                    <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 12px;">
                        <input type="color" id="text-color-picker" value="${currentTextColor}"
                               style="width: 40px; height: 40px; border: none; border-radius: 6px; cursor: pointer; background: none;">
                        <input type="text" id="text-color-hex" value="${currentTextColor}" placeholder="#FFFFFF"
                               style="flex: 1; padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: white; font-size: 14px; font-family: monospace;">
                    </div>
                    <!-- Text Color Presets -->
                    <div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 6px;">
                        <div class="color-preset" data-color="#ffffff" style="background: #ffffff;" title="White"></div>
                        <div class="color-preset" data-color="#f0f0f0" style="background: #f0f0f0;" title="Light Gray"></div>
                        <div class="color-preset" data-color="#cccccc" style="background: #cccccc;" title="Gray"></div>
                        <div class="color-preset" data-color="#888888" style="background: #888888;" title="Dark Gray"></div>
                        <div class="color-preset" data-color="#000000" style="background: #000000; border: 1px solid #555;" title="Black"></div>
                        <div class="color-preset" data-color="#4A90E2" style="background: #4A90E2;" title="Blue"></div>
                        <div class="color-preset" data-color="#7ED321" style="background: #7ED321;" title="Green"></div>
                        <div class="color-preset" data-color="#F5A623" style="background: #F5A623;" title="Orange"></div>
                    </div>
                </div>

                <!-- Background Color -->
                <div style="margin-bottom: 16px;">
                    <div style="margin-bottom: 8px; font-size: 13px; color: #ccc;">Background Color:</div>
                    <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 12px;">
                        <input type="color" id="bg-color-picker" value="${currentBgColor}"
                               style="width: 40px; height: 40px; border: none; border-radius: 6px; cursor: pointer; background: none;">
                        <input type="text" id="bg-color-hex" value="${currentBgColor}" placeholder="#000000"
                               style="flex: 1; padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: white; font-size: 14px; font-family: monospace;">
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 12px;">
                            <input type="checkbox" id="bg-enabled" ${currentBgColor !== 'transparent' ? 'checked' : ''}>
                            Enable
                        </label>
                    </div>
                    <!-- Background Color Presets -->
                    <div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 6px;">
                        <div class="bg-color-preset" data-color="transparent" style="background: repeating-linear-gradient(45deg, #555, #555 4px, #333 4px, #333 8px);" title="Transparent"></div>
                        <div class="bg-color-preset" data-color="#000000" style="background: #000000; border: 1px solid #555;" title="Black"></div>
                        <div class="bg-color-preset" data-color="#333333" style="background: #333333;" title="Dark Gray"></div>
                        <div class="bg-color-preset" data-color="#666666" style="background: #666666;" title="Gray"></div>
                        <div class="bg-color-preset" data-color="#ffffff" style="background: #ffffff;" title="White"></div>
                        <div class="bg-color-preset" data-color="#4A90E2" style="background: #4A90E2;" title="Blue"></div>
                        <div class="bg-color-preset" data-color="#7ED321" style="background: #7ED321;" title="Green"></div>
                        <div class="bg-color-preset" data-color="#F5A623" style="background: #F5A623;" title="Orange"></div>
                    </div>
                </div>

                <!-- Preview -->
                <div style="margin-bottom: 16px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 6px; text-align: center;">
                    <div id="color-preview" style="color: ${currentTextColor}; background: ${currentBgColor}; padding: 8px; border-radius: 4px; transition: all 0.2s ease;">Sample Text</div>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; gap: 8px; justify-content: flex-end;">
                    <button id="color-cancel-btn" style="padding: 8px 16px; background: transparent; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; color: white; cursor: pointer;">Cancel</button>
                    <button id="color-apply-btn" style="padding: 8px 16px; background: #4A90E2; border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600;">Apply</button>
                </div>
            `;

            // Add color preset styles
            const style = document.createElement('style');
            style.textContent = `
                .color-preset, .bg-color-preset {
                    width: 24px;
                    height: 24px;
                    border-radius: 4px;
                    cursor: pointer;
                    border: 2px solid transparent;
                    transition: all 0.2s ease;
                }
                .color-preset:hover, .bg-color-preset:hover {
                    border-color: #4A90E2;
                    transform: scale(1.1);
                }
                .color-preset.active, .bg-color-preset.active {
                    border-color: #4A90E2;
                    box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.3);
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(menu);

            let selectedTextColor = currentTextColor;
            let selectedBgColor = currentBgColor;

            // Update preview function
            function updatePreview() {
                const preview = document.getElementById('color-preview');
                const bgEnabled = document.getElementById('bg-enabled').checked;
                preview.style.color = selectedTextColor;
                preview.style.background = bgEnabled ? selectedBgColor : 'transparent';
            }

            // Text color picker sync
            document.getElementById('text-color-picker').addEventListener('input', (e) => {
                selectedTextColor = e.target.value;
                document.getElementById('text-color-hex').value = selectedTextColor;
                updatePreview();
            });

            document.getElementById('text-color-hex').addEventListener('input', (e) => {
                const color = e.target.value;
                if (/^#[0-9A-F]{6}$/i.test(color)) {
                    selectedTextColor = color;
                    document.getElementById('text-color-picker').value = selectedTextColor;
                    updatePreview();
                }
            });

            // Background color picker sync
            document.getElementById('bg-color-picker').addEventListener('input', (e) => {
                selectedBgColor = e.target.value;
                document.getElementById('bg-color-hex').value = selectedBgColor;
                document.getElementById('bg-enabled').checked = true;
                updatePreview();
            });

            document.getElementById('bg-color-hex').addEventListener('input', (e) => {
                const color = e.target.value;
                if (/^#[0-9A-F]{6}$/i.test(color)) {
                    selectedBgColor = color;
                    document.getElementById('bg-color-picker').value = selectedBgColor;
                    updatePreview();
                }
            });

            // Background enable/disable
            document.getElementById('bg-enabled').addEventListener('change', updatePreview);

            // Text color presets
            menu.querySelectorAll('.color-preset').forEach(preset => {
                preset.addEventListener('click', () => {
                    selectedTextColor = preset.dataset.color;
                    document.getElementById('text-color-picker').value = selectedTextColor;
                    document.getElementById('text-color-hex').value = selectedTextColor;
                    updatePreview();
                });
            });

            // Background color presets
            menu.querySelectorAll('.bg-color-preset').forEach(preset => {
                preset.addEventListener('click', () => {
                    selectedBgColor = preset.dataset.color;
                    if (selectedBgColor === 'transparent') {
                        document.getElementById('bg-enabled').checked = false;
                    } else {
                        document.getElementById('bg-color-picker').value = selectedBgColor;
                        document.getElementById('bg-color-hex').value = selectedBgColor;
                        document.getElementById('bg-enabled').checked = true;
                    }
                    updatePreview();
                });
            });

            // Handle apply button
            document.getElementById('color-apply-btn').addEventListener('click', () => {
                addPendingChange(elementId, `${elementId}Color`, selectedTextColor);

                const bgEnabled = document.getElementById('bg-enabled').checked;
                if (bgEnabled) {
                    addPendingChange(elementId, `${elementId}Background`, true);
                    addPendingChange(elementId, `${elementId}BackgroundColor`, selectedBgColor);
                } else {
                    addPendingChange(elementId, `${elementId}Background`, false);
                }

                menu.remove();
            });

            // Handle cancel button
            document.getElementById('color-cancel-btn').addEventListener('click', () => {
                menu.remove();
            });

            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closeColorMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeColorMenu);
                    }
                });
            }, 100);
        }

        // Opacity Menu
        function showOpacityMenu(elementId) {
            console.log(`Show opacity menu for ${elementId}`);

            // Remove any existing menu
            const existingMenu = document.getElementById('opacity-menu');
            if (existingMenu) existingMenu.remove();

            // Create opacity menu
            const menu = document.createElement('div');
            menu.id = 'opacity-menu';
            menu.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: rgba(32, 34, 37, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 20px;
                min-width: 300px;
                max-width: 90vw;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                z-index: 10002;
                color: white;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            `;

            // Get current opacity values
            const currentTextOpacity = getCurrentElementOpacity(elementId);
            const currentBgOpacity = getCurrentElementBgOpacity(elementId);

            menu.innerHTML = `
                <div style="margin-bottom: 16px; font-weight: 600; color: #4A90E2;">ðŸ‘ï¸ Opacity - ${elementId}</div>

                <!-- Text Opacity -->
                <div style="margin-bottom: 16px;">
                    <div style="margin-bottom: 8px; font-size: 13px; color: #ccc;">Text Opacity:</div>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <span style="font-size: 12px; color: #888;">0%</span>
                        <input type="range" id="text-opacity-slider" min="0" max="100" value="${currentTextOpacity}"
                               style="flex: 1; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; outline: none;">
                        <span style="font-size: 12px; color: #888;">100%</span>
                    </div>
                    <div style="text-align: center; margin-top: 8px;">
                        <span id="text-opacity-display" style="color: #4A90E2; font-weight: 600;">${currentTextOpacity}%</span>
                    </div>
                </div>

                <!-- Background Opacity -->
                <div style="margin-bottom: 16px;">
                    <div style="margin-bottom: 8px; font-size: 13px; color: #ccc;">Background Opacity:</div>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <span style="font-size: 12px; color: #888;">0%</span>
                        <input type="range" id="bg-opacity-slider" min="0" max="100" value="${currentBgOpacity}"
                               style="flex: 1; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; outline: none;">
                        <span style="font-size: 12px; color: #888;">100%</span>
                    </div>
                    <div style="text-align: center; margin-top: 8px;">
                        <span id="bg-opacity-display" style="color: #4A90E2; font-weight: 600;">${currentBgOpacity}%</span>
                    </div>
                </div>

                <!-- Quick Presets -->
                <div style="margin-bottom: 16px;">
                    <div style="margin-bottom: 8px; font-size: 13px; color: #ccc;">Quick Presets:</div>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        <button class="opacity-preset-btn" data-text="25" data-bg="10">Subtle</button>
                        <button class="opacity-preset-btn" data-text="50" data-bg="30">Medium</button>
                        <button class="opacity-preset-btn" data-text="75" data-bg="50">Bold</button>
                        <button class="opacity-preset-btn" data-text="100" data-bg="80">Full</button>
                        <button class="opacity-preset-btn" data-text="0" data-bg="0">Hidden</button>
                    </div>
                </div>

                <!-- Preview -->
                <div style="margin-bottom: 16px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 6px; text-align: center; position: relative;">
                    <div id="opacity-preview-bg" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: #333; border-radius: 6px; opacity: ${currentBgOpacity / 100};"></div>
                    <div id="opacity-preview-text" style="position: relative; z-index: 1; color: white; opacity: ${currentTextOpacity / 100}; transition: opacity 0.2s ease;">Sample Text</div>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; gap: 8px; justify-content: flex-end;">
                    <button id="opacity-cancel-btn" style="padding: 8px 16px; background: transparent; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; color: white; cursor: pointer;">Cancel</button>
                    <button id="opacity-apply-btn" style="padding: 8px 16px; background: #4A90E2; border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600;">Apply</button>
                </div>
            `;

            // Add preset button styles
            const style = document.createElement('style');
            style.textContent = `
                .opacity-preset-btn {
                    padding: 6px 8px;
                    background: rgba(255,255,255,0.1);
                    border: 1px solid rgba(255,255,255,0.2);
                    border-radius: 4px;
                    color: white;
                    cursor: pointer;
                    font-size: 12px;
                    transition: all 0.2s ease;
                }
                .opacity-preset-btn:hover {
                    background: rgba(74, 144, 226, 0.3);
                    border-color: rgba(74, 144, 226, 0.6);
                }
                #text-opacity-slider::-webkit-slider-thumb, #bg-opacity-slider::-webkit-slider-thumb {
                    appearance: none;
                    width: 16px;
                    height: 16px;
                    border-radius: 50%;
                    background: #4A90E2;
                    cursor: pointer;
                }
                #text-opacity-slider::-moz-range-thumb, #bg-opacity-slider::-moz-range-thumb {
                    width: 16px;
                    height: 16px;
                    border-radius: 50%;
                    background: #4A90E2;
                    cursor: pointer;
                    border: none;
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(menu);

            let selectedTextOpacity = currentTextOpacity;
            let selectedBgOpacity = currentBgOpacity;

            // Update preview function
            function updateOpacityPreview() {
                document.getElementById('opacity-preview-text').style.opacity = selectedTextOpacity / 100;
                document.getElementById('opacity-preview-bg').style.opacity = selectedBgOpacity / 100;
            }

            // Text opacity slider
            document.getElementById('text-opacity-slider').addEventListener('input', (e) => {
                selectedTextOpacity = parseInt(e.target.value);
                document.getElementById('text-opacity-display').textContent = selectedTextOpacity + '%';
                updateOpacityPreview();
            });

            // Background opacity slider
            document.getElementById('bg-opacity-slider').addEventListener('input', (e) => {
                selectedBgOpacity = parseInt(e.target.value);
                document.getElementById('bg-opacity-display').textContent = selectedBgOpacity + '%';
                updateOpacityPreview();
            });

            // Preset buttons
            menu.querySelectorAll('.opacity-preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    selectedTextOpacity = parseInt(btn.dataset.text);
                    selectedBgOpacity = parseInt(btn.dataset.bg);

                    // Update sliders and displays
                    document.getElementById('text-opacity-slider').value = selectedTextOpacity;
                    document.getElementById('bg-opacity-slider').value = selectedBgOpacity;
                    document.getElementById('text-opacity-display').textContent = selectedTextOpacity + '%';
                    document.getElementById('bg-opacity-display').textContent = selectedBgOpacity + '%';

                    updateOpacityPreview();
                });
            });

            // Handle apply button
            document.getElementById('opacity-apply-btn').addEventListener('click', () => {
                addPendingChange(elementId, `${elementId}Opacity`, selectedTextOpacity);
                addPendingChange(elementId, `${elementId}BackgroundOpacity`, selectedBgOpacity);
                menu.remove();
            });

            // Handle cancel button
            document.getElementById('opacity-cancel-btn').addEventListener('click', () => {
                menu.remove();
            });

            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closeOpacityMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeOpacityMenu);
                    }
                });
            }, 100);
        }

        // Background Menu
        function showBackgroundMenu(elementId) {
            console.log(`Show background menu for ${elementId}`);

            // Remove any existing menu
            const existingMenu = document.getElementById('background-menu');
            if (existingMenu) existingMenu.remove();

            // Create background menu
            const menu = document.createElement('div');
            menu.id = 'background-menu';
            menu.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: rgba(32, 34, 37, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 20px;
                width: 320px;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                z-index: 10002;
                color: white;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            `;

            // Get current background settings
            const currentBorderRadius = config[`${elementId}BorderRadius`] || 0;
            const currentPadding = config[`${elementId}Padding`] || 0;
            const currentShadow = config[`${elementId}Shadow`] || 0;
            const currentBackground = config[`${elementId}Background`] || 'dark';
            const backgroundEnabled = currentBackground !== 'none';

            menu.innerHTML = `
                <div style="margin-bottom: 16px; font-weight: 600; color: #4A90E2;">ðŸŽ­ Background - ${elementId}</div>

                <!-- Background Enable -->
                <div style="margin-bottom: 16px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="bg-enable-checkbox" ${backgroundEnabled ? 'checked' : ''}>
                        <span>Enable Background</span>
                    </label>
                </div>

                <!-- Border Radius -->
                <div style="margin-bottom: 16px;">
                    <div style="margin-bottom: 8px; font-size: 13px; color: #ccc;">Border Radius:</div>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <span style="font-size: 12px; color: #888;">0px</span>
                        <input type="range" id="border-radius-slider" min="0" max="30" value="${currentBorderRadius}"
                               style="flex: 1; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; outline: none;">
                        <span style="font-size: 12px; color: #888;">30px</span>
                    </div>
                    <div style="text-align: center; margin-top: 8px;">
                        <span id="border-radius-display" style="color: #4A90E2; font-weight: 600;">${currentBorderRadius}px</span>
                    </div>
                </div>

                <!-- Padding -->
                <div style="margin-bottom: 16px;">
                    <div style="margin-bottom: 8px; font-size: 13px; color: #ccc;">Padding:</div>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <span style="font-size: 12px; color: #888;">0px</span>
                        <input type="range" id="padding-slider" min="0" max="40" value="${currentPadding}"
                               style="flex: 1; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; outline: none;">
                        <span style="font-size: 12px; color: #888;">40px</span>
                    </div>
                    <div style="text-align: center; margin-top: 8px;">
                        <span id="padding-display" style="color: #4A90E2; font-weight: 600;">${currentPadding}px</span>
                    </div>
                </div>

                <!-- Shadow -->
                <div style="margin-bottom: 16px;">
                    <div style="margin-bottom: 8px; font-size: 13px; color: #ccc;">Shadow Blur:</div>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <span style="font-size: 12px; color: #888;">0px</span>
                        <input type="range" id="shadow-slider" min="0" max="20" value="${currentShadow}"
                               style="flex: 1; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; outline: none;">
                        <span style="font-size: 12px; color: #888;">20px</span>
                    </div>
                    <div style="text-align: center; margin-top: 8px;">
                        <span id="shadow-display" style="color: #4A90E2; font-weight: 600;">${currentShadow}px</span>
                    </div>
                </div>

                <!-- Style Presets -->
                <div style="margin-bottom: 16px;">
                    <div style="margin-bottom: 8px; font-size: 13px; color: #ccc;">Style Presets:</div>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                        <button class="bg-preset-btn" data-radius="0" data-padding="0" data-shadow="0">None</button>
                        <button class="bg-preset-btn" data-radius="4" data-padding="8" data-shadow="2">Subtle</button>
                        <button class="bg-preset-btn" data-radius="8" data-padding="12" data-shadow="4">Modern</button>
                        <button class="bg-preset-btn" data-radius="12" data-padding="16" data-shadow="8">Rounded</button>
                        <button class="bg-preset-btn" data-radius="20" data-padding="20" data-shadow="12">Pill</button>
                        <button class="bg-preset-btn" data-radius="6" data-padding="10" data-shadow="15">Bold</button>
                    </div>
                </div>

                <!-- Preview -->
                <div style="margin-bottom: 16px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 6px; text-align: center;">
                    <div id="bg-preview" style="
                        color: white;
                        background: ${backgroundEnabled ? 'rgba(0,0,0,0.6)' : 'transparent'};
                        border-radius: ${currentBorderRadius}px;
                        padding: ${currentPadding}px;
                        box-shadow: 0 0 ${currentShadow}px rgba(0,0,0,0.8);
                        transition: all 0.2s ease;
                        display: inline-block;
                    ">Sample Text</div>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; gap: 8px; justify-content: flex-end;">
                    <button id="bg-cancel-btn" style="padding: 8px 16px; background: transparent; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; color: white; cursor: pointer;">Cancel</button>
                    <button id="bg-apply-btn" style="padding: 8px 16px; background: #4A90E2; border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600;">Apply</button>
                </div>
            `;

            // Add preset button styles
            const style = document.createElement('style');
            style.textContent = `
                .bg-preset-btn {
                    padding: 8px 6px;
                    background: rgba(255,255,255,0.1);
                    border: 1px solid rgba(255,255,255,0.2);
                    border-radius: 4px;
                    color: white;
                    cursor: pointer;
                    font-size: 12px;
                    transition: all 0.2s ease;
                }
                .bg-preset-btn:hover {
                    background: rgba(74, 144, 226, 0.3);
                    border-color: rgba(74, 144, 226, 0.6);
                }
                #border-radius-slider::-webkit-slider-thumb,
                #padding-slider::-webkit-slider-thumb,
                #shadow-slider::-webkit-slider-thumb {
                    appearance: none;
                    width: 16px;
                    height: 16px;
                    border-radius: 50%;
                    background: #4A90E2;
                    cursor: pointer;
                }
                #border-radius-slider::-moz-range-thumb,
                #padding-slider::-moz-range-thumb,
                #shadow-slider::-moz-range-thumb {
                    width: 16px;
                    height: 16px;
                    border-radius: 50%;
                    background: #4A90E2;
                    cursor: pointer;
                    border: none;
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(menu);

            let selectedBorderRadius = currentBorderRadius;
            let selectedPadding = currentPadding;
            let selectedShadow = currentShadow;
            let bgEnabled = backgroundEnabled;

            // Update preview function
            function updateBgPreview() {
                const preview = document.getElementById('bg-preview');
                preview.style.background = bgEnabled ? 'rgba(0,0,0,0.6)' : 'transparent';
                preview.style.borderRadius = selectedBorderRadius + 'px';
                preview.style.padding = selectedPadding + 'px';
                preview.style.boxShadow = bgEnabled ? `0 0 ${selectedShadow}px rgba(0,0,0,0.8)` : 'none';
            }

            // Background enable checkbox
            document.getElementById('bg-enable-checkbox').addEventListener('change', (e) => {
                bgEnabled = e.target.checked;
                updateBgPreview();
            });

            // Border radius slider
            document.getElementById('border-radius-slider').addEventListener('input', (e) => {
                selectedBorderRadius = parseInt(e.target.value);
                document.getElementById('border-radius-display').textContent = selectedBorderRadius + 'px';
                updateBgPreview();
            });

            // Padding slider
            document.getElementById('padding-slider').addEventListener('input', (e) => {
                selectedPadding = parseInt(e.target.value);
                document.getElementById('padding-display').textContent = selectedPadding + 'px';
                updateBgPreview();
            });

            // Shadow slider
            document.getElementById('shadow-slider').addEventListener('input', (e) => {
                selectedShadow = parseInt(e.target.value);
                document.getElementById('shadow-display').textContent = selectedShadow + 'px';
                updateBgPreview();
            });

            // Preset buttons
            menu.querySelectorAll('.bg-preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    selectedBorderRadius = parseInt(btn.dataset.radius);
                    selectedPadding = parseInt(btn.dataset.padding);
                    selectedShadow = parseInt(btn.dataset.shadow);

                    // Update sliders and displays
                    document.getElementById('border-radius-slider').value = selectedBorderRadius;
                    document.getElementById('padding-slider').value = selectedPadding;
                    document.getElementById('shadow-slider').value = selectedShadow;
                    document.getElementById('border-radius-display').textContent = selectedBorderRadius + 'px';
                    document.getElementById('padding-display').textContent = selectedPadding + 'px';
                    document.getElementById('shadow-display').textContent = selectedShadow + 'px';

                    // Enable background if using a preset with values > 0
                    if (selectedBorderRadius > 0 || selectedPadding > 0 || selectedShadow > 0) {
                        bgEnabled = true;
                        document.getElementById('bg-enable-checkbox').checked = true;
                    }

                    updateBgPreview();
                });
            });

            // Handle apply button
            document.getElementById('bg-apply-btn').addEventListener('click', () => {
                // Convert boolean to proper background value
                const backgroundValue = bgEnabled ? (currentBackground === 'none' ? 'dark' : currentBackground) : 'none';
                addPendingChange(elementId, `${elementId}Background`, backgroundValue);
                addPendingChange(elementId, `${elementId}BorderRadius`, selectedBorderRadius);
                addPendingChange(elementId, `${elementId}Padding`, selectedPadding);
                addPendingChange(elementId, `${elementId}Shadow`, selectedShadow);
                menu.remove();
            });

            // Handle cancel button
            document.getElementById('bg-cancel-btn').addEventListener('click', () => {
                menu.remove();
            });

            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closeBgMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeBgMenu);
                    }
                });
            }, 100);
        }

        // Helper Functions for Context Menus
        function getCurrentElementPosition(elementId) {
            // Map elementId to config position property
            const positionMap = {
                'clock': config.clockPosition || 'top-left',
                'date': config.datePosition || 'top-right',
                'source': config.sourcePosition || 'bottom-left',
                'counter': config.counterPosition || 'bottom-right',
                'metadataOverlay': config.metadataPosition || 'bottom-right'
            };
            return positionMap[elementId] || 'top-left';
        }

        function highlightCurrentPosition(position) {
            // This would highlight the current position preset in the menu
            // Implementation depends on position menu structure
        }

        function getCurrentElementFontSize(elementId) {
            // Map elementId to config font size property
            const sizeMap = {
                'clock': config.clockCustomFontSize || 24,
                'date': config.dateCustomFontSize || 18,
                'source': config.sourceCustomFontSize || 14,
                'counter': config.counterCustomFontSize || 16,
                'metadataOverlay': config.metadataCustomFontSize || 14
            };
            return parseInt(sizeMap[elementId]) || 18;
        }

        function getCurrentElementTextColor(elementId) {
            // Map elementId to config color property
            const colorMap = {
                'clock': config.clockColor || '#ffffff',
                'date': config.dateColor || '#ffffff',
                'source': config.sourceColor || '#ffffff',
                'counter': config.counterColor || '#ffffff',
                'metadataOverlay': config.metadataColor || '#ffffff'
            };
            return colorMap[elementId] || '#ffffff';
        }

        function getCurrentElementBgColor(elementId) {
            // Map elementId to config background color property
            const bgColorMap = {
                'clock': config.clockBackgroundColor || '#000000',
                'date': config.dateBackgroundColor || '#000000',
                'source': config.sourceBackgroundColor || '#000000',
                'counter': config.counterBackgroundColor || '#000000',
                'metadataOverlay': config.metadataBackgroundColor || '#000000'
            };

            // Check if background is enabled
            const bgEnabledMap = {
                'clock': config.clockBackground,
                'date': config.dateBackground,
                'source': config.sourceBackground,
                'counter': config.counterBackground,
                'metadataOverlay': config.metadataBackground
            };

            return bgEnabledMap[elementId] ? bgColorMap[elementId] : 'transparent';
        }

        function getCurrentElementOpacity(elementId) {
            // Map elementId to config opacity property
            const opacityMap = {
                'clock': config.clockOpacity || 100,
                'date': config.dateOpacity || 100,
                'source': config.sourceOpacity || 100,
                'counter': config.counterOpacity || 100,
                'metadataOverlay': config.metadataOpacity || 100
            };
            return parseInt(opacityMap[elementId]) || 100;
        }

        function getCurrentElementBgOpacity(elementId) {
            // Map elementId to config background opacity property
            const bgOpacityMap = {
                'clock': config.clockBackgroundOpacity || 80,
                'date': config.dateBackgroundOpacity || 80,
                'source': config.sourceBackgroundOpacity || 80,
                'counter': config.counterBackgroundOpacity || 80,
                'metadataOverlay': config.metadataBackgroundOpacity || 80
            };
            return parseInt(bgOpacityMap[elementId]) || 80;
        }

        // Pending Changes Management System
        let pendingChanges = {};
        let originalConfig = {};

        function startEditorSession() {
            // Store original configuration for potential rollback
            originalConfig = JSON.parse(JSON.stringify(config));
            pendingChanges = {};
            warningShown = false; // Reset warning flag for new session
            updateSaveButtonState();
        }

        function addPendingChange(elementId, property, value) {
            // Check for excessive pending changes to prevent memory issues
            const totalChanges = Object.keys(pendingChanges).reduce((count, id) =>
                count + Object.keys(pendingChanges[id]).length, 0);

            // Show warning popup at 75 changes
            if (totalChanges >= 75 && totalChanges < 100) {
                showChangeWarningPopup(totalChanges);
            }

            if (totalChanges > 100) {
                console.warn('Too many pending changes (>100), auto-saving to prevent memory issues');
                saveAllChanges();
                return;
            }

            if (!pendingChanges[elementId]) {
                pendingChanges[elementId] = {};
            }
            pendingChanges[elementId][property] = value;

            // Update the UI immediately for preview
            applyChangePreview(elementId, property, value);
            updateSaveButtonState();
            updateStatusText();
        }

        function applyChangePreview(elementId, property, value) {
            // Apply change to local config for immediate visual feedback
            config[property] = value;

            // Re-render the element with new config
            if (elementId === 'clock') {
                applyClock();
            } else if (elementId === 'date') {
                applyDate();
            } else if (elementId === 'source') {
                applySourceIndicatorPosition();
            } else if (elementId === 'counter') {
                applyPhotoCounterPosition();
            } else if (elementId === 'metadataOverlay') {
                updateMetadataStyles();
            }
        }

        function updateSaveButtonState() {
            const saveBtn = document.getElementById('save-changes-btn');
            const hasChanges = Object.keys(pendingChanges).length > 0;

            if (saveBtn) {
                saveBtn.disabled = !hasChanges;
                saveBtn.style.opacity = hasChanges ? '1' : '0.5';
                saveBtn.style.cursor = hasChanges ? 'pointer' : 'not-allowed';
            }
        }

        function updateStatusText() {
            const statusElement = document.getElementById('editor-status');
            const changeCount = Object.keys(pendingChanges).length;

            if (statusElement) {
                if (changeCount === 0) {
                    statusElement.textContent = 'Editor Mode Active - Right-click elements to customize';
                } else {
                    statusElement.textContent = `${changeCount} unsaved change${changeCount === 1 ? '' : 's'} - Right-click to continue editing`;
                }
            }
        }

        let warningShown = false;

        function showChangeWarningPopup(changeCount) {
            // Only show once per editor session
            if (warningShown) return;
            warningShown = true;

            // Create popup HTML
            const popup = document.createElement('div');
            popup.id = 'change-warning-popup';
            popup.innerHTML = `
                <div class="warning-content">
                    <div class="warning-icon">âš ï¸</div>
                    <div class="warning-text">
                        <h3>Approaching Change Limit</h3>
                        <p>${changeCount} changes pending. Save now to prevent performance issues.</p>
                    </div>
                    <div class="warning-buttons">
                        <button id="warning-save-btn" class="warning-btn save">Save Now</button>
                        <button id="warning-dismiss-btn" class="warning-btn dismiss">Continue</button>
                    </div>
                </div>
            `;

            document.body.appendChild(popup);

            // Add event listeners
            document.getElementById('warning-save-btn').addEventListener('click', () => {
                popup.remove();
                saveAllChanges();
            });

            document.getElementById('warning-dismiss-btn').addEventListener('click', () => {
                popup.remove();
            });

            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (popup.parentNode) {
                    popup.remove();
                }
            }, 10000);

            // Animate in
            setTimeout(() => {
                popup.classList.add('show');
            }, 100);
        }

        function mapPropertyToMQTTTopic(elementId, property) {
            // Map element properties to MQTT topics based on existing integration patterns
            const topicBase = 'touchkio/kiosk/';

            // Position mappings
            if (property.includes('Position')) {
                return `${topicBase}${elementId}_position/set`;
            }
            if (property.includes('CustomX')) {
                return `${topicBase}${elementId}_custom_x/set`;
            }
            if (property.includes('CustomY')) {
                return `${topicBase}${elementId}_custom_y/set`;
            }

            // Font size
            if (property.includes('CustomFontSize')) {
                return `${topicBase}${elementId}_custom_font_size/set`;
            }

            // Colors
            if (property.includes('Color') && !property.includes('Background')) {
                return `${topicBase}${elementId}_color/set`;
            }
            if (property.includes('BackgroundColor')) {
                return `${topicBase}${elementId}_background_color/set`;
            }

            // Opacity
            if (property.includes('Opacity') && !property.includes('Background')) {
                return `${topicBase}${elementId}_opacity/set`;
            }
            if (property.includes('BackgroundOpacity')) {
                return `${topicBase}${elementId}_background_opacity/set`;
            }

            // Background styles
            if (property.includes('Background') && !property.includes('Color') && !property.includes('Opacity')) {
                return `${topicBase}${elementId}_background/set`;
            }
            if (property.includes('BorderRadius')) {
                return `${topicBase}${elementId}_border_radius/set`;
            }
            if (property.includes('Padding')) {
                return `${topicBase}${elementId}_padding/set`;
            }
            if (property.includes('Shadow')) {
                return `${topicBase}${elementId}_shadow/set`;
            }

            return null;
        }

        function saveAllChanges() {
            console.log('ðŸš€ SAVE STARTED: saveAllChanges function called!');

            // Check for too many changes that could cause performance issues
            const changeCount = Object.keys(pendingChanges).length;
            if (changeCount > 50) {
                console.warn(`Warning: Large number of changes (${changeCount}), processing carefully`);
            }

            console.log('Pending changes count:', changeCount);
            console.log('Pending changes object:', pendingChanges);

            if (changeCount === 0) {
                console.log('No pending changes to save, returning early');
                return;
            }

            console.log('Saving all pending changes:', pendingChanges);

            // Apply all changes directly to config
            console.log('ðŸ” DEBUG: Applying pending changes to config');
            console.log('  Current config.counterCustomX:', config.counterCustomX);
            console.log('  Current config.counterCustomY:', config.counterCustomY);

            Object.entries(pendingChanges).forEach(([elementId, changes]) => {
                console.log(`  Processing element: ${elementId}`);
                Object.entries(changes).forEach(([property, value]) => {
                    // Apply change to config
                    config[property] = value;
                    console.log(`ðŸ”§ CONFIG UPDATED: Applied config['${property}'] = '${value}'`);
                    if (property.includes('counter')) {
                        console.log(`    âš ï¸ Counter property detected: ${property}`);
                    }
                });
            });

            console.log('  After changes - config.counterCustomX:', config.counterCustomX);
            console.log('  After changes - config.counterCustomY:', config.counterCustomY);

            // Re-render all elements with new config
            applyClock();
            applyDate();
            applySourceIndicatorPosition();
            applyPhotoCounterPosition();
            updateMetadataStyles();

            // Send settings to integration.js for MQTT persistence BEFORE clearing
            const settingsUpdate = {};

            Object.entries(pendingChanges).forEach(([elementId, changes]) => {
                Object.entries(changes).forEach(([property, value]) => {
                    // Map to MQTT setting names (same as existing integration)
                    let mqttKey = '';

                    // Fix element ID mapping for MQTT keys
                    let mqttElementId = elementId;
                    if (elementId === 'metadataOverlay') {
                        mqttElementId = 'metadata';
                    }

                    if (property.includes('Position')) {
                        mqttKey = `slideshow_${mqttElementId}_position`;
                    } else if (property.includes('CustomX')) {
                        mqttKey = `slideshow_${mqttElementId}_custom_x`;
                        console.log(`    ðŸ“ Mapping CustomX: ${property} -> ${mqttKey}`);
                    } else if (property.includes('CustomY')) {
                        mqttKey = `slideshow_${mqttElementId}_custom_y`;
                        console.log(`    ðŸ“ Mapping CustomY: ${property} -> ${mqttKey}`);
                    } else if (property.includes('CustomFontSize')) {
                        mqttKey = `slideshow_${mqttElementId}_custom_font_size`;
                    } else if (property.includes('Color') && !property.includes('Background')) {
                        mqttKey = `slideshow_${mqttElementId}_color`;
                    } else if (property.includes('BackgroundColor')) {
                        mqttKey = `slideshow_${mqttElementId}_background_color`;
                    } else if (property.includes('Opacity') && !property.includes('Background')) {
                        mqttKey = `slideshow_${mqttElementId}_opacity`;
                    } else if (property.includes('BackgroundOpacity')) {
                        mqttKey = `slideshow_${mqttElementId}_background_opacity`;
                    } else if (property.includes('Background') && !property.includes('Color') && !property.includes('Opacity')) {
                        mqttKey = `slideshow_${mqttElementId}_background`;
                        // Handle both boolean and string background values
                        if (typeof value === 'boolean') {
                            value = value ? 'ON' : 'OFF';
                        }
                        // String values like 'dark', 'none' pass through unchanged
                    } else if (property.includes('BorderRadius')) {
                        mqttKey = `slideshow_${mqttElementId}_border_radius`;
                    } else if (property.includes('Padding')) {
                        mqttKey = `slideshow_${mqttElementId}_padding`;
                    } else if (property.includes('Shadow')) {
                        mqttKey = `slideshow_${mqttElementId}_shadow`;
                    } else if (property === 'clockFormat') {
                        mqttKey = `slideshow_clock_format`;
                    } else if (property === 'clockAmPmCase') {
                        mqttKey = `slideshow_clock_am_pm_case`;
                    } else if (property === 'clockAmPmSize') {
                        mqttKey = `slideshow_clock_am_pm_size`;
                    } else if (property === 'clockAmPmSpacing') {
                        mqttKey = `slideshow_clock_am_pm_spacing`;
                    } else if (property === 'clockAlignment') {
                        mqttKey = `slideshow_clock_alignment`;
                    } else if (property === 'dateAlignment') {
                        mqttKey = `slideshow_date_alignment`;
                    } else if (property === 'showClock') {
                        mqttKey = `slideshow_show_clock`;
                    } else if (property === 'showDate') {
                        mqttKey = `slideshow_show_date`;
                    } else if (property === 'showSourceIndicator') {
                        mqttKey = `slideshow_show_source`;
                    } else if (property === 'showPhotoCounter') {
                        mqttKey = `slideshow_show_counter`;
                    } else if (property === 'showMetadata') {
                        mqttKey = `slideshow_show_metadata`;
                    }

                    if (mqttKey) {
                        settingsUpdate[mqttKey] = value;
                        console.log(`Prepared setting: ${mqttKey} = ${value}`);
                    }
                });
            });

            // Send to main process via proper IPC with better error handling
            if (Object.keys(settingsUpdate).length > 0) {
                console.log('About to send IPC message with settings:', settingsUpdate);
                try {
                    ipcRenderer.send('editor-settings-update', settingsUpdate);
                    console.log('Successfully sent editor settings update via IPC');

                    // Clear pending changes only after successful send
                    pendingChanges = {};
                    updateSaveButtonState();
                    updateStatusText();

                    // Show success feedback and exit editor mode
                    const statusElement = document.getElementById('editor-status');
                    if (statusElement) {
                        statusElement.textContent = `âœ… ${changeCount} change${changeCount === 1 ? '' : 's'} saved to MQTT!`;
                        statusElement.style.color = '#46cc71';

                        setTimeout(() => {
                            // Exit editor mode after showing success message
                            exitEditorMode();
                        }, 1000);
                    } else {
                        // If no status element, exit immediately
                        exitEditorMode();
                    }
                } catch (error) {
                    console.error('Error sending IPC message:', error);
                    const statusElement = document.getElementById('editor-status');
                    if (statusElement) {
                        statusElement.textContent = `âŒ Failed to save changes - IPC error`;
                        statusElement.style.color = '#ff4757';
                    }
                    // Don't clear changes or exit if send failed
                    return;
                }
            } else {
                console.log('No settings to send via IPC');
                // Still clear changes if no settings were prepared
                pendingChanges = {};
                updateSaveButtonState();
                updateStatusText();
                exitEditorMode();
            }
        }

        function exitEditorMode() {
            // CRITICAL: Send backend signals first, then delay frontend cleanup to prevent flash
            try {
                ipcRenderer.send('editor-mode-disable');
                ipcRenderer.send('resume-normal-slideshow-operation');
                console.log('Sent editor mode disable and resume signals to main process');
            } catch (error) {
                console.error('Error sending editor mode signals:', error);
            }

            // Delay all frontend cleanup to happen after backend has stabilized
            setTimeout(() => {
                try {
                    // Exit editor mode by updating config directly and hiding UI
                    config.editorMode = false;

                    // Remove entire editor notification
                    const notification = document.getElementById('editor-notification');
                    if (notification) {
                        notification.remove();
                        console.log('Removed editor notification completely');
                    }

                    // Hide editor grid overlay
                    const gridOverlay = document.getElementById('editor-grid-overlay');
                    if (gridOverlay) gridOverlay.style.display = 'none';

                    // Remove context menu cursors and hover effects
                    document.querySelectorAll('.slideshow-element').forEach(element => {
                        element.style.cursor = 'none';
                        element.classList.remove('editor-element');
                        element.style.boxShadow = '';
                    });

                    // Re-enable activity detection
                    window.activityDetectionEnabled = true;

                    console.log('Editor mode frontend cleanup completed');
                } catch (error) {
                    console.error('Error during editor mode cleanup:', error);
                }
            }, 500); // Wait 500ms for backend to stabilize
        }

        function discardAllChanges() {
            const changeCount = Object.keys(pendingChanges).length;

            if (changeCount > 0) {
                try {
                    // Restore original configuration
                    config = JSON.parse(JSON.stringify(originalConfig));

                    // Re-apply all elements to restore original state
                    applyClock();
                    applyDate();
                    applySourceIndicatorPosition();
                    applyPhotoCounterPosition();
                    updateMetadataStyles();

                    console.log(`Discarded ${changeCount} pending changes`);
                } catch (error) {
                    console.error('Error restoring original config:', error);
                }
            }

            // Clear pending changes
            pendingChanges = {};

            // Exit editor mode (this will signal backend to resume normal operation)
            exitEditorMode();
        }

        // Save element position by updating config and persisting via postMessage
        function saveElementPosition(elementId, x, y) {
            console.log(`Saving ${elementId} position: (${x}, ${y})`);

            // Create position update message for main process
            const positionUpdate = {};

            // Map element IDs to MQTT setting names
            if (elementId === 'clock') {
                positionUpdate['slideshow_clock_custom_x'] = x + 'px';
                positionUpdate['slideshow_clock_custom_y'] = y + 'px';
            } else if (elementId === 'date') {
                positionUpdate['slideshow_date_custom_x'] = x + 'px';
                positionUpdate['slideshow_date_custom_y'] = y + 'px';
            } else if (elementId === 'source') {
                positionUpdate['slideshow_source_custom_x'] = x + 'px';
                positionUpdate['slideshow_source_custom_y'] = y + 'px';
            } else if (elementId === 'counter') {
                positionUpdate['slideshow_counter_custom_x'] = x + 'px';
                positionUpdate['slideshow_counter_custom_y'] = y + 'px';
            } else if (elementId === 'metadataOverlay') {
                positionUpdate['slideshow_metadata_custom_x'] = x + 'px';
                positionUpdate['slideshow_metadata_custom_y'] = y + 'px';
            }

            // Send to main process via postMessage
            window.postMessage({
                type: 'DRAG_POSITION_UPDATE',
                settings: positionUpdate
            }, '*');

            console.log(`Sent position update for ${elementId}:`, positionUpdate);

            // Also update local config to maintain position during this session
            const customXKey = `${elementId}CustomX`;
            const customYKey = `${elementId}CustomY`;
            config[customXKey] = x + 'px';
            config[customYKey] = y + 'px';
        }

        ipcRenderer.on('slideshow-config', (event, data) => {
            console.log('===== IPC MESSAGE RECEIVED =====');
            console.log('Received slideshow config:', data);
            console.log('Data type:', typeof data);
            console.log('Data keys:', Object.keys(data || {}));

            // Debug box removed - no longer needed

            if (data.config) {
                config = data.config;

                // Handle editor mode - simple immediate activation for testing
                if (config.editorMode !== undefined) {
                    console.log('Editor mode config received:', config.editorMode);

                    // Debug indicator removed - using blue notification instead

                    if (config.editorMode) {
                        // Show slideshow when editor mode is enabled
                        console.log('Making slideshow container visible for editor mode');
                        const slideshowContainer = document.querySelector('.slideshow-container');
                        if (slideshowContainer) {
                            slideshowContainer.style.display = 'flex';
                            slideshowContainer.style.visibility = 'visible';
                            slideshowContainer.style.opacity = '1';
                            console.log('Slideshow container made visible');
                        } else {
                            console.log('Slideshow container not found');
                        }

                        // Disable activity detection
                        window.activityDetectionEnabled = false;
                        // Backend handles slideshow timer management - no frontend timer control needed


                        // Start editor session (store original config for rollback)
                        startEditorSession();

                        // Add editor notification with save/discard buttons
                        if (!document.getElementById('editor-notification')) {
                            const notification = document.createElement('div');
                            notification.id = 'editor-notification';
                            notification.innerHTML = `
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <span id="editor-status">Editor Mode Active - Right-click elements to customize</span>
                                    <div style="display: flex; gap: 8px;">
                                        <button id="save-changes-btn" style="
                                            background: rgba(46, 204, 113, 0.9);
                                            color: white;
                                            border: none;
                                            padding: 6px 12px;
                                            border-radius: 15px;
                                            font-size: 12px;
                                            font-weight: 500;
                                            cursor: pointer;
                                            opacity: 0.5;
                                            transition: all 0.2s ease;
                                        " disabled>ðŸ’¾ Save Changes</button>
                                        <button id="discard-changes-btn" style="
                                            background: rgba(231, 76, 60, 0.9);
                                            color: white;
                                            border: none;
                                            padding: 6px 12px;
                                            border-radius: 15px;
                                            font-size: 12px;
                                            font-weight: 500;
                                            cursor: pointer;
                                            transition: all 0.2s ease;
                                        ">ðŸ—‘ï¸ Discard & Exit</button>
                                    </div>
                                </div>
                            `;
                            notification.style.cssText = `
                                position: fixed;
                                top: 20px;
                                left: 50%;
                                transform: translateX(-50%);
                                background: rgba(32, 34, 37, 0.95);
                                color: white;
                                padding: 12px 20px;
                                border-radius: 25px;
                                font-size: 14px;
                                font-weight: 500;
                                z-index: 10001;
                                backdrop-filter: blur(15px);
                                box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
                                border: 1px solid rgba(255, 255, 255, 0.1);
                            `;
                            document.body.appendChild(notification);

                            // Add button event listeners
                            console.log('Setting up save button event listener...');
                            const saveButton = document.getElementById('save-changes-btn');
                            const discardButton = document.getElementById('discard-changes-btn');

                            if (saveButton) {
                                console.log('Save button found, adding event listener');
                                saveButton.addEventListener('click', function() {
                                    console.log('Save button clicked!');
                                    saveAllChanges();
                                });
                            } else {
                                console.error('Save button not found!');
                            }

                            if (discardButton) {
                                console.log('Discard button found, adding event listener');
                                discardButton.addEventListener('click', discardAllChanges);
                            } else {
                                console.error('Discard button not found!');
                            }
                        }

                        // Show editor grid overlay
                        console.log('Showing editor grid overlay...');
                        const gridOverlay = document.getElementById('editor-grid-overlay');
                        if (gridOverlay) {
                            gridOverlay.style.display = 'block';
                            console.log('Editor grid overlay made visible');
                        } else {
                            console.log('ERROR: Editor grid overlay element not found');
                        }

                        // Show elements based on their visibility settings and make them draggable
                        ['clock', 'date', 'source', 'counter', 'metadataOverlay'].forEach(id => {
                            const element = document.getElementById(id);
                            if (element) {
                                // Check if element should be visible based on config
                                const visibilityMap = {
                                    'clock': config.showClock !== false,
                                    'date': config.showDate !== false,
                                    'source': config.showSourceIndicator !== false,
                                    'counter': config.showPhotoCounter !== false,
                                    'metadataOverlay': config.showMetadata !== false
                                };

                                if (visibilityMap[id]) {
                                    element.style.display = 'block';
                                    element.style.opacity = '1';
                                } else {
                                    // Keep hidden elements hidden but still editable
                                    element.style.display = 'none';
                                }

                                // Apply current positioning BEFORE making draggable
                                // This ensures metadata has proper position styles
                                if (id === 'metadataOverlay') {
                                    updateMetadataStyles();
                                }

                                // Make element context menu enabled
                                makeContextMenuEnabled(element, id);
                            }
                        });

                        // Add global context menu for empty space to manage all elements
                        document.addEventListener('contextmenu', function(e) {
                            if (!config.editorMode) return;

                            // Check if click is on empty space (not on an element)
                            const clickedElement = e.target;
                            const isEmptySpace = !clickedElement.classList.contains('editor-element') &&
                                                !clickedElement.closest('.editor-element') &&
                                                !clickedElement.id.match(/^(clock|date|source|counter|metadataOverlay)$/);

                            if (isEmptySpace) {
                                e.preventDefault();
                                showGlobalElementMenu(e.clientX, e.clientY);
                            }
                        });

                        // Touch and hold for empty space on mobile
                        let globalTouchTimer;
                        document.addEventListener('touchstart', function(e) {
                            if (!config.editorMode) return;

                            const touch = e.touches[0];
                            const clickedElement = document.elementFromPoint(touch.clientX, touch.clientY);
                            const isEmptySpace = !clickedElement.classList.contains('editor-element') &&
                                                !clickedElement.closest('.editor-element') &&
                                                !clickedElement.id.match(/^(clock|date|source|counter|metadataOverlay)$/);

                            if (isEmptySpace) {
                                globalTouchTimer = setTimeout(() => {
                                    showGlobalElementMenu(touch.clientX, touch.clientY);
                                    if (navigator.vibrate) navigator.vibrate(50);
                                }, 500);
                            }
                        });

                        document.addEventListener('touchend', function() {
                            if (globalTouchTimer) {
                                clearTimeout(globalTouchTimer);
                                globalTouchTimer = null;
                            }
                        });

                    } else {
                        // Deactivate editor mode - just re-enable activity detection

                        // Re-enable activity detection
                        window.activityDetectionEnabled = true;
                        // Backend handles slideshow timer management - no frontend timer restart needed


                        // Remove editor UI
                        const notification = document.getElementById('editor-notification');
                        if (notification) notification.remove();

                        // Hide editor grid overlay
                        const gridOverlay = document.getElementById('editor-grid-overlay');
                        if (gridOverlay) {
                            gridOverlay.style.display = 'none';
                            console.log('Editor grid overlay hidden');
                        }

                        // Remove drag functionality from elements
                        ['clock', 'date', 'source', 'counter', 'metadataOverlay'].forEach(id => {
                            const element = document.getElementById(id);
                            if (element) {
                                element.style.cursor = '';
                                element.style.transition = '';
                                element.style.boxShadow = '';
                                element.style.transform = '';
                                // Note: Event listeners will be cleaned up by checking config.editorMode
                            }
                        });

                        // Don't hide slideshow - just let normal activity detection handle it
                    }
                }

                // Clock and date configuration
                applyClock();
                applyDate();
                initializeClock();

                // Source indicator configuration
                const sourceIndicator = document.querySelector('.source-indicator');
                if (config.showSourceIndicator !== false) {
                    sourceIndicator.style.display = 'flex';
                    const sourcePos = config.sourcePosition || 'top-left';

                    // Apply proper styling via the dedicated function (handles all positioning including custom)
                    applySourceIndicatorPosition();
                } else {
                    sourceIndicator.style.display = 'none';
                }

                // Photo counter configuration
                const photoCounter = document.querySelector('.photo-counter');
                if (config.showPhotoCounter) {
                    photoCounter.style.display = 'flex';
                    const counterPos = config.counterPosition || 'bottom-left';

                    // Apply proper styling via the dedicated function (handles all positioning including custom)
                    applyPhotoCounterPosition();
                } else {
                    photoCounter.style.display = 'none';
                }

                // Metadata overlay configuration
                const metadataOverlay = document.querySelector('.metadata-overlay');
                if (config.showMetadata) {
                    // Update all metadata styles when config changes
                    updateMetadataStyles();
                    // Metadata visibility will be handled by updateMetadataDisplay when photos are shown
                } else {
                    metadataOverlay.style.display = 'none';
                }

                // Photo fit configuration - only update if it changed
                if (data.config.photoFit !== undefined) {
                    const photos = document.querySelectorAll('.photo');
                    photos.forEach(photo => {
                        // Preserve the visible state when updating photo fit
                        const wasVisible = photo.classList.contains('visible');
                        photo.className = `photo fit-${config.photoFit || 'contain'}`;
                        if (wasVisible) {
                            photo.classList.add('visible');
                        }
                    });
                }

                // Apply transition type - only update if it changed
                if (data.config.transitionType !== undefined) {
                    const container = document.querySelector('.slideshow-container');
                    container.className = `slideshow-container transition-${config.transitionType || 'fade'}`;
                }
            }

            if (data.photos) {
                photos = data.photos;
                updatePhotoCounter(currentIndex, photos.length);

                if (photos.length === 0) {
                    elements.noPhotos.style.display = 'block';
                }
            }
        });

        ipcRenderer.on('show-photo', (event, photoData) => {
            showPhoto(photoData);
        });

        // Delay before enabling activity detection to prevent false triggers
        window.activityDetectionEnabled = false;
        setTimeout(() => {
            window.activityDetectionEnabled = true;
            console.log('Activity detection enabled');
        }, 1000); // Wait 1 second before enabling

        // Aggressive event capture for VNC and remote clicks
        const triggerUserActivity = () => {
            if (window.activityDetectionEnabled) {
                console.log('User activity detected in slideshow');
                ipcRenderer.send('slideshow-user-activity');
            }
        };

        // Capture clicks on all elements
        document.addEventListener('click', triggerUserActivity, true);
        document.addEventListener('mousedown', triggerUserActivity, true);
        document.addEventListener('mouseup', triggerUserActivity, true);

        document.addEventListener('keydown', triggerUserActivity);

        // Throttled mousemove to prevent too many events
        let mouseMoveTimeout;
        let lastMouseX = 0;
        let lastMouseY = 0;
        document.addEventListener('mousemove', (e) => {
            // Only trigger on significant mouse movement
            const deltaX = Math.abs(e.clientX - lastMouseX);
            const deltaY = Math.abs(e.clientY - lastMouseY);

            if (deltaX > 10 || deltaY > 10) {
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;

                if (!mouseMoveTimeout) {
                    mouseMoveTimeout = setTimeout(() => {
                        triggerUserActivity();
                        mouseMoveTimeout = null;
                    }, 100);
                }
            }
        });

        document.addEventListener('touchstart', triggerUserActivity);

        // Also detect clicks on the slideshow container specifically
        document.querySelector('.slideshow-container').addEventListener('click', triggerUserActivity, true);

        window.addEventListener('beforeunload', () => {
            if (clockInterval) {
                clearInterval(clockInterval);
            }
        });

        // Create function to apply source indicator styling
        function applySourceIndicatorPosition() {
            const sourceIndicator = document.querySelector('.source-indicator');
            if (config.showSourceIndicator && sourceIndicator) {
                sourceIndicator.style.display = 'flex';
                const sourcePos = config.sourcePosition || 'top-left';
                const sourceBackground = config.sourceBackground || 'dark';

                // Apply classes for background only (no size/font-size classes needed)
                sourceIndicator.className = `source-indicator background-${sourceBackground}`;

                // Apply custom font size if specified
                if (config.sourceCustomFontSize && config.sourceCustomFontSize.trim() !== '') {
                    sourceIndicator.style.fontSize = config.sourceCustomFontSize;
                } else {
                    sourceIndicator.style.fontSize = ''; // Clear custom font size
                }

                sourceIndicator.style.position = 'absolute';
                sourceIndicator.style.zIndex = '10';
                sourceIndicator.style.top = 'auto';
                sourceIndicator.style.right = 'auto';
                sourceIndicator.style.bottom = 'auto';
                sourceIndicator.style.left = 'auto';
                sourceIndicator.style.transform = 'none';

                // Check if custom coordinates are provided
                const hasCustomX = config.sourceCustomX && config.sourceCustomX.toString().trim() !== '';
                const hasCustomY = config.sourceCustomY && config.sourceCustomY.toString().trim() !== '';

                console.log('Source positioning debug:', {
                    sourceCustomX: config.sourceCustomX,
                    sourceCustomY: config.sourceCustomY,
                    hasCustomX,
                    hasCustomY,
                    sourcePosition: sourcePos
                });

                if (hasCustomX || hasCustomY) {
                    // Use custom positioning - clear preset styles first
                    sourceIndicator.style.top = 'auto';
                    sourceIndicator.style.right = 'auto';
                    sourceIndicator.style.bottom = 'auto';
                    sourceIndicator.style.left = 'auto';
                    sourceIndicator.style.transform = 'none';

                    if (hasCustomX) {
                        sourceIndicator.style.left = config.sourceCustomX;
                    }
                    if (hasCustomY) {
                        sourceIndicator.style.top = config.sourceCustomY;
                    }
                } else {
                    // Use preset position - clear all custom positioning first
                    sourceIndicator.style.top = 'auto';
                    sourceIndicator.style.right = 'auto';
                    sourceIndicator.style.bottom = 'auto';
                    sourceIndicator.style.left = 'auto';
                    sourceIndicator.style.transform = 'none';

                    switch(sourcePos) {
                        case 'top-left':
                            sourceIndicator.style.top = '20px';
                            sourceIndicator.style.left = '20px';
                            break;
                        case 'top-center':
                            sourceIndicator.style.top = '20px';
                            sourceIndicator.style.left = '50%';
                            sourceIndicator.style.transform = 'translateX(-50%)';
                            break;
                        case 'top-right':
                            sourceIndicator.style.top = '20px';
                            sourceIndicator.style.right = '20px';
                            break;
                        case 'left':
                            sourceIndicator.style.top = '50%';
                            sourceIndicator.style.left = '20px';
                            sourceIndicator.style.transform = 'translateY(-50%)';
                            break;
                        case 'center':
                            sourceIndicator.style.top = '50%';
                            sourceIndicator.style.left = '50%';
                            sourceIndicator.style.transform = 'translate(-50%, -50%)';
                            break;
                        case 'right':
                            sourceIndicator.style.top = '50%';
                            sourceIndicator.style.right = '20px';
                            sourceIndicator.style.transform = 'translateY(-50%)';
                            break;
                        case 'bottom-left':
                            sourceIndicator.style.bottom = '20px';
                            sourceIndicator.style.left = '20px';
                            break;
                        case 'bottom-center':
                            sourceIndicator.style.bottom = '20px';
                            sourceIndicator.style.left = '50%';
                            sourceIndicator.style.transform = 'translateX(-50%)';
                            break;
                        case 'bottom-right':
                            sourceIndicator.style.bottom = '20px';
                            sourceIndicator.style.right = '20px';
                            break;
                        case 'custom':
                            // Custom position handled above, do nothing here
                            break;
                    }
                }

                // Apply custom color if specified
                if (config.sourceColor) {
                    sourceIndicator.style.color = config.sourceColor;
                }

                // Apply background opacity if background is not 'none'
                if (sourceBackground !== 'none' && config.sourceBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(sourceIndicator).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.sourceBackgroundOpacity / 100;
                            sourceIndicator.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                sourceIndicator.style.opacity = config.sourceOpacity || 0.8;

                // Apply advanced styling options
                if (config.sourceBorderRadius && config.sourceBorderRadius.trim() !== '') {
                    sourceIndicator.style.borderRadius = config.sourceBorderRadius;
                } else {
                    sourceIndicator.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.sourcePadding && config.sourcePadding.trim() !== '') {
                    sourceIndicator.style.padding = config.sourcePadding;
                } else {
                    sourceIndicator.style.padding = ''; // Clear custom padding
                }

                if (config.sourceShadow && config.sourceShadow.trim() !== '') {
                    sourceIndicator.style.boxShadow = config.sourceShadow;
                } else {
                    sourceIndicator.style.boxShadow = ''; // Clear custom shadow
                }
            } else if (sourceIndicator) {
                sourceIndicator.style.display = 'none';
            }
        }

        // Create function to apply clock styling
        function applyClock() {
            const clock = elements.clock;
            if (config.showClock && clock) {
                clock.style.display = 'block';
                const clockPos = config.clockPosition || 'bottom-right';
                const clockBackground = config.clockBackground || 'dark';
                const clockFontSize = config.clockFontSize || 'medium';

                // Apply classes for background and font size (if no custom size)
                if (config.clockCustomFontSize) {
                    clock.className = `clock background-${clockBackground} pos-${clockPos}`;
                    clock.style.fontSize = config.clockCustomFontSize;
                } else {
                    clock.className = `clock background-${clockBackground} font-size-${clockFontSize} pos-${clockPos}`;
                }

                // Apply positioning - use custom coordinates if provided, otherwise use preset positions
                clock.style.position = 'absolute';
                clock.style.zIndex = '10';
                clock.style.top = 'auto';
                clock.style.right = 'auto';
                clock.style.bottom = 'auto';
                clock.style.left = 'auto';
                clock.style.transform = 'none';

                // Check if custom coordinates are provided (handle empty strings and undefined)
                const hasCustomX = config.clockCustomX && config.clockCustomX.toString().trim() !== '';
                const hasCustomY = config.clockCustomY && config.clockCustomY.toString().trim() !== '';

                console.log('Clock positioning debug:', {
                    clockCustomX: config.clockCustomX,
                    clockCustomY: config.clockCustomY,
                    hasCustomX,
                    hasCustomY
                });

                if (hasCustomX || hasCustomY) {
                    // Use custom positioning - clear preset styles first
                    clock.style.top = 'auto';
                    clock.style.right = 'auto';
                    clock.style.bottom = 'auto';
                    clock.style.left = 'auto';
                    clock.style.transform = 'none';

                    if (hasCustomX) {
                        clock.style.left = config.clockCustomX;
                        console.log('Applied custom clock X:', config.clockCustomX);
                    }
                    if (hasCustomY) {
                        clock.style.top = config.clockCustomY;
                        console.log('Applied custom clock Y:', config.clockCustomY);
                    }
                } else {
                    // Use preset position - clear all custom positioning first
                    clock.style.top = 'auto';
                    clock.style.right = 'auto';
                    clock.style.bottom = 'auto';
                    clock.style.left = 'auto';
                    clock.style.transform = 'none';

                    switch(clockPos) {
                        case 'top-left':
                            clock.style.top = '20px';
                            clock.style.left = '20px';
                            break;
                        case 'top-center':
                            clock.style.top = '20px';
                            clock.style.left = '50%';
                            clock.style.transform = 'translateX(-50%)';
                            break;
                        case 'top-right':
                            clock.style.top = '20px';
                            clock.style.right = '20px';
                            break;
                        case 'left':
                            clock.style.top = '50%';
                            clock.style.left = '20px';
                            clock.style.transform = 'translateY(-50%)';
                            break;
                        case 'center':
                            clock.style.top = '50%';
                            clock.style.left = '50%';
                            clock.style.transform = 'translate(-50%, -50%)';
                            break;
                        case 'right':
                            clock.style.top = '50%';
                            clock.style.right = '20px';
                            clock.style.transform = 'translateY(-50%)';
                            break;
                        case 'bottom-left':
                            clock.style.bottom = '20px';
                            clock.style.left = '20px';
                            break;
                        case 'bottom-center':
                            clock.style.bottom = '20px';
                            clock.style.left = '50%';
                            clock.style.transform = 'translateX(-50%)';
                            break;
                        case 'bottom-right':
                            clock.style.bottom = '20px';
                            clock.style.right = '20px';
                            break;
                        case 'custom':
                            // Custom position handled above, do nothing here
                            break;
                    }
                }

                // Apply custom color if specified
                if (config.clockColor) {
                    clock.style.color = config.clockColor;
                }

                // Apply background opacity if background is not 'none'
                if (clockBackground !== 'none' && config.clockBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(clock).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.clockBackgroundOpacity / 100;
                            clock.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                clock.style.opacity = config.clockOpacity || 1.0;

                // Apply text alignment
                if (config.clockAlignment) {
                    clock.style.textAlign = config.clockAlignment;
                } else {
                    clock.style.textAlign = 'left'; // Default to left alignment
                }

                // Apply advanced styling options
                if (config.clockBorderRadius && config.clockBorderRadius.trim() !== '') {
                    clock.style.borderRadius = config.clockBorderRadius;
                } else {
                    clock.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.clockPadding && config.clockPadding.trim() !== '') {
                    clock.style.padding = config.clockPadding;
                } else {
                    clock.style.padding = ''; // Clear custom padding
                }

                if (config.clockShadow && config.clockShadow.trim() !== '') {
                    clock.style.boxShadow = config.clockShadow;
                } else {
                    clock.style.boxShadow = ''; // Clear custom shadow
                }
            } else if (clock) {
                clock.style.display = 'none';
            }
        }

        // Create function to apply date styling
        function applyDate() {
            const date = elements.date;
            if (config.showDate !== false && date) {
                date.style.display = 'block';
                const datePos = config.datePosition || 'bottom-left';
                const dateBackground = config.dateBackground || 'dark';
                const dateFontSize = config.dateFontSize || 'medium';

                // Apply classes for background and position only
                if (config.dateCustomFontSize && config.dateCustomFontSize.trim() !== '') {
                    date.className = `date background-${dateBackground} pos-${datePos}`;
                    date.style.fontSize = config.dateCustomFontSize;
                } else {
                    date.className = `date background-${dateBackground} pos-${datePos}`;
                    date.style.fontSize = ''; // Clear custom font size
                }

                // Apply positioning - use custom coordinates if provided, otherwise use preset positions
                date.style.position = 'absolute';
                date.style.zIndex = '10';
                date.style.top = 'auto';
                date.style.right = 'auto';
                date.style.bottom = 'auto';
                date.style.left = 'auto';
                date.style.transform = 'none';

                // Check if custom coordinates are provided
                const hasCustomX = config.dateCustomX && config.dateCustomX.trim() !== '';
                const hasCustomY = config.dateCustomY && config.dateCustomY.trim() !== '';

                if (hasCustomX || hasCustomY) {
                    // Use custom positioning - clear preset styles first
                    date.style.top = 'auto';
                    date.style.right = 'auto';
                    date.style.bottom = 'auto';
                    date.style.left = 'auto';
                    date.style.transform = 'none';

                    if (hasCustomX) {
                        date.style.left = config.dateCustomX;
                    }
                    if (hasCustomY) {
                        date.style.top = config.dateCustomY;
                    }
                } else {
                    // Use preset position - clear all custom positioning first
                    date.style.top = 'auto';
                    date.style.right = 'auto';
                    date.style.bottom = 'auto';
                    date.style.left = 'auto';
                    date.style.transform = 'none';

                    switch(datePos) {
                        case 'top-left':
                            date.style.top = '20px';
                            date.style.left = '20px';
                            break;
                        case 'top-center':
                            date.style.top = '20px';
                            date.style.left = '50%';
                            date.style.transform = 'translateX(-50%)';
                            break;
                        case 'top-right':
                            date.style.top = '20px';
                            date.style.right = '20px';
                            break;
                        case 'left':
                            date.style.top = '50%';
                            date.style.left = '20px';
                            date.style.transform = 'translateY(-50%)';
                            break;
                        case 'center':
                            date.style.top = '50%';
                            date.style.left = '50%';
                            date.style.transform = 'translate(-50%, -50%)';
                            break;
                        case 'right':
                            date.style.top = '50%';
                            date.style.right = '20px';
                            date.style.transform = 'translateY(-50%)';
                            break;
                        case 'bottom-left':
                            date.style.bottom = '20px';
                            date.style.left = '20px';
                            break;
                        case 'bottom-center':
                            date.style.bottom = '20px';
                            date.style.left = '50%';
                            date.style.transform = 'translateX(-50%)';
                            break;
                        case 'bottom-right':
                            date.style.bottom = '20px';
                            date.style.right = '20px';
                            break;
                        case 'custom':
                            // Custom position handled above, do nothing here
                            break;
                    }
                }

                // Apply custom color if specified
                if (config.dateColor) {
                    date.style.color = config.dateColor;
                }

                // Apply background opacity if background is not 'none'
                if (dateBackground !== 'none' && config.dateBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(date).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.dateBackgroundOpacity / 100;
                            date.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                date.style.opacity = config.dateOpacity || 0.8;

                // Apply text alignment
                if (config.dateAlignment) {
                    date.style.textAlign = config.dateAlignment;
                } else {
                    date.style.textAlign = 'left'; // Default to left alignment
                }

                // Apply advanced styling options
                if (config.dateBorderRadius && config.dateBorderRadius.trim() !== '') {
                    date.style.borderRadius = config.dateBorderRadius;
                } else {
                    date.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.datePadding && config.datePadding.trim() !== '') {
                    date.style.padding = config.datePadding;
                } else {
                    date.style.padding = ''; // Clear custom padding
                }

                if (config.dateShadow && config.dateShadow.trim() !== '') {
                    date.style.boxShadow = config.dateShadow;
                } else {
                    date.style.boxShadow = ''; // Clear custom shadow
                }
            } else if (date) {
                date.style.display = 'none';
            }
        }

        // Create function to apply photo counter styling
        function applyPhotoCounterPosition() {
            const photoCounter = document.querySelector('.photo-counter');
            if (config.showPhotoCounter && photoCounter) {
                photoCounter.style.display = 'flex';
                const counterPos = config.counterPosition || 'bottom-left';
                const counterBackground = config.counterBackground || 'dark';

                // Apply classes for background only (no size/font-size classes needed)
                photoCounter.className = `photo-counter background-${counterBackground}`;

                // Apply custom font size if specified
                if (config.counterCustomFontSize && config.counterCustomFontSize.trim() !== '') {
                    photoCounter.style.fontSize = config.counterCustomFontSize;
                } else {
                    photoCounter.style.fontSize = ''; // Clear custom font size
                }

                photoCounter.style.position = 'absolute';
                photoCounter.style.zIndex = '10';
                photoCounter.style.top = 'auto';
                photoCounter.style.right = 'auto';
                photoCounter.style.bottom = 'auto';
                photoCounter.style.left = 'auto';
                photoCounter.style.transform = 'none';

                // Check if custom coordinates are provided
                const hasCustomX = config.counterCustomX && config.counterCustomX.toString().trim() !== '';
                const hasCustomY = config.counterCustomY && config.counterCustomY.toString().trim() !== '';

                console.log('Counter positioning debug:', {
                    counterCustomX: config.counterCustomX,
                    counterCustomY: config.counterCustomY,
                    hasCustomX,
                    hasCustomY,
                    counterPosition: counterPos
                });

                if (hasCustomX || hasCustomY) {
                    // Use custom positioning - clear preset styles first
                    photoCounter.style.top = 'auto';
                    photoCounter.style.right = 'auto';
                    photoCounter.style.bottom = 'auto';
                    photoCounter.style.left = 'auto';
                    photoCounter.style.transform = 'none';

                    if (hasCustomX) {
                        photoCounter.style.left = config.counterCustomX;
                    }
                    if (hasCustomY) {
                        photoCounter.style.top = config.counterCustomY;
                    }
                } else {
                    // Use preset position - clear all custom positioning first
                    photoCounter.style.top = 'auto';
                    photoCounter.style.right = 'auto';
                    photoCounter.style.bottom = 'auto';
                    photoCounter.style.left = 'auto';
                    photoCounter.style.transform = 'none';

                    switch(counterPos) {
                        case 'top-left':
                            photoCounter.style.top = '20px';
                            photoCounter.style.left = '20px';
                            break;
                        case 'top-center':
                            photoCounter.style.top = '20px';
                            photoCounter.style.left = '50%';
                            photoCounter.style.transform = 'translateX(-50%)';
                            break;
                        case 'top-right':
                            photoCounter.style.top = '20px';
                            photoCounter.style.right = '20px';
                            break;
                        case 'left':
                            photoCounter.style.top = '50%';
                            photoCounter.style.left = '20px';
                            photoCounter.style.transform = 'translateY(-50%)';
                            break;
                        case 'center':
                            photoCounter.style.top = '50%';
                            photoCounter.style.left = '50%';
                            photoCounter.style.transform = 'translate(-50%, -50%)';
                            break;
                        case 'right':
                            photoCounter.style.top = '50%';
                            photoCounter.style.right = '20px';
                            photoCounter.style.transform = 'translateY(-50%)';
                            break;
                        case 'bottom-left':
                            photoCounter.style.bottom = '20px';
                            photoCounter.style.left = '20px';
                            break;
                        case 'bottom-center':
                            photoCounter.style.bottom = '20px';
                            photoCounter.style.left = '50%';
                            photoCounter.style.transform = 'translateX(-50%)';
                            break;
                        case 'bottom-right':
                            photoCounter.style.bottom = '20px';
                            photoCounter.style.right = '20px';
                            break;
                        case 'custom':
                            // Custom position handled above, do nothing here
                            break;
                    }
                }

                // Apply custom color if specified
                if (config.counterColor) {
                    photoCounter.style.color = config.counterColor;
                }

                // Apply background opacity if background is not 'none'
                if (counterBackground !== 'none' && config.counterBackgroundOpacity !== undefined) {
                    const currentBg = window.getComputedStyle(photoCounter).backgroundColor;
                    if (currentBg && currentBg !== 'rgba(0, 0, 0, 0)') {
                        // Extract RGB values and apply new opacity
                        const rgbMatch = currentBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            const opacity = config.counterBackgroundOpacity / 100;
                            photoCounter.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                }

                // Apply general opacity
                photoCounter.style.opacity = config.counterOpacity || 0.8;

                // Apply advanced styling options
                if (config.counterBorderRadius && config.counterBorderRadius.trim() !== '') {
                    photoCounter.style.borderRadius = config.counterBorderRadius;
                } else {
                    photoCounter.style.borderRadius = ''; // Clear custom border radius
                }

                if (config.counterPadding && config.counterPadding.trim() !== '') {
                    photoCounter.style.padding = config.counterPadding;
                } else {
                    photoCounter.style.padding = ''; // Clear custom padding
                }

                if (config.counterShadow && config.counterShadow.trim() !== '') {
                    photoCounter.style.boxShadow = config.counterShadow;
                } else {
                    photoCounter.style.boxShadow = ''; // Clear custom shadow
                }
            } else if (photoCounter) {
                photoCounter.style.display = 'none';
            }
        }

        // Expose updateConfig function for backend communication
        window.updateConfig = function(newConfig) {
            // Temporarily disable activity detection during config update to prevent cascade
            const wasActivityEnabled = window.activityDetectionEnabled;
            window.activityDetectionEnabled = false;

            // Merge new config with existing config
            Object.assign(config, newConfig);

            // Re-apply source indicator styling if any source option changed
            if (currentPhotoIndex !== -1 && (newConfig.sourcePosition || newConfig.sourceBackground ||
                newConfig.sourceColor || newConfig.sourceFontSize || newConfig.sourceBackgroundOpacity || newConfig.sourceSize || newConfig.sourceOpacity || newConfig.sourceBorderRadius || newConfig.sourcePadding || newConfig.sourceShadow || newConfig.sourceCustomX || newConfig.sourceCustomY)) {
                applySourceIndicatorPosition();
            }

            // Re-apply counter styling if any counter option changed
            if (newConfig.counterPosition || newConfig.counterBackground ||
                newConfig.counterColor || newConfig.counterFontSize || newConfig.counterBackgroundOpacity || newConfig.counterSize || newConfig.counterOpacity || newConfig.counterBorderRadius || newConfig.counterPadding || newConfig.counterShadow || newConfig.counterCustomX || newConfig.counterCustomY || newConfig.showPhotoCounter !== undefined) {
                applyPhotoCounterPosition();
            }

            // Re-apply clock styling if any clock option changed
            if (newConfig.clockFontSize || newConfig.clockCustomFontSize || newConfig.clockColor || newConfig.clockBackground || newConfig.clockOpacity || newConfig.clockPosition || newConfig.clockBackgroundOpacity || newConfig.clockBorderRadius || newConfig.clockPadding || newConfig.clockShadow || newConfig.clockCustomX || newConfig.clockCustomY || newConfig.showClock !== undefined) {
                applyClock();
            }

            // Re-apply date styling if any date option changed
            if (newConfig.dateFontSize || newConfig.dateCustomFontSize || newConfig.dateColor || newConfig.dateBackground || newConfig.dateSize || newConfig.dateOpacity || newConfig.datePosition || newConfig.dateAlignment || newConfig.dateBackgroundOpacity || newConfig.dateBorderRadius || newConfig.datePadding || newConfig.dateShadow || newConfig.dateCustomX || newConfig.dateCustomY || newConfig.showDate !== undefined) {
                applyDate();
            }

            // Re-apply metadata styling if any metadata option changed
            if (newConfig.metadataColor || newConfig.metadataBackground || newConfig.metadataFontSize || newConfig.metadataBackgroundOpacity || newConfig.metadataBorderRadius || newConfig.metadataPadding || newConfig.metadataShadow || newConfig.metadataCustomX || newConfig.metadataCustomY) {
                if (currentPhotoIndex !== -1) {
                    updateMetadataOverlay();
                }
            }

            // Restore activity detection state after a delay to ensure DOM updates complete
            // Use longer delay for editor mode changes which trigger more extensive UI updates
            const delay = newConfig.editorMode !== undefined ? 200 : 50;
            setTimeout(() => {
                window.activityDetectionEnabled = wasActivityEnabled;
                console.log('Activity detection restored after config update');
            }, delay);
        };

        // Listen for slideshow ready event - backend handles visibility
        ipcRenderer.on('slideshow-ready', () => {
            console.log('Slideshow content ready - backend will handle elegant animations');
        });

        // Animation functions
        function applySlideshowEntranceAnimation(duration = 400) {
            console.log('Applying elegant entrance animation with duration:', duration + 'ms');

            // Set animation duration via CSS custom property
            document.documentElement.style.setProperty('--animation-duration', duration + 'ms');

            document.body.classList.add('animate-elegant-in');
            document.body.classList.remove('animate-elegant-out');

            // Remove the animation class after it completes and ensure background stays black
            window.animationController.scheduleTimeout(() => {
                document.body.classList.remove('animate-elegant-in');
                // Ensure background is black for normal slideshow operation (hide image transitions)
                document.body.style.backgroundColor = 'black';
                console.log('Entrance animation complete - background set to black for slideshow operation');
            }, duration, 'entrance_cleanup');
        }

        function applySlideshowExitAnimation(duration = 400) {
            console.log('Applying elegant exit animation with duration:', duration + 'ms');

            // Set animation duration via CSS custom property
            document.documentElement.style.setProperty('--animation-duration', duration + 'ms');

            // Prepare for exit by making background transparent for smooth fade out
            console.log('Preparing exit animation - making background transparent for smooth fade');
            document.body.style.backgroundColor = 'transparent';

            document.body.classList.add('animate-elegant-out');
            document.body.classList.remove('animate-elegant-in');

            // Remove the animation class after it completes and ensure background stays transparent
            window.animationController.scheduleTimeout(() => {
                document.body.classList.remove('animate-elegant-out');
                // Keep background transparent after exit
                document.body.style.backgroundColor = 'transparent';
                console.log('Exit animation complete - background remains transparent');
            }, duration, 'exit_cleanup');
        }

        // Listen for animation events from backend
        ipcRenderer.on('apply-entrance-animation', (event, duration) => {
            applySlideshowEntranceAnimation(duration);
        });

        ipcRenderer.on('apply-exit-animation', (event, duration) => {
            applySlideshowExitAnimation(duration);
        });

        // Central Animation Controller - replaces scattered setTimeout calls
        class AnimationController {
            constructor() {
                this.activeAnimations = new Map();
                this.frameId = null;
                this.timers = new Map();
                this.isRunning = false;
            }

            // RequestAnimationFrame-based smooth transitions
            smoothTransition(element, property, from, to, duration, callback) {
                const id = `${element.id || 'element'}_${property}_${Date.now()}`;
                const start = performance.now();

                const animate = (now) => {
                    const progress = Math.min((now - start) / duration, 1);
                    const value = from + (to - from) * this.easeOutCubic(progress);

                    element.style[property] = typeof value === 'number' ? value + 'px' : value;

                    if (progress < 1) {
                        this.activeAnimations.set(id, requestAnimationFrame(animate));
                    } else {
                        this.activeAnimations.delete(id);
                        if (callback) callback();
                    }
                };

                this.activeAnimations.set(id, requestAnimationFrame(animate));
                return id;
            }

            // Easing function for smooth animations
            easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }

            // Replace setTimeout with coordinated timing
            scheduleTimeout(callback, delay, id = null) {
                const timerId = id || `timeout_${Date.now()}`;
                const start = performance.now();

                const checkTimer = (now) => {
                    if (now - start >= delay) {
                        this.timers.delete(timerId);
                        callback();
                    } else {
                        this.timers.set(timerId, requestAnimationFrame(checkTimer));
                    }
                };

                this.timers.set(timerId, requestAnimationFrame(checkTimer));
                return timerId;
            }

            // Replace setInterval with coordinated timing
            scheduleInterval(callback, interval, id = null) {
                const intervalId = id || `interval_${Date.now()}`;
                let lastCall = performance.now();

                const checkInterval = (now) => {
                    if (now - lastCall >= interval) {
                        lastCall = now;
                        callback();
                    }
                    this.timers.set(intervalId, requestAnimationFrame(checkInterval));
                };

                this.timers.set(intervalId, requestAnimationFrame(checkInterval));
                return intervalId;
            }

            // Clear timer
            clearTimer(id) {
                if (this.timers.has(id)) {
                    cancelAnimationFrame(this.timers.get(id));
                    this.timers.delete(id);
                }
                if (this.activeAnimations.has(id)) {
                    cancelAnimationFrame(this.activeAnimations.get(id));
                    this.activeAnimations.delete(id);
                }
            }

            // Clear all animations and timers
            clearAll() {
                this.activeAnimations.forEach(id => cancelAnimationFrame(id));
                this.timers.forEach(id => cancelAnimationFrame(id));
                this.activeAnimations.clear();
                this.timers.clear();
            }
        }

        // Memory Management System
        class MemoryManager {
            constructor() {
                this.imageReferences = new Set();
                this.maxImages = 10; // Keep only 10 images in memory
                this.memoryPressureThreshold = 150 * 1024 * 1024; // 150MB
                this.cleanupInterval = null;
                this.isMonitoring = false;
            }

            // Track image element for cleanup
            trackImage(imgElement, id = null) {
                const imageId = id || `img_${Date.now()}_${Math.random()}`;
                imgElement.dataset.memoryId = imageId;
                this.imageReferences.add({
                    id: imageId,
                    element: imgElement,
                    timestamp: Date.now()
                });

                // Auto-cleanup if we exceed max images
                if (this.imageReferences.size > this.maxImages) {
                    this.cleanupOldImages();
                }

                return imageId;
            }

            // Release specific image from memory
            releaseImage(imgElement) {
                if (!imgElement) return;

                const imageId = imgElement.dataset.memoryId;

                // Clear image source and data
                imgElement.src = '';
                imgElement.srcset = '';
                imgElement.removeAttribute('src');
                imgElement.removeAttribute('srcset');

                // Remove from tracking
                if (imageId) {
                    this.imageReferences.forEach(ref => {
                        if (ref.id === imageId) {
                            this.imageReferences.delete(ref);
                        }
                    });
                    delete imgElement.dataset.memoryId;
                }

                console.log(`Released image from memory: ${imageId || 'unknown'}`);
            }

            // Clean up oldest images when over limit
            cleanupOldImages() {
                const sortedImages = Array.from(this.imageReferences)
                    .sort((a, b) => a.timestamp - b.timestamp);

                const toRemove = sortedImages.slice(0, sortedImages.length - this.maxImages);

                toRemove.forEach(ref => {
                    this.releaseImage(ref.element);
                });

                console.log(`Cleaned up ${toRemove.length} old images from memory`);
            }

            // Force cleanup of all tracked images
            cleanupAll() {
                this.imageReferences.forEach(ref => {
                    this.releaseImage(ref.element);
                });
                this.imageReferences.clear();
                console.log('Released all tracked images from memory');
            }

            // Start memory pressure monitoring
            startMonitoring() {
                if (this.isMonitoring) return;

                this.isMonitoring = true;
                this.cleanupInterval = window.animationController.scheduleInterval(() => {
                    // Check memory usage (approximate)
                    if (performance.memory && performance.memory.usedJSHeapSize > this.memoryPressureThreshold) {
                        console.log('Memory pressure detected, triggering cleanup');
                        this.cleanupOldImages();

                        // Force garbage collection if available
                        if (window.gc) {
                            window.gc();
                        }
                    }
                }, 30000, 'memory_monitor'); // Check every 30 seconds
            }

            // Stop monitoring
            stopMonitoring() {
                if (this.cleanupInterval) {
                    window.animationController.clearTimer(this.cleanupInterval);
                    this.cleanupInterval = null;
                }
                this.isMonitoring = false;
            }

            // Get memory usage info
            getMemoryInfo() {
                const info = {
                    trackedImages: this.imageReferences.size,
                    maxImages: this.maxImages
                };

                if (performance.memory) {
                    info.heapUsed = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                    info.heapTotal = Math.round(performance.memory.totalJSHeapSize / 1024 / 1024);
                    info.heapLimit = Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024);
                }

                return info;
            }
        }

        // Global memory manager instance
        window.memoryManager = new MemoryManager();

        // Performance Monitoring Dashboard
        class PerformanceMonitor {
            constructor() {
                this.metrics = {
                    frameRate: 0,
                    frameTimes: [],
                    maxFrameTime: 16.67, // 60fps target
                    memoryUsage: 0,
                    transitionCount: 0,
                    lastTransitionTime: 0
                };
                this.isMonitoring = false;
                this.monitoringInterval = null;
                this.frameStartTime = 0;
                this.debugMode = false;
            }

            // Start performance monitoring
            startMonitoring() {
                if (this.isMonitoring) return;

                this.isMonitoring = true;
                this.frameStartTime = performance.now();

                // Monitor frame rate using requestAnimationFrame
                const measureFrameRate = () => {
                    const now = performance.now();
                    const frameTime = now - this.frameStartTime;

                    this.metrics.frameTimes.push(frameTime);

                    // Keep only last 60 frame times (1 second at 60fps)
                    if (this.metrics.frameTimes.length > 60) {
                        this.metrics.frameTimes.shift();
                    }

                    // Calculate average frame rate
                    const avgFrameTime = this.metrics.frameTimes.reduce((a, b) => a + b, 0) / this.metrics.frameTimes.length;
                    this.metrics.frameRate = Math.round(1000 / avgFrameTime);

                    this.frameStartTime = now;

                    if (this.isMonitoring) {
                        requestAnimationFrame(measureFrameRate);
                    }
                };

                requestAnimationFrame(measureFrameRate);

                // Monitor memory and other metrics every 5 seconds
                this.monitoringInterval = window.animationController.scheduleInterval(() => {
                    this.updateMetrics();
                    if (this.debugMode) {
                        this.logMetrics();
                    }
                }, 5000, 'performance_monitor');
            }

            // Stop monitoring
            stopMonitoring() {
                this.isMonitoring = false;
                if (this.monitoringInterval) {
                    window.animationController.clearTimer(this.monitoringInterval);
                    this.monitoringInterval = null;
                }
            }

            // Update performance metrics
            updateMetrics() {
                // Memory usage
                if (performance.memory) {
                    this.metrics.memoryUsage = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                }

                // Memory manager stats
                const memInfo = window.memoryManager.getMemoryInfo();
                this.metrics.trackedImages = memInfo.trackedImages;
                this.metrics.heapUsed = memInfo.heapUsed;
                this.metrics.heapTotal = memInfo.heapTotal;
            }

            // Log transition timing
            logTransition(duration) {
                this.metrics.transitionCount++;
                this.metrics.lastTransitionTime = duration;
            }

            // Get current performance metrics
            getMetrics() {
                this.updateMetrics();
                return {
                    ...this.metrics,
                    timestamp: Date.now(),
                    averageFrameTime: this.metrics.frameTimes.length > 0 ?
                        Math.round(this.metrics.frameTimes.reduce((a, b) => a + b, 0) / this.metrics.frameTimes.length * 100) / 100 : 0
                };
            }

            // Log metrics to console
            logMetrics() {
                const metrics = this.getMetrics();
                console.log('ðŸ“Š Performance Metrics:', {
                    FPS: metrics.frameRate,
                    'Avg Frame Time': metrics.averageFrameTime + 'ms',
                    'Memory (MB)': metrics.memoryUsage,
                    'Tracked Images': metrics.trackedImages,
                    'Transitions': metrics.transitionCount
                });
            }

            // Enable debug mode with detailed logging
            enableDebugMode() {
                this.debugMode = true;
                console.log('ðŸ” Performance debug mode enabled');
            }

            // Disable debug mode
            disableDebugMode() {
                this.debugMode = false;
                console.log('ðŸ” Performance debug mode disabled');
            }

            // Generate performance report
            generateReport() {
                const metrics = this.getMetrics();
                const report = {
                    timestamp: new Date().toISOString(),
                    performance: {
                        targetFPS: 60,
                        currentFPS: metrics.frameRate,
                        fpsEfficiency: Math.round((metrics.frameRate / 60) * 100) + '%',
                        averageFrameTime: metrics.averageFrameTime + 'ms',
                        targetFrameTime: this.maxFrameTime + 'ms'
                    },
                    memory: {
                        currentUsage: metrics.memoryUsage + 'MB',
                        trackedImages: metrics.trackedImages,
                        heapUsed: metrics.heapUsed + 'MB',
                        heapTotal: metrics.heapTotal + 'MB'
                    },
                    activity: {
                        totalTransitions: metrics.transitionCount,
                        lastTransitionTime: metrics.lastTransitionTime + 'ms'
                    }
                };

                console.log('ðŸ“ˆ Performance Report:', report);
                return report;
            }
        }

        // Visual Preset Editor for drag-and-drop layout design
        window.PresetEditor = class PresetEditor {
            constructor() {
                this.isActive = false;
                this.selectedElement = null;
                this.isDragging = false;
                this.dragStartPos = null;
                this.elementStartPos = null;
                this.gridSize = 10;
                this.showGrid = true;
                this.snapToGrid = true;
                this.updateDebouncer = {};

                // Bind methods
                this.handleMouseDown = this.handleMouseDown.bind(this);
                this.handleMouseMove = this.handleMouseMove.bind(this);
                this.handleMouseUp = this.handleMouseUp.bind(this);
                this.handleElementClick = this.handleElementClick.bind(this);
            }

            // Enter editor mode
            enter() {
                if (this.isActive) return;
                this.isActive = true;
                console.log('Entering preset editor mode');

                // Disable activity detection to prevent slideshow from hiding
                this.savedActivityDetection = window.activityDetectionEnabled;
                window.activityDetectionEnabled = false;
                console.log('Activity detection disabled for editor mode');

                // Backend handles slideshow timer management
                if (window.isSlideshowActive) {
                    this.wasPlaying = true;
                } else {
                    this.wasPlaying = false;
                }

                // Show all UI elements
                this.showAllElements();

                // Make elements interactive
                this.makeElementsInteractive();

                // Add visual helpers
                if (this.showGrid) {
                    this.addGrid();
                }

                // Add editor class to body
                document.body.classList.add('editor-mode');

                // Show editor notification
                this.showNotification('Editor Mode Active - Drag elements to reposition');
            }

            // Exit editor mode
            exit() {
                if (!this.isActive) return;
                this.isActive = false;
                console.log('Exiting preset editor mode');

                // Restore activity detection
                window.activityDetectionEnabled = this.savedActivityDetection !== undefined ? this.savedActivityDetection : true;
                console.log('Activity detection restored');

                // Remove interactive state
                this.removeElementInteractivity();

                // Remove visual helpers
                this.removeGrid();
                this.removeNotification();

                // Remove editor class
                document.body.classList.remove('editor-mode');

                // Backend handles slideshow timer management
                // No frontend timer restart needed
            }

            // Show all UI elements for editing
            showAllElements() {
                const elements = ['clock', 'date', 'source', 'counter', 'metadata'];
                elements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.style.display = 'block';
                        element.style.opacity = '1';
                    }
                });
            }

            // Make elements interactive
            makeElementsInteractive() {
                const elements = ['clock', 'date', 'source', 'counter', 'metadata'];
                elements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.classList.add('editor-element');
                        element.addEventListener('mousedown', this.handleMouseDown);
                        element.addEventListener('click', this.handleElementClick);
                        element.style.cursor = 'move';
                    }
                });

                // Add global mouse listeners
                document.addEventListener('mousemove', this.handleMouseMove);
                document.addEventListener('mouseup', this.handleMouseUp);
            }

            // Remove element interactivity
            removeElementInteractivity() {
                const elements = ['clock', 'date', 'source', 'counter', 'metadata'];
                elements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.classList.remove('editor-element', 'selected');
                        element.removeEventListener('mousedown', this.handleMouseDown);
                        element.removeEventListener('click', this.handleElementClick);
                        element.style.cursor = 'default';
                    }
                });

                // Remove global mouse listeners
                document.removeEventListener('mousemove', this.handleMouseMove);
                document.removeEventListener('mouseup', this.handleMouseUp);
            }

            // Handle element click for selection
            handleElementClick(e) {
                e.stopPropagation();
                if (this.isDragging) return;

                // Remove previous selection
                if (this.selectedElement) {
                    this.selectedElement.classList.remove('selected');
                }

                // Select new element
                this.selectedElement = e.currentTarget;
                this.selectedElement.classList.add('selected');
                console.log(`Selected element: ${this.selectedElement.id}`);
            }

            // Handle mouse down for drag start
            handleMouseDown(e) {
                e.preventDefault();
                e.stopPropagation();

                this.isDragging = true;
                this.selectedElement = e.currentTarget;
                this.selectedElement.classList.add('dragging');

                // Store initial positions
                this.dragStartPos = { x: e.clientX, y: e.clientY };
                this.elementStartPos = {
                    x: this.selectedElement.offsetLeft,
                    y: this.selectedElement.offsetTop
                };

                console.log(`Started dragging ${this.selectedElement.id}`);
            }

            // Handle mouse move for dragging
            handleMouseMove(e) {
                if (!this.isDragging || !this.selectedElement) return;

                // Calculate new position
                let newX = this.elementStartPos.x + (e.clientX - this.dragStartPos.x);
                let newY = this.elementStartPos.y + (e.clientY - this.dragStartPos.y);

                // Apply grid snapping if enabled
                if (this.snapToGrid) {
                    newX = Math.round(newX / this.gridSize) * this.gridSize;
                    newY = Math.round(newY / this.gridSize) * this.gridSize;
                }

                // Apply boundary constraints
                newX = Math.max(0, Math.min(newX, window.innerWidth - this.selectedElement.offsetWidth));
                newY = Math.max(0, Math.min(newY, window.innerHeight - this.selectedElement.offsetHeight));

                // Apply new position
                this.selectedElement.style.left = newX + 'px';
                this.selectedElement.style.top = newY + 'px';
                this.selectedElement.style.position = 'fixed';

                // Debounced MQTT update
                this.updatePositionDebounced(this.selectedElement.id, newX, newY);
            }

            // Handle mouse up for drag end
            handleMouseUp(e) {
                if (!this.isDragging || !this.selectedElement) return;

                this.isDragging = false;
                this.selectedElement.classList.remove('dragging');

                // Send final position to MQTT
                const finalX = parseInt(this.selectedElement.style.left);
                const finalY = parseInt(this.selectedElement.style.top);
                this.updatePositionFinal(this.selectedElement.id, finalX, finalY);

                console.log(`Finished dragging ${this.selectedElement.id} to (${finalX}, ${finalY})`);
            }

            // Debounced position update for smooth dragging
            updatePositionDebounced(elementId, x, y) {
                clearTimeout(this.updateDebouncer[elementId]);
                this.updateDebouncer[elementId] = setTimeout(() => {
                    // Send position update via IPC
                    window.electronAPI?.send('slideshow-config-update', {
                        [`${elementId}CustomX`]: x + 'px',
                        [`${elementId}CustomY`]: y + 'px',
                        [`${elementId}Position`]: 'custom'
                    });
                }, 100);
            }

            // Final position update when drag ends
            updatePositionFinal(elementId, x, y) {
                clearTimeout(this.updateDebouncer[elementId]);

                // Send final position via IPC
                window.electronAPI?.send('slideshow-config-update', {
                    [`${elementId}CustomX`]: x + 'px',
                    [`${elementId}CustomY`]: y + 'px',
                    [`${elementId}Position`]: 'custom'
                });

                // Update config object
                if (window.config) {
                    window.config[`${elementId}CustomX`] = x + 'px';
                    window.config[`${elementId}CustomY`] = y + 'px';
                    window.config[`${elementId}Position`] = 'custom';
                }
            }

            // Add grid overlay
            addGrid() {
                const grid = document.createElement('div');
                grid.id = 'editor-grid';
                grid.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background-size: ${this.gridSize}px ${this.gridSize}px;
                    background-image:
                        linear-gradient(rgba(255,255,255,0.2) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(255,255,255,0.2) 1px, transparent 1px);
                    pointer-events: none;
                    z-index: 9998;
                `;

                // Add major grid lines every 50px
                const majorGrid = document.createElement('div');
                majorGrid.id = 'editor-major-grid';
                majorGrid.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background-size: 50px 50px;
                    background-image:
                        linear-gradient(rgba(74, 144, 226, 0.3) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(74, 144, 226, 0.3) 1px, transparent 1px);
                    pointer-events: none;
                    z-index: 9997;
                `;

                document.body.appendChild(majorGrid);
                document.body.appendChild(grid);
            }

            // Remove grid overlay
            removeGrid() {
                const grid = document.getElementById('editor-grid');
                const majorGrid = document.getElementById('editor-major-grid');
                if (grid) grid.remove();
                if (majorGrid) majorGrid.remove();
            }

            // Show editor notification
            showNotification(message) {
                const notification = document.createElement('div');
                notification.id = 'editor-notification';
                notification.textContent = message;
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(74, 144, 226, 0.9);
                    color: white;
                    padding: 12px 24px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 600;
                    z-index: 10001;
                    animation: slideIn 0.3s ease-out;
                `;
                document.body.appendChild(notification);
            }

            // Remove notification
            removeNotification() {
                const notification = document.getElementById('editor-notification');
                if (notification) notification.remove();
            }

            // Toggle editor mode
            toggle() {
                if (this.isActive) {
                    this.exit();
                } else {
                    this.enter();
                }
            }
        }

        // Add editor styles
        const editorStyles = document.createElement('style');
        editorStyles.textContent = `
            /* Editor Mode Styles */
            .editor-mode {
                cursor: default !important;
            }

            .editor-element {
                transition: box-shadow 0.2s, transform 0.2s;
            }

            .editor-element:hover {
                box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.8);
                transform: scale(1.02);
            }

            .editor-element.selected {
                box-shadow: 0 0 0 2px rgba(46, 204, 113, 1);
            }

            .editor-element.dragging {
                opacity: 0.8;
                transform: scale(1.05);
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                z-index: 10000 !important;
                cursor: move !important;
            }

            .editor-element.editor-hidden {
                opacity: 0.3 !important;
                border: 2px dashed rgba(255, 255, 255, 0.3);
            }

            .editor-element.editor-hidden:hover {
                opacity: 0.5 !important;
                box-shadow: 0 0 0 2px rgba(255, 165, 0, 0.8);
            }

            @keyframes slideIn {
                from {
                    opacity: 0;
                    transform: translateX(-50%) translateY(-10px);
                }
                to {
                    opacity: 1;
                    transform: translateX(-50%) translateY(0);
                }
            }
        `;
        document.head.appendChild(editorStyles);

        // Global preset editor instance
        window.presetEditor = new window.PresetEditor();

        // Create debug grid immediately when page loads
        function createDebugGrid() {
            // Remove any existing grid
            const existingGrid = document.getElementById('debug-grid');
            if (existingGrid) existingGrid.remove();

            // Create new grid
            const grid = document.createElement('div');
            grid.id = 'debug-grid';
            grid.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background-size: 50px 50px;
                background-image:
                    linear-gradient(rgba(255,0,0,0.8) 2px, transparent 2px),
                    linear-gradient(90deg, rgba(255,0,0,0.8) 2px, transparent 2px);
                pointer-events: none;
                z-index: 9998;
                display: none;
            `;
            document.body.appendChild(grid);
            console.log('Debug grid created and added to body');
            return grid;
        }

        // Create the grid immediately
        const debugGrid = createDebugGrid();

        // Function to toggle grid visibility
        window.toggleDebugGrid = function(show) {
            const grid = document.getElementById('debug-grid');
            if (grid) {
                grid.style.display = show ? 'block' : 'none';
                console.log('Debug grid toggled:', show ? 'visible' : 'hidden');
            }
        };

        // Global performance monitor instance
        window.performanceMonitor = new PerformanceMonitor();

        // Global animation controller instance
        window.animationController = new AnimationController();

        // Replace clock interval with animation controller
        if (typeof clockInterval !== 'undefined' && clockInterval) {
            clearInterval(clockInterval);
        }

        // Use animation controller for clock updates
        window.animationController.scheduleInterval(updateClock, 1000, 'clock_update');

        // Start memory monitoring
        window.memoryManager.startMonitoring();

        // Start performance monitoring
        window.performanceMonitor.startMonitoring();

        console.log('Slideshow HTML loaded with Animation Controller, Memory Manager, and Performance Monitor ready');

        // Create editor grid immediately as global element
        // Simple visible grid overlay for editor mode
        let editorGridOverlay = null;

        window.showEditorGrid = function(show) {
            if (show && !editorGridOverlay) {
                // Create bright visible grid
                editorGridOverlay = document.createElement('div');
                editorGridOverlay.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background-size: 20px 20px;
                    background-image:
                        linear-gradient(rgba(0,255,0,0.9) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(0,255,0,0.9) 1px, transparent 1px);
                    pointer-events: none;
                    z-index: 5;
                `;
                document.body.appendChild(editorGridOverlay);
                console.log('Bright green editor grid created and shown');
            } else if (!show && editorGridOverlay) {
                // Remove grid overlay
                if (editorGridOverlay.parentNode) {
                    document.body.removeChild(editorGridOverlay);
                }
                editorGridOverlay = null;
                console.log('Editor grid removed');
            }
        };

        console.log('Simple editor grid system ready');

        // TEST: Create always-visible grid to verify z-index and visibility
        const testGrid = document.createElement('div');
        testGrid.id = 'test-grid';
        testGrid.style.cssText = `
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-size: 40px 40px;
            background-image:
                linear-gradient(rgba(255,0,0,0.7) 2px, transparent 2px),
                linear-gradient(90deg, rgba(255,0,0,0.7) 2px, transparent 2px);
            pointer-events: none;
            z-index: 99999;
        `;
        document.body.appendChild(testGrid);
        console.log('TEST: Red grid overlay created with z-index 99999');
    </script>
</body>
</html>